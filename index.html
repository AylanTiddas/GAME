<!DOCTYPE html>

<html data-theme="kabylie" lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- Security hardening -->
<meta content="default-src 'self' data: blob:; base-uri 'self'; object-src 'none'; frame-ancestors 'none'; form-action 'self'; img-src 'self' data: blob:; media-src 'self' data: blob:; font-src 'self' data:; style-src 'self' 'nonce-tiddas'; script-src 'self' 'nonce-tiddas'; connect-src 'self'; upgrade-insecure-requests; worker-src 'self' blob:; manifest-src 'self' blob:" http-equiv="Content-Security-Policy"/>
<meta content="no-referrer" name="referrer"/>
<meta content="camera=(), microphone=(), geolocation=(), payment=(), usb=()" http-equiv="Permissions-Policy"/>
<meta content="dark light" name="color-scheme"/>
<title data-i18n="appTitle">Tiddas - Jeu</title>
<link href="#" id="pwa-manifest" rel="manifest"/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABJklEQVR42s2XvQ2DMBCFzyf37JAUiaWEliYzIDFBZmMClqChDUhAATswQVJZMpYNxn/kKkD2fc93z8gmIMTjdvlChOjGmfBnjA2XWRgbLosgZ8DFQNXHdpiYb5AuJ1UOzPO+HSa2NEXvA55kFVuaom+HiT3v11VOZQt8wkURMlxZAQAADn+9P7uJ6zKFvbF1mYJuQdREPYccHWOyAPQBd5lLbZPz1elaYCoc4eSgvsprYkYnAXLJjwoL5gFXs9KQDncWIEJ8AYO3QLU9t8TTPYhucpQW6Fa8BT+6C9C2/KIg+T2KB3y1g4aG7JkQj7rdZadYV0CXyPb//1dHMtTBk6xiPuH8oGtcAZVa12O5Kuf5FxPxohg7unEmKN9WY8JXJowpQmT9ABkqrop8prLHAAAAAElFTkSuQmCC"/>
<link rel="icon" type="image/png" sizes="192x192" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAYAAABS3GwHAAAGIklEQVR42u3dMU7jQBSH8dhKzx1IQSKRbWk4AxIn4Gx7AqScYRtaQAoUcAdOwBZLslFwIA7xeDzv9zUrLQWx/f/ee2NPcDXqgfOz0/cRsMXj82uV+ndWAo/IQlRCj8gyVEKPyDLUwo+hccysVYKPyN2gFn5E7gaV4CNyN6iFH5G7QS38iCxBLfyILEEt/IgsQS38iCxBLfyILEHtFCEyteqPyF2gFn5ElsAIBCOQ6o+oXaAWfkSWwAgEIxAQlSr1+PPw9DLb/r/5dLJ0KeLRZxZWW6fHyQ/26mq562dEiBX8t7vr3rOQpAM8PL3MmoL/icViRoLyw98U/G1OLm47zcKqA9TZhP+jOzS1RcQK/6o7dJmFVebrrg947/CTQPgTS9C5AEDu1F0a37r66wKqf+IuUHv6i6icn52+j3P+gH9+/3KVMMwRCCAAEFWA+XSyHC0Why1eFouDF03Ij7e76+XJxe1BWej6gZgOgNBUXd8Fan07NMh2iKYF/uXNfdHH3PZ2aNfVP0kHaDUK2QtUNPPpZO9RKEX4R6NEu0Hn08nyq92gK0GEP4YEX+0GXQmSKgvjlAe+HokaFkmiEWtRvBn2ppykYtxHBdg1AyOmCH2uf9wFQmgIAAIABAAIABAAIAAQgbFTkI7vnn38+f2r+P1AOkDQ4O/74M8DQh0gRLXXCQgg+CCA0IMAgg8CCG0OnzPa2mMs+Gg6T1FEGAs+IotQCz8in0MPwmARHKlybbb03KpbDuNG0zkp+cFcqLtAlzf3vYY+Z/lyOUdGoA6rf5+3FodUQZs+a6lSeBBW8DgDAgg+YgiQy2wPAoQIvtATQLUHAcz1GDK1QH79e4RfB1DtoQNECWqbL7BDByiWiK8wIgBIQQCQggCDDB4poAMQFi3wjbDMJCGKDrAXJe9Z/+44jFM6wM5gRAiHTqED/KhjlNwpdAcCHDQ+lSIGKQhgXUEKApDisIW2vw2K0ERbXBOgw3GitDBtHk8pnYIAxqfQ6woCZCBFxNGDAAjTLQiA4qUY6pqAAAOWQof4OXaDFiiIh1w6QFh0BR1A0KEDCHv6z+g5AFR2AuR58XMMVslbJQgAlZ0Awg4CCDyyxW1Q6AC5cKzbaMfaqltSZW97/F1ud87pvBqBCh1jbIcgQMiZXfAJUHTo7QYlgDEGBBB26ADCDgIIOwIKcHlzn90YJOwEUOUxKGyFaBn0XP5Sgz94S4BeQrcr7CklcP/fCJStIMYwHUAVBAGg+huBIPgESHfxo4xFgm8E2hkMr0mFEeibquklFQi9BvCaVFgEB1pXkIIApNjzGLwmFWGlKOk4CECKTuXwmlToFAWMT7ZC9CCFBagOgD06hoddBCDEQEYor0kFKQgAUlgEo2eEXwcQeBBA2NN+Lq9JzWgm3g7KUC+Q6k6AMFVK2AnQaRcQsuOfYwJA2AdM7aLhu3NY8nkcR7iARh/FI/wIRATBtwbo+QL3IZ8xkAAEBwGEHQTIILA/GYMEngBhJBB2AoSTQOjT4/sAIABAAIAAAAEAAgAEAAgAlEvyB2EPTy+z7f97u7teuhTxOLm4nf3Pxb9/59PJskgBVsFvCvv/EzEhQqTgX10td+UklQjjVOH/qsqvfvbw9DJLXQHQwwTQEPw1Hz9LlYW67/Bvi9A0IiFI+LdESJGF6vzs9D2H8G+3SOuCAseefcO/yWLRaSdwFwih6UyAQ6v/ahTavEOAoNU/wSikA0AHAKKS9TfCfEOqDFYPubLsAI/Pr5VLhIg8Pr9WnY1A8+nk4IXsycWtB2IFMZ9OlqPF4rCFrNugwEAXwYd0AdVfF0hV/dcCdLkOaCOB8JMgVfhXmV8Hv8stEf/uBHy/G1T4Y7B+sNX0cOxDkK6zkFyATwe/XRkQV4QesvBJgJQSAH2yOfK7C4TQEAAEaGoNQOnjT2MHIAGihN8IBCPQvqYApVX/LzsACVB6+I1AMAIdag4w9Oq/VwcgAUoN/94jEAlQYvhbrQFIgNLC33oRTAKUFP7WApAAJYV/NNraDt0W26cx1OAf3AF0A5QS/h93AN0AQw3+UTqAboAhh/+oHUBHwFBCn0QAMmAIU0UvYwshkMsY/Rc2VH/a+oUJTAAAAABJRU5ErkJggg=="/>
<link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAAF40lEQVR42u3dQU7jShRG4djKnD2QAYlEesqENSCxAtbWK0DKGnrCFJACA9gDK6AHjdMoOCE2Kdt1/Z3Jk4haz04d/763qhwXkw45Pzt9n2B0PD6/Fl39vwoCI5LgBYkRSe6CyIgkdkFkRBK7JDOGxE+dKoiMSGldkhmR0rokMyJJXZIZkaQuyYxIUpdkRiSpSzIjktQlmRFJ6tLXg0iU0hmRUrokMyJJreRA3JJDOiP3lJbQCEXRVTo/PL0stv+2nM/WhiAefYx1tTNv2tnJXV2td31G7Fgiv91d9zbWSRP64ellUSfyF1arBanzl7lO5G1OLm6TjHWV0GXvMn+kd91tCrFkrtI7xVhXDpepTvBgmUk9GplTS22WA+EoU1yxjdNZSo8mnVOndGkxBVE4Pzt9nw7xwP78/mV0oIYGCA1C72M5n60nq1W7Yn+1at1koHve7q7XJxe3rcY61QKLhEYoilSzHI2n74Iuf9c1uJc396HOsen0Xap0TprQjUoPezmyZjmfHVx6pJR5Mkm82245n6337barhCdzDKn37barhE891tMuTnRTgtQ0FVSI1SR+lrfOg9RMu7yCd9WUiCl2H/2CWQ6EgtAgNEBogNAAoUFoHJs/v3/tnKI0dUnoECKTOj1TX8FxJG7776JtVCL0CEUGoUkMQhOZ0GQMfGxjqNenRB7fXSay2FMiEzsSJZmJTWhAydFf4lze3PfWfA3pqe+6Y4m2uDOKhO5K5sub+0HLMYZZjpK0x5E4F1nqjjNSLW1hRdqpoceazCQmNJFBaBJDDU1iTDKb5UglXE6zFJDQ0lhCkxkSOuvmkuSEDi850QktzUHon6YoySGhSR4SG/xHcEeR0AMlytbH745Zso84oSOu8h36+3gYWQ393aNQuSW55NYUhipXNJ6EblWr5iS6BSFCNxY9SuPpIVk0TnfNpoTONukiPUH9+bir88rxNzsIrfnce7y5/Q4eoUmu5ADJCY3Gkg9F8JzqaLMcAZIdhM4WZYmSg6xHOC6zHJC0YxU61eAO+ZEtF6CENvAgNHkJDSJni2k7SOhjc4wpoTb7fyMkbZvvLtVe6SF8n6MpOaKUCVYKRyx0zhJ3/W5FQpNW6hKavOQlNHlBaPISWqNE3uyxsNJC3i4uKr+SpOToNHVT7hE2XUfoZBJVv25a97k32xI6jOhQQ5NLOktodT0ITWRC5zrQlsMRKqE//1JmpMaT5EqOvVJ4/QShw9elJCf0KJov71ghtDSX5oQm+TDSnNAII3ndcXvHCnZKnvsr4XJ7x4r90ANqRiGhlSsgNMnj3lEITXIJjf6bNRCawD84Du9Y6eHWvC1ATgMhfQmddboQmNCtUnqI8gxdZiuFyD4Imvx9yJRjGRzUf1fRvq9p1IFSp47zoh/FI1jEHs/da2og82z6lFaaQhcloUFeQhOy4Q+zE5jQ2UtN4jR4YqWH0oHMhAYIDUIDhAYIDRAaIDRGRGcLKw9PL4vtv73dXa8NQTxOLm4X/8f933+X89k6hNCVyHXy/j/xGbEjiXx1td7lQWqxp6ll3pfC1WcPTy+Lrq5gJAyuGpE3fHyWeqzLvmTeFruuJEEQmbfETjnWxfnZ6XufMm/fstTVGZYZh8r8mdUqSVKb5UAoji5023SuSo/PHTKCpnPC0kNCQ0IDQ2WQT6zYAJ8H1aLJoBL68fm1MDSIwOPza3H0kmM5n7Vu7E4ubi2wZMRyPltPVqt2jZ1pO6AnoduktHQeUUonSueN0Cnq6CZSk3lEUieSuXJ4I3KKJfB/nfD3u+3IHIPNQkndYsuH8KnGujOhv5zs9pWNuGJ3ONZfhO5CaiClzMmaQqAvyl2mA7mls4RG7ISW0sg5nXcmNKmRo8xKDsQvOaQ0ck3nbxOa1MhJ5oNKDlIjF5kPrqFJjRxkbtQUkhpDl7mR0KTG0GVuLDSpMWSZJ5Ot3XZNsTsPQxG5dUJLawxV5h8ntLTGUEQ+utDExhDu8klLBnKj61K10xqY4AROzV/seXuxJLIpzwAAAABJRU5ErkJggg=="/>
<meta content="#fff3bf" name="theme-color"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/>
<meta content="Tiddas" name="apple-mobile-web-app-title"/>
<style nonce="tiddas">
        :root {
    /* Core palette */
    --stone-dark: #2c2722;
    --stone-medium: #6a6054;
    --stone-light: #d0c4b2;
    --wood-dark: #5a341f;
    --wood-medium: #7c4a2b;
    --wood-light: #9d603a;

    /* Accessible text system (defaults tuned for darker themes) */
    --text-main: rgba(245,245,245,0.94);
    --text-muted: rgba(245,245,245,0.78);
    --text-light: #f5f5f5; /* kept for legacy usages */
    --text-gold: #f0c850;

    --danger-red: #ff4d4d;
    --highlight-cyan: #00ffff;
    --info-blue: #63a4ff;

    --transition-duration: 0.25s;

    --board-border-dark: #201b17;
    --board-surface-light: #2b231d;
    --parchment-bg: rgba(0,0,0,0.35);

    /* Better defaults for visibility */
    --cell-border: rgba(240, 200, 80, 0.30);
    --panel-bg: rgba(0,0,0,0.45);
    --panel-border: rgba(240,200,80,0.35);

    /* Stone colors (player setup previews) */
    --player1-stone-color-dark: #1a1a1a;
    --player1-stone-color-light: #333333;
    --player2-stone-color-dark: #cccccc;
    --player2-stone-color-light: #ffffff;

    /* Typography helpers */
    --font-title: 'Space Grotesk', var(--font-ui);
    --font-body: 'Inter', var(--font-ui);
    --font-ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
}

/* ===== Single-file UI Icons (no external font dependencies) ===== */
.icon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width: 1.15em;
  height: 1.15em;
  line-height: 1;
  font-size: 1.05em;
  transform: translateY(0.05em);
}

* {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            height: 100%;
            font-size: clamp(13px, 1.5vw, 16px);
            overflow-x: hidden;
        }
        body {
            min-height: 100vh;
            min-height: 100dvh;
            background: linear-gradient(135deg, #3a2d25, #2a201a);
            color: var(--text-main);
            font-family: var(--font-body);
            line-height: 1.45;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            position: relative;
            overflow-x: hidden;
            max-width: 100vw;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="%234a3d35" stroke-width="2" opacity="0.1"/><path d="M10,50 Q50,10 90,50 Q50,90 10,50 Z" fill="none" stroke="%234a3d35" stroke-width="1" opacity="0.05"/></svg>');
            background-size: 80px;
            display: flex;
            flex-direction: column;
            text-rendering: optimizeLegibility;
        }
        .stone-decoration {
            position: absolute;
            width: min(12vw, 50px);
            height: min(12vw, 50px);
            background: radial-gradient(circle at 30% 30%, var(--stone-medium), var(--stone-dark) 70%), linear-gradient(145deg, var(--stone-medium), var(--stone-dark));
            border-radius: 50%;
            box-shadow: inset 0 -8px 15px rgba(0,0,0,0.3), 0 8px 15px rgba(0,0,0,0.4);
            z-index: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.7rem;
            color: var(--text-main, var(--text-gold));
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0.7;
            transition: transform 0.5s ease, opacity 0.5s ease, box-shadow 0.3s ease;
            filter: saturate(1.2);
            border: 2px solid rgba(240, 200, 80, 0.2);
        }
        .stone-1 { top: 3%; left: 3%; transform: rotate(20deg); }
        .stone-2 { top: 3%; right: 3%; transform: rotate(-30deg); }
        .stone-3 { bottom: 3%; left: 3%; transform: rotate(10deg); }
        .stone-4 { bottom: 3%; right: 3%; transform: rotate(-15deg); }
        header {
            text-align: center;
            padding: 0.75rem 0 0.5rem;
            width: 100%;
            position: relative;
            flex-shrink: 0;
            transition: opacity 0.3s ease, height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
        }
        header::after {
            content: '— ⵣ —';
            display: block;
            font-size: 1.1rem;
            color: var(--text-gold);
            opacity: 0.45;
            letter-spacing: 6px;
            margin-top: 0.2rem;
        }
        header.hidden {
            opacity: 0;
            height: 0;
            padding: 0;
            pointer-events: none;
        }
        h1 {
            font-family: var(--font-title);
            font-size: clamp(2.2rem, 6vw, 3.2rem);
            margin: 0;
            color: var(--text-gold);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6), 0 0 30px rgba(240,200,80,0.25);
            letter-spacing: 5px;
            position: relative;
        }
        h1::after {
            content: 'ⵜⵉⴷⴷⴰⵙ';
            display: block;
            font-size: 0.32em;
            letter-spacing: 8px;
            opacity: 0.65;
            font-family: var(--font-body);
            color: var(--text-gold);
            text-shadow: none;
            margin-top: -0.2em;
        }
        /* language-selector styles merged into toolbar section above */
        .game-container {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: clamp(0.5rem, 2vw, 1rem);
            min-height: 0;
            overflow: hidden;
            z-index: 1;
        }
        .selection-area {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            max-width: 950px;
            max-height: calc(100dvh - 5rem);
            overflow-y: auto;
            padding: clamp(1.5rem, 4vw, 3rem);
            background: var(--panel-bg, rgba(0,0,0,0.4));
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            border: 2px solid var(--panel-border, rgba(240, 200, 80, 0.5));
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
            position: relative;
            backdrop-filter: blur(3px);
        }
        .selection-area.active { display: flex; }
        .selection-area h2 {
            font-family: var(--font-title);
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            color: var(--text-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
            margin-bottom: 1rem;
            text-align: center;
            letter-spacing: 1px;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .version-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(250px, 90vw), 1fr));
            gap: 1.5rem;
            width: 100%;
            justify-content: center;
        }
        .version-card {
            background: var(--panel-bg, rgba(0,0,0,0.3));
            border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
            border-radius: 10px;
            padding: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(3px);
        }
        .version-card:hover {
            transform: translateY(-8px) scale(1.03);
            box-shadow: 0 12px 25px rgba(0,0,0,0.5), 0 0 20px rgba(240, 200, 80, 0.6);
            border-color: var(--text-gold);
        }
        .version-card.active {
            background: var(--text-gold);
            color: var(--stone-dark);
            box-shadow: 0 0 25px rgba(240, 200, 80, 0.9), inset 0 0 15px rgba(0,0,0,0.5);
            border-color: var(--text-gold);
            transform: scale(1.05);
        }
        .version-card h3 {
            font-family: var(--font-title);
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            color: var(--text-gold);
            margin-bottom: 8px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            transition: color var(--transition-duration) ease;
        }
        .version-card.active h3 {
            color: var(--stone-dark);
            text-shadow: none;
        }
        .version-card p {
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            line-height: 1.55;
            color: var(--text-muted);
            text-shadow: none;
            transition: color var(--transition-duration) ease;
        }
        .version-card.active p { color: var(--stone-dark); }
        .rules-btn {
            margin-top: 1rem;
            padding: 0.8rem 1.8rem;
            border-radius: 8px;
            background: var(--panel-bg, rgba(0,0,0,0.3));
            border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
            color: var(--text-gold);
            font-family: var(--font-title);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .rules-btn:hover {
            background: rgba(240, 200, 80, 0.15);
            border-color: var(--text-gold);
            transform: translateY(-3px);
        }
        .options-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            width: 100%;
        }
        .option-btn {
            flex: 1;
            min-width: min(200px, 90vw);
            max-width: 280px;
            padding: 1.5rem;
            border-radius: 12px;
            background: var(--panel-bg, rgba(0,0,0,0.3));
            border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.4));
            color: var(--text-main);
            font-family: var(--font-title);
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            text-shadow: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            backdrop-filter: blur(2px);
        }
        .option-btn:hover {
            transform: translateY(-8px);
            background: rgba(240, 200, 80, 0.15);
            box-shadow: 0 12px 25px rgba(0,0,0,0.5), 0 0 20px rgba(240, 200, 80, 0.6);
            border-color: var(--text-gold);
        }
        .option-btn[disabled] {
            cursor: not-allowed;
            opacity: 0.5;
            filter: grayscale(80%);
        }
        .option-btn[disabled]:hover {
            transform: none;
            background: rgba(0,0,0,0.3);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border-color: rgba(240, 200, 80, 0.4);
        }
        .option-btn i {
            font-size: 2.8rem;
            color: var(--text-gold);
            filter: drop-shadow(0 0 5px rgba(240, 200, 80, 0.5));
        }
        .option-btn span {
            font-size: 1rem;
            font-family: var(--font-body);
            opacity: 1;
            line-height: 1.45;
            color: var(--text-muted);
            text-shadow: none;
        }
        .back-btn {
            padding: 0.7rem 1.8rem;
            border-radius: 25px;
            background: transparent;
            border: 1px solid rgba(240, 200, 80, 0.6);
            color: var(--text-gold);
            font-family: var(--font-body);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            backdrop-filter: blur(1px);
        }
        .back-btn:hover {
            background: rgba(240, 200, 80, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0,0,0,0.4), 0 0 10px rgba(240, 200, 80, 0.4);
        }
        .player-setup-area {
            gap: 2rem;
            padding: 2.5rem;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--text-gold);
            box-shadow: 0 0 25px rgba(240, 200, 80, 0.7), inset 0 0 15px rgba(0,0,0,0.6);
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }
        .player-setup-area .setup-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.25rem;
            padding: 1.5rem;
            border: 1px solid rgba(240, 200, 80, 0.4);
            border-radius: 15px;
            background: rgba(0,0,0,0.3);
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
        }
        .player-setup-area .setup-section h3 {
            font-size: clamp(1.4rem, 4vw, 1.8rem);
            color: var(--text-gold);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            margin-bottom: 1rem;
        }
        .player-setup-area .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 450px;
        }
        .player-setup-area label {
            font-size: clamp(1rem, 3vw, 1.2rem);
            color: var(--text-light);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .player-setup-area input[type="text"] {
            padding: 0.8rem 1.25rem;
            font-size: 1.1rem;
            border-radius: 8px;
            border: 1px solid rgba(240, 200, 80, 0.6);
            background: rgba(255,255,255,0.1);
            color: var(--text-light);
            outline: none;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        .player-setup-area input[type="text"]::placeholder { color: rgba(255,255,255,0.6); }
        .player-setup-area input[type="text"]:focus {
            border-color: var(--highlight-cyan);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5), 0 0 10px rgba(0,255,255,0.5);
        }
        .player-setup-area .color-choice-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1.25rem;
            width: 100%;
        }
        .player-setup-area .color-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.8rem;
            padding: 1.25rem;
            border-radius: 15px;
            background: rgba(0,0,0,0.35);
            border: 2px solid rgba(240, 200, 80, 0.5);
            color: var(--text-light);
            font-family: var(--font-body);
            font-size: clamp(0.9rem, 3vw, 1.15rem);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            position: relative;
            overflow: hidden;
            min-width: min(180px, 40vw);
            flex: 1;
            max-width: 220px;
            text-align: center;
        }
        .player-setup-area .color-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6), 0 0 15px rgba(240, 200, 80, 0.7);
            border-color: var(--text-gold);
        }
        .player-setup-area .color-option.selected {
            background: linear-gradient(135deg, var(--text-gold), #e0b040);
            color: var(--stone-dark);
            border-color: var(--text-gold);
            box-shadow: 0 0 25px rgba(240, 200, 80, 0.9), inset 0 0 15px rgba(0,0,0,0.5);
            transform: scale(1.03);
        }
        .player-setup-area .color-option input[type="radio"] {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        .player-setup-area .color-option .stone-preview {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.6), inset 0 -5px 15px rgba(0,0,0,0.5), inset 0 5px 10px rgba(255,255,255,0.4);
            transition: all 0.3s ease;
        }
        .player-setup-area .color-option.selected .stone-preview { box-shadow: 0 0 0 5px rgba(255,255,255,0.5), 0 5px 15px rgba(0,0,0,0.6), inset 0 -5px 15px rgba(0,0,0,0.5); }
        .player-setup-area .color-option .stone-preview.player1 { background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%); }
        .player-setup-area .color-option .stone-preview.player2 { background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%); }
        .player-setup-area .color-option .checkmark {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--stone-dark);
            font-size: 1.8em;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        .player-setup-area .color-option.selected .checkmark {
            opacity: 1;
            transform: scale(1);
        }
        .start-game-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1.1rem 3rem;
            border-radius: 50px;
            background: linear-gradient(145deg, #FFE066, #FFB700, #FF8C00);
            color: #3a1a08;
            font-family: var(--font-title);
            font-size: clamp(1.4rem, 5vw, 1.9rem);
            font-weight: 800;
            cursor: pointer;
            transition: all 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 0 rgba(255,200,0,0.5), 0 3px 0 rgba(0,0,0,0.35);
            text-shadow: 0 1px 2px rgba(255,255,255,0.3), 0 2px 4px rgba(0,0,0,0.2);
            border: 3px solid rgba(139,69,19,0.6);
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-top: 1.5rem;
            position: relative;
            overflow: hidden;
            z-index: 1;
            animation: playBtnPulse 2.5s ease-in-out infinite;
        }
        .start-game-btn::before {
            content: '';
            position: absolute;
            top: -50%; left: -60%;
            width: 40%; height: 200%;
            background: linear-gradient(100deg, transparent, rgba(255,255,255,0.5), transparent);
            transform: skewX(-20deg);
            animation: shimmer 2.8s ease-in-out infinite;
        }
        @keyframes shimmer {
            0% { left: -60%; opacity: 0; }
            20% { opacity: 1; }
            60% { left: 130%; opacity: 1; }
            100% { left: 130%; opacity: 0; }
        }
        @keyframes playBtnPulse {
            0%, 100% { box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 0 rgba(255,200,0,0.6), 0 3px 0 rgba(0,0,0,0.35); }
            50% { box-shadow: 0 6px 24px rgba(0,0,0,0.55), 0 0 0 8px rgba(255,200,0,0), 0 3px 0 rgba(0,0,0,0.35); }
        }
        .start-game-btn i { font-size: 0.9em; filter: drop-shadow(0 1px 3px rgba(0,0,0,0.3)); }
        .start-game-btn:hover {
            transform: translateY(-6px) scale(1.06);
            box-shadow: 0 16px 36px rgba(0,0,0,0.7), 0 0 40px rgba(255,200,0,0.7), 0 4px 0 rgba(0,0,0,0.4);
            background: linear-gradient(145deg, #FFE880, #FFD000, #FFA000);
            border-color: #A0522D;
            letter-spacing: 5px;
        }
        .start-game-btn:active {
            transform: translateY(2px) scale(0.97);
            box-shadow: 0 3px 12px rgba(0,0,0,0.5);
            background: linear-gradient(145deg, #FFB700, #FF8C00, #FFE066);
            animation: none;
        }
        .game-play-area {
            display: none;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fadeInUp 0.5s ease forwards;
            padding: 1rem;
        }
        .game-play-area.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .player-panel-container {
            width: 100%;
            max-width: 500px;
        }
        .center-column {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        .game-board-container {
            position: relative;
            width: min(95vw, calc(95vh - 10rem), 600px);
            width: min(95vw, calc(95dvh - 10rem), 600px);
            max-width: 600px;
            aspect-ratio: 1 / 1;
            padding: 15px;
            background: linear-gradient(160deg, var(--wood-dark) 0%, var(--wood-medium) 100%);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 0 20px rgba(0,0,0,0.4);
            border: 10px solid var(--wood-light);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        @media (min-width: 1200px) {
            .game-play-area.active {
                display: grid;
                grid-template-columns: 1fr auto 1fr;
                align-items: center;
                justify-content: center;
                gap: 2rem;
                padding: 1rem 2rem;
                height: 100%;
                perspective: 2000px;
            }
            .player-panel-container {
                display: flex;
                height: 100%;
                align-items: center;
            }
            .player-panel-left { justify-content: flex-end; }
            .player-panel-right { justify-content: flex-start; }
            .player-panel {
                width: 100%;
                max-width: 320px;
            }
            .game-board-container {
                width: clamp(400px, 70vh, 680px);
                transform: rotateX(8deg) scale(1);
                transition: transform 0.5s ease;
            }
        }

        .game-board {
            background: var(--board-surface-light);
            border: 4px solid var(--stone-dark);
            border-radius: 10px;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4);
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 0;
            position: relative;
            overflow: hidden;
            z-index: 2;
        }
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: clamp(0.75rem, 2vw, 1.25rem);
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5), 0 5px 10px rgba(0,0,0,0.3);
            border: 1.5px solid;
            width: 100%;
            height: 100%;
            transition: all 0.4s ease-in-out;
            backdrop-filter: blur(2px);
        }
        .player-title {
            font-size: clamp(1rem, 3vw, 1.2rem);
            margin-bottom: 0.75rem;
            font-weight: bold;
            text-align: center;
            color: var(--text-gold);
            text-shadow: 1px 1px 4px rgba(0,0,0,0.7);
        }
        .player-stats {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 100%;
            gap: 1rem;
        }
        .player-stat {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .player-stat i {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: var(--text-gold);
            opacity: 0.8;
            text-shadow: 0 0 3px rgba(240, 200, 80, 0.5);
        }
        .stat-value {
            font-size: clamp(1.2rem, 3.5vw, 1.4rem);
            font-weight: bold;
            color: var(--text-gold);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.6);
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            width: 100%;
            flex-shrink: 0;
            padding-top: 0.5rem;
        }
        .game-info-display {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1.5rem;
            width: 100%;
            text-align: center;
            color: var(--text-main);
            text-shadow: none;
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            padding: 0.75rem 1.25rem;
            background: var(--panel-bg, linear-gradient(160deg, rgba(0,0,0,0.4), rgba(0,0,0,0.7)));
            border: 1px solid var(--panel-border, rgba(240, 200, 80, 0.5));
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        .game-info-display span:empty { display: none; }
        .game-info-display strong {
            color: var(--text-gold);
            margin-right: 8px;
        }
        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            aspect-ratio: 1 / 1;
            z-index: 2;
            background: transparent;
            transition: all 0.2s ease-out;
            border: 1px solid var(--cell-border, rgba(0,0,0,0.18));
            box-shadow: inset 1px 1px 5px rgba(255,255,255,0.5), inset -1px -1px 5px rgba(0,0,0,0.4);
        }
        .status {
            padding: 0.75rem;
            font-size: clamp(1rem, 3vw, 1.2rem);
            min-height: 50px;
            text-align: center;
            background: var(--panel-bg, rgba(0,0,0,0.5));
            border-radius: 12px;
            border: min(0.4vw, 2px) solid var(--panel-border, rgba(240, 200, 80, 0.6));
            box-shadow: inset 0 0 min(3vw, 15px) rgba(0,0,0,0.5), 0 5px 15px rgba(0,0,0,0.4);
            text-shadow: none;
            width: 100%;
            transition: all var(--transition-duration) ease;
            backdrop-filter: blur(2px);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .player-info.player1-info { border-color: #333; }
        .player-info.player2-info { border-color: #ccc; }
        
        .player-info.active-player {
            transform: scale(1.05);
            border-color: var(--text-gold) !important;
            background: rgba(240, 200, 80, 0.15);
            box-shadow: 0 0 25px rgba(240, 200, 80, 0.8), inset 0 0 15px rgba(240, 200, 80, 0.5);
        }
        
        .controls button {
            padding: 0.7rem 1.2rem;
            border-radius: 35px;
            background: linear-gradient(145deg, var(--wood-light), var(--wood-medium));
            color: var(--text-light);
            font-family: var(--font-ui);
            font-weight: bold;
            cursor: pointer;
            font-size: clamp(0.8rem, 2.5vw, 0.9rem);
            transition: all 0.3s ease;
            box-shadow: 0 6px 10px rgba(0,0,0,0.5);
            width: auto;
            max-width: 200px;
            border: 1px solid var(--wood-dark);
            text-shadow: none;
            letter-spacing: 0.4px;
            text-transform: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            flex-basis: 120px;
        }
        .controls button:not([disabled]):hover {
            transform: translateY(-5px);
            box-shadow: 0 9px 18px rgba(0,0,0,0.6);
        }
        .controls button:not([disabled]):active {
            transform: translateY(2px);
            box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }
        .controls button:hover { background: linear-gradient(145deg, var(--wood-light), var(--wood-medium), var(--text-gold)); }
        .controls button.surrender-btn {
            background: linear-gradient(145deg, #8B0000, #B22222);
            border-color: #6e0000;
        }
        .controls button.surrender-btn:hover { background: linear-gradient(145deg, #B22222, #DC143C); }
        #undo-btn {
            background: linear-gradient(145deg, #465569, #2c3e50);
            border-color: #1a2531;
        }
        #undo-btn:not([disabled]):hover { background: linear-gradient(145deg, #5a6d84, #34495e, var(--info-blue)); }
        .controls button:disabled {
            cursor: not-allowed;
            filter: grayscale(80%);
            opacity: 0.6;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1010;
            backdrop-filter: blur(5px);
            padding: 1.25rem;
        }
        .modal-overlay.active { display: flex; }
        .modal-content {
            background: linear-gradient(160deg, #3a2d25, #2a201a);
            border: 2px solid var(--text-gold);
            border-radius: 15px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            position: relative;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            text-align: center;
        }
        .modal-content h3 {
            font-family: var(--font-title);
            color: var(--text-gold);
            margin-bottom: 1.25rem;
            font-size: 1.5rem;
        }
        .modal-content p {
            margin-bottom: 1.5rem;
            line-height: 1.6;
            font-size: 1rem;
        }
        .modal-actions {
            display: flex;
            justify-content: center;
            gap: 1.25rem;
        }
        .modal-actions button {
            padding: 0.75rem 2rem;
            border-radius: 25px;
            font-family: var(--font-body);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            border: none;
        }
        .modal-confirm-btn {
            background: var(--danger-red);
            color: var(--text-light);
        }
        .modal-confirm-btn:hover {
            background: #ff6666;
            transform: translateY(-3px);
        }
        .modal-cancel-btn {
            background: var(--stone-medium);
            color: var(--text-light);
        }
        .modal-cancel-btn:hover {
            background: var(--stone-light);
            color: var(--stone-dark);
            transform: translateY(-3px);
        }
        .rules-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1300;
            backdrop-filter: blur(5px);
            padding: 1rem;
        }
        .rules-modal-overlay.active { display: flex; }
        .rules-book {
            background: var(--parchment-bg);
            color: var(--wood-dark);
            border: clamp(5px, 2vw, 15px) solid var(--wood-dark);
            border-radius: 10px;
            padding: clamp(0.8rem, 3vw, 2rem) clamp(0.8rem, 4vw, 2.5rem);
            max-width: 800px;
            width: 100%;
            max-height: min(90vh, 90dvh);
            overflow-y: auto;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5), 0 10px 40px rgba(0,0,0,0.7);
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        .rules-modal-overlay.active .rules-book {
            opacity: 1;
            transform: scale(1);
        }
        .rules-book h3 {
            font-family: var(--font-title);
            color: var(--wood-dark);
            text-align: center;
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 1.25rem;
            border-bottom: 2px solid rgba(90, 52, 31, 0.3);
            padding-bottom: 0.75rem;
        }
        .rules-book h4 {
            font-family: var(--font-title);
            color: var(--wood-medium);
            margin-top: 1.25rem;
            margin-bottom: 0.75rem;
            font-size: clamp(1.1rem, 3vw, 1.3rem);
            border-bottom: 1px solid rgba(90, 52, 31, 0.2);
            padding-bottom: 5px;
        }
        .rules-book p, .rules-book li {
            line-height: 1.7;
            margin-bottom: 0.8rem;
            font-size: clamp(0.95rem, 2.5vw, 1rem);
        }
        .rules-book ul {
            list-style-type: none;
            padding-left: 0;
        }
        .rules-book li {
            position: relative;
            padding-left: 1.5rem;
        }
        .rules-book li::before {
            content: '•';
            position: absolute;
            left: 5px;
            color: var(--wood-medium);
            font-weight: bold;
        }
        .rules-book strong {
            color: var(--danger-red);
            font-weight: bold;
        }
        .rules-book .rules-section p:first-of-type { margin-top: 5px; }
        .rules-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 2rem;
            color: var(--wood-dark);
            cursor: pointer;
            transition: transform 0.3s ease, color 0.3s ease;
        }
        .rules-close-btn:hover {
            transform: scale(1.2);
            color: var(--danger-red);
        }
        .rules-content { display: none; }
        .dark-cell { background: rgba(0,0,0,0.1); }
        .cell:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.03);
            z-index: 3;
            box-shadow: inset 0 0 15px rgba(255,255,255,0.6), inset 0 0 15px rgba(0,0,0,0.5), 0 0 10px rgba(240, 200, 80, 0.3);
        }
        .stone {
            width: 65%;
            height: 65%;
            position: relative;
            z-index: 2;
            transition: all 0.3s ease;
            border-radius: 50%;
            box-shadow: 0 5px 12px rgba(0,0,0,0.5), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(255,255,255,0.3);
        }
        .cell.selected {
            z-index: 4;
            animation: pulse 1.5s infinite;
        }
        .cell.possible-move {
            background: rgba(255, 215, 0, 0.2);
            outline: min(0.4vw, 2px) dashed var(--text-gold);
            box-shadow: inset 0 0 12px rgba(255, 215, 0, 0.4);
        }
        .cell.possible-move:hover { background: rgba(255, 215, 0, 0.4); }
        @keyframes pulse {
            0% { box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 215, 0, 0.5); }
            70% { box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 min(3vw, 15px) rgba(255, 215, 0, 0); }
            100% { box-shadow: inset 2px 2px 10px rgba(255,255,255,0.5), inset -2px -2px 10px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        .cell.capturable {
            background: rgba(255, 0, 0, 0.25);
            outline: min(0.6vw, 3px) dashed var(--danger-red);
            animation: capturable-pulse 2s infinite;
        }
        @keyframes capturable-pulse {
            0% { outline-color: var(--danger-red); }
            50% { outline-color: rgba(255, 0, 0, 0.5); }
            100% { outline-color: var(--danger-red); }
        }
        .cell.mill-highlight {
            background: rgba(0, 255, 255, 0.2);
            outline: min(0.6vw, 3px) solid var(--highlight-cyan);
            animation: mill-pulse 1.5s infinite;
        }
        @keyframes mill-pulse {
            0% { outline-color: var(--highlight-cyan); }
            50% { outline-color: rgba(0, 255, 255, 0.5); }
            100% { outline-color: var(--highlight-cyan); }
        }
        .stone::after {
            content: "";
            position: absolute;
            top: 15%;
            left: 15%;
            width: 30%;
            height: 20%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            transform: rotate(-20deg);
            z-index: 3;
            filter: blur(2px);
        }
        .stone.player1 { background: radial-gradient(circle at 35% 35%, var(--player1-stone-color-light), var(--player1-stone-color-dark) 60%, #000 90%); }
        .stone.player2 { background: radial-gradient(circle at 35% 35%, var(--player2-stone-color-light), var(--player2-stone-color-dark) 60%, #e0e0e0 90%); }
        .stone.selected {
            transform: scale(1.25);
            animation: stone-pulse 1.5s infinite;
            filter: brightness(1.1);
        }
        @keyframes stone-pulse {
            0% { box-shadow: 0 0 0 0 rgba(240, 200, 80, 0.7), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4); }
            70% { box-shadow: 0 0 0 min(3.5vw, 18px) rgba(240, 200, 80, 0), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4); }
            100% { box-shadow: 0 0 0 0 rgba(240, 200, 80, 0), 0 min(2.8vw, 14px) min(7vw, 35px) rgba(0,0,0,0.8), inset 0 min(-1.8vw, -9px) min(4.5vw, 22px) rgba(0,0,0,0.4); }
        }
        .stone.moving { animation: placeStone 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; }
        @keyframes placeStone {
            0% { opacity: 0; transform: scale(0.2) translateY(-50px); }
            70% { opacity: 1; transform: scale(1.1) translateY(5px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .stone.captured, .stone.fade-out { animation: fadeOutStone 0.5s ease-in forwards; }
        @keyframes fadeOutStone { to { transform: scale(0.3) rotate(30deg); opacity: 0; filter: blur(5px); } }
        .status.status-error {
            background-color: rgba(255, 0, 0, 0.6);
            border-color: var(--danger-red);
            animation: shake 0.5s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
        }
        footer {
            text-align: center;
            padding: 0.75rem 0 0.5rem;
            color: var(--text-gold);
            font-size: clamp(0.78rem, 2vw, 0.88rem);
            opacity: 0.85;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
            flex-shrink: 0;
            border-top: 1px solid rgba(240,200,80,0.12);
        }
        footer::before {
            content: 'ⵣ ⵎ ⵣ';
            font-size: 0.95rem;
            letter-spacing: 8px;
            opacity: 0.35;
        }
        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            color: var(--text-gold);
            font-family: var(--font-title);
            font-size: clamp(2em, 10vw, 5em);
            flex-direction: column;
            gap: 30px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            backdrop-filter: blur(8px);
            text-shadow: 0 0 15px rgba(240, 200, 80, 0.8), 0 0 30px rgba(240, 200, 80, 0.6);
        }
        .winner-overlay.active {
            opacity: 1;
            pointer-events: all;
            animation: winnerFadeIn 1s ease-out forwards;
        }
        .winner-overlay .winner-message {
            font-size: 0.5em;
            color: var(--text-light);
            text-shadow: none;
            margin-bottom: -15px;
            opacity: 0;
            animation: slideInUp 0.8s ease-out 0.5s forwards;
        }
        .winner-overlay .winner-name {
            font-size: 1em;
            font-weight: bold;
            opacity: 0;
            animation: zoomIn 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) 0.8s forwards;
        }
        .winner-overlay .replay-button {
            padding: 1rem 2.5rem;
            border-radius: 35px;
            background: linear-gradient(145deg, var(--wood-light), var(--wood-medium));
            color: var(--text-light);
            font-family: var(--font-title);
            font-size: clamp(1rem, 4vw, 1.2rem);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            border: none;
            opacity: 0;
            animation: fadeIn 0.8s ease-out 1.5s forwards;
        }
        .winner-overlay .replay-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.6);
            background: linear-gradient(145deg, var(--wood-light), var(--wood-medium), var(--text-gold));
        }
        @keyframes winnerFadeIn { to { opacity: 1; } }
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes zoomIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .ephemeral-message-bubble {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            color: var(--stone-dark);
            padding: 1.25rem 2rem;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
            font-size: 1.8em;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            border: 3px solid var(--text-gold);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .ephemeral-message-bubble.active {
            opacity: 1;
            transform: translate(-50%, -80px);
            animation: bubblePop 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
        }
        @keyframes bubblePop {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            80% { transform: translate(-50%, -90px) scale(1.05); opacity: 1; }
            100% { transform: translate(-50%, -80px) scale(1); opacity: 1; }
        }

        
/* ==================== ACCESSIBILITY TWEAKS ==================== */
@media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}
@media (prefers-contrast: more) {
    :root {
        --panel-bg: rgba(0,0,0,0.65);
        --panel-border: rgba(240,200,80,0.55);
        --cell-border: rgba(240,200,80,0.55);
    }
    [data-theme="kabylie"] {
        --panel-bg: rgba(255,255,255,0.98);
        --panel-border: rgba(31,26,18,0.35);
        --cell-border: rgba(31,26,18,0.45);
    }
    .selection-area, .version-card, .difficulty-card, .mode-card, .option-btn,
    .player-info, .status, .game-info-display, .move-history-panel {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }
}

/* ==================== THEMES ==================== */

        /* Kabylie-inspired bright theme (default) */
        [data-theme="kabylie"] {
            --kab-blue: #1e88e5;
            --kab-green: #2e7d32;
            --kab-yellow: #fdd835;
            --kab-red: #d32f2f;

            --text-main: #1f1a12;
            --text-muted: #4a3f33;
            --text-light: #ffffff;
            --text-gold: #9c6b00;

            --stone-dark: #2b2a28;
            --stone-medium: #6f6458;
            --stone-light: #f2eadf;

            --wood-dark: #8a5a2b;
            --wood-medium: #b37634;
            --wood-light: #d7a25a;

            --board-border-dark: rgba(47,42,37,0.55);
            --board-surface-light: rgba(255,250,240,0.92);
            --parchment-bg: rgba(255,255,255,0.92);

            --cell-border: rgba(47,42,37,0.30);
            --highlight-cyan: rgba(30,136,229,0.95);
            --danger-red: #c62828;

            --bg-start: #fff3bf;
            --bg-end: #d7f3ff;

            --panel-bg: rgba(255,255,255,0.88);
            --panel-border: rgba(31,26,18,0.18);
        }
        [data-theme="kabylie"] body {
            background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
            color: var(--text-main);
            /* Subtle Amazigh-inspired pattern */
            background-image:
              url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="140" height="140" viewBox="0 0 140 140"><rect width="140" height="140" fill="none"/><path d="M0 70h140M70 0v140" stroke="%231e88e5" stroke-width="2" opacity="0.05"/><path d="M20 20l30 30M90 90l30 30M120 20l-30 30M50 90l-30 30" stroke="%232e7d32" stroke-width="2" opacity="0.05"/><text x="70" y="78" text-anchor="middle" font-size="32" fill="%23d32f2f" opacity="0.06">ⵣ</text></svg>'),
              radial-gradient(circle at 15% 20%, rgba(253,216,53,0.35), rgba(253,216,53,0) 55%),
              radial-gradient(circle at 85% 70%, rgba(30,136,229,0.25), rgba(30,136,229,0) 60%);
            background-size: 140px 140px, auto, auto;
        }
        [data-theme="kabylie"] header h1 {
            color: var(--kab-red);
            text-shadow: 0 2px 0 rgba(255,255,255,0.55), 0 8px 18px rgba(0,0,0,0.12);
        }
        [data-theme="kabylie"] header h1::after {
            color: var(--kab-blue);
        }
        [data-theme="kabylie"] header::after {
            color: var(--kab-red);
        }
        [data-theme="kabylie"] .stone-decoration { color: rgba(210,47,47,0.18); text-shadow: none; }
        [data-theme="kabylie"] .selection-area,
        [data-theme="kabylie"] .version-card,
        [data-theme="kabylie"] .difficulty-card,
        [data-theme="kabylie"] .mode-card,
        [data-theme="kabylie"] .ai-difficulty-panel,
        [data-theme="kabylie"] .rules-modal-content {
            background: var(--panel-bg);
            border-color: rgba(30,136,229,0.28);
            box-shadow: 0 12px 28px rgba(0,0,0,0.12);
            color: var(--text-main);
            backdrop-filter: blur(8px);
        }
        [data-theme="kabylie"] .selection-area h2,
        [data-theme="kabylie"] .ai-difficulty-panel h2,
        [data-theme="kabylie"] .rules-modal-content h2 {
            color: var(--kab-blue);
            text-shadow: none;
        }
        [data-theme="kabylie"] .version-card:hover,
        [data-theme="kabylie"] .difficulty-card:hover,
        [data-theme="kabylie"] .mode-card:hover {
            box-shadow: 0 14px 30px rgba(0,0,0,0.14);
            border-color: rgba(46,125,50,0.45);
        }
        [data-theme="kabylie"] .version-card.active,
        [data-theme="kabylie"] .difficulty-card.active,
        [data-theme="kabylie"] .mode-card.active {
            background: linear-gradient(145deg, rgba(253,216,53,0.85), rgba(30,136,229,0.15));
            color: var(--text-main);
            border-color: rgba(210,47,47,0.45);
        }
        [data-theme="kabylie"] .toolbar-btn,
        [data-theme="kabylie"] .language-selector {
            background: rgba(255,255,255,0.86);
            border: 1px solid rgba(31,26,18,0.18);
            box-shadow: 0 6px 16px rgba(0,0,0,0.10);
            color: var(--text-main);
        }
        [data-theme="kabylie"] .toolbar-btn:hover { background: rgba(255,255,255,0.95); border-color: rgba(30,136,229,0.35); }
        [data-theme="kabylie"] .language-selector i { color: var(--kab-blue); }
        [data-theme="kabylie"] .language-selector select { color: var(--text-main); }
        [data-theme="kabylie"] .language-selector select option { background: #ffffff; color: #1f1a12; }

        [data-theme="kabylie"] .game-info-display {
            background: rgba(255,255,255,0.86);
            border-color: rgba(46,125,50,0.28);
            box-shadow: 0 10px 22px rgba(0,0,0,0.10), inset 0 0 0 rgba(0,0,0,0);
            color: var(--text-main);
            text-shadow: none;
        }
        [data-theme="kabylie"] .game-info-display strong { color: var(--kab-blue); }
        [data-theme="kabylie"] .status {
            background: rgba(255,255,255,0.88);
            color: var(--text-main);
            border-color: rgba(30,136,229,0.32);
            box-shadow: 0 10px 22px rgba(0,0,0,0.10);
        }
        [data-theme="kabylie"] .status.error {
            border-color: rgba(198,40,40,0.55);
            background: rgba(255,235,238,0.92);
        }

        [data-theme="kabylie"] .game-board-container {
            background: linear-gradient(160deg, rgba(183,118,52,0.65), rgba(215,162,90,0.55));
            border-color: rgba(138,90,43,0.55);
            box-shadow: 0 14px 34px rgba(0,0,0,0.16), inset 0 0 18px rgba(255,255,255,0.35);
        }
        [data-theme="kabylie"] .game-board {
            background: rgba(255,250,240,0.92);
            border-color: rgba(47,42,37,0.55);
        }
        [data-theme="kabylie"] .cell {
            box-shadow: inset 1px 1px 4px rgba(255,255,255,0.55), inset -1px -1px 4px rgba(0,0,0,0.10);
        }
        [data-theme="kabylie"] .cell.dark-cell { background: rgba(31,26,18,0.04); }
        [data-theme="kabylie"] .cell.possible-move {
            background: rgba(46,125,50,0.14);
            outline-color: rgba(46,125,50,0.85);
            box-shadow: inset 0 0 12px rgba(46,125,50,0.18);
        }
        [data-theme="kabylie"] .cell.mill-highlight {
            background: rgba(30,136,229,0.14);
            outline-color: rgba(30,136,229,0.95);
        }

        [data-theme="kabylie"] .stone.player1 {
            background: radial-gradient(circle at 35% 35%, #444, #1f1a12 60%, #0d0b09 92%);
            box-shadow: 0 6px 12px rgba(0,0,0,0.30), inset 0 -6px 12px rgba(0,0,0,0.28), inset 0 5px 10px rgba(255,255,255,0.15);
        }
        [data-theme="kabylie"] .stone.player2 {
            background: radial-gradient(circle at 35% 35%, #ffffff, #e9e4db 60%, #bdb7ad 92%);
            box-shadow: 0 6px 12px rgba(0,0,0,0.18), inset 0 -6px 12px rgba(0,0,0,0.12), inset 0 5px 10px rgba(255,255,255,0.65);
        }
        [data-theme="kabylie"] .stone.selected { outline-color: rgba(210,47,47,0.85); }

        [data-theme="kabylie"] .move-history-panel {
            background: rgba(255,255,255,0.92);
            color: var(--text-main);
            border-color: rgba(31,26,18,0.22);
            box-shadow: 0 4px 12px rgba(0,0,0,0.10);
        }
        [data-theme="kabylie"] .move-log-entry { color: var(--text-main); }
        [data-theme="kabylie"] .move-history-title { color: var(--kab-blue); opacity: 1; }
        [data-theme="kabylie"] .move-log-entry.mill-entry { background: rgba(30,136,229,0.10); border-left-color: var(--kab-blue); }
        [data-theme="kabylie"] .move-log-entry.capture-entry { background: rgba(198,40,40,0.08); border-left-color: var(--kab-red); }

        [data-theme="desert"] {
            --stone-dark: #3d2a14;
            --stone-medium: #7a5a32;
            --stone-light: #f3e5c8;
            --wood-dark: #7a3a0a;
            --wood-medium: #a0561e;
            --wood-light: #c87030;
            --text-gold: #b87a10;
            --board-surface-light: #f6e2b8;
            --parchment-bg: #fff8e8;
            --board-border-dark: rgba(61,42,20,0.55);
            --cell-border: rgba(61,42,20,0.28);

            --text-main: #1f1a12;
            --text-muted: #4a3f33;
            --panel-bg: rgba(255,255,255,0.86);
            --panel-border: rgba(31,26,18,0.18);

            --bg-start: #fff1d6;
            --bg-end: #f2d0a0;
        }
        [data-theme="desert"] body {
            background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
            color: var(--text-main, var(--text-light));
        }
        [data-theme="desert"] .move-history-panel { background: rgba(255,248,232,0.92); color: var(--text-main); border-color: rgba(61,42,20,0.30); }
        [data-theme="desert"] .move-log-entry { color: var(--text-main); }
        [data-theme="desert"] .move-history-title { color: var(--text-gold); opacity: 1; }
        [data-theme="desert"] .move-log-entry.mill-entry { background: rgba(160,86,30,0.10); border-left-color: var(--wood-medium); }
        [data-theme="desert"] .move-log-entry.capture-entry { background: rgba(122,58,10,0.10); border-left-color: var(--wood-dark); }
        [data-theme="desert"] .status { background: rgba(255,248,232,0.90); color: var(--text-main); border-color: rgba(61,42,20,0.28); }
        [data-theme="desert"] .game-info-display { background: rgba(255,248,232,0.88); color: var(--text-main); border-color: rgba(61,42,20,0.20); }
        [data-theme="desert"] .game-info-display strong { color: var(--wood-dark); }
        [data-theme="desert"] .player-info { background: rgba(255,248,232,0.86); color: var(--text-main); border-color: rgba(61,42,20,0.22) !important; }
        [data-theme="desert"] .player-title { color: var(--wood-dark); text-shadow: none; }
        [data-theme="desert"] .stat-value { color: var(--wood-medium); text-shadow: none; }
        [data-theme="desert"] .player-stat i { color: var(--wood-light); opacity: 1; }
        [data-theme="desert"] .player-info.active-player { background: rgba(200,112,48,0.12); border-color: rgba(200,112,48,0.55) !important; box-shadow: 0 0 20px rgba(200,112,48,0.25); }
        [data-theme="desert"] .selection-area, [data-theme="desert"] .version-card { background: rgba(255,248,232,0.90); border-color: rgba(61,42,20,0.22); color: var(--text-main); }
        [data-theme="desert"] .version-card h3, [data-theme="desert"] .selection-area h2 { color: var(--wood-dark); text-shadow: none; }
        [data-theme="desert"] .version-card p { color: var(--text-muted); }
        [data-theme="desert"] .option-btn { background: rgba(255,248,232,0.88); color: var(--text-main); border-color: rgba(61,42,20,0.22); }
        [data-theme="desert"] .option-btn span { color: var(--text-muted); }
        [data-theme="desert"] .option-btn i { color: var(--wood-medium); }
        [data-theme="nuit"] {
--stone-dark: #080818;
--stone-medium: #1a1a3a;
--stone-light: #2a2a5a;
--wood-dark: #100830;
--wood-medium: #1e0f50;
--wood-light: #3a1a80;

--text-main: rgba(240,234,255,0.94);
--text-muted: rgba(240,234,255,0.76);
--text-light: #f0eaff;
--text-gold: #bb86fc;

--highlight-cyan: #03dac6;
--info-blue: #7dd3f7;
--danger-red: #ff6b8a;

--panel-bg: rgba(10, 8, 30, 0.72);
--panel-border: rgba(187, 134, 252, 0.22);

--board-surface-light: #0d0d2a;
--board-border-dark: #050510;
--parchment-bg: #0d0d2a;
--cell-border: rgba(187, 134, 252, 0.15);
        }
        [data-theme="nuit"] body {
            background: linear-gradient(135deg, #0d0820, #050510);
            color: var(--text-main);
            background-image:
              radial-gradient(circle at 15% 20%, rgba(187,134,252,0.18), transparent 45%),
              radial-gradient(circle at 80% 70%, rgba(3,218,198,0.10), transparent 55%),
              radial-gradient(circle at 50% 50%, rgba(255,255,255,0.04), transparent 40%);
        }
        [data-theme="nuit"] .stone.player1 {
            background: radial-gradient(circle at 35% 35%, #7c3aed, #2d1b69 60%, #110830 90%);
            box-shadow: 0 5px 12px rgba(0,0,0,0.7), inset 0 -5px 12px rgba(0,0,0,0.5), inset 0 5px 10px rgba(187,134,252,0.3), 0 0 10px rgba(187,134,252,0.3);
        }
        [data-theme="nuit"] .stone.player2 {
            background: radial-gradient(circle at 35% 35%, #03dac6, #018786 60%, #003a3a 90%);
            box-shadow: 0 5px 12px rgba(0,0,0,0.7), inset 0 -5px 12px rgba(0,0,0,0.5), inset 0 5px 10px rgba(3,218,198,0.3), 0 0 10px rgba(3,218,198,0.3);
        }
        [data-theme="nuit"] .game-board {
            background: #0d0d2a;
            border-color: #1a0a4a;
        }
        [data-theme="nuit"] .game-board-container {
            background: linear-gradient(160deg, #1a0a4a, #0d0828);
            border-color: #3a1a80;
        }
        [data-theme="nuit"] .cell { border-color: rgba(187, 134, 252, 0.1); }
        [data-theme="nuit"] .cell.dark-cell { background: rgba(187,134,252,0.05); }
        [data-theme="nuit"] .cell.possible-move { background: rgba(3,218,198,0.15); outline-color: #03dac6; }
        [data-theme="nuit"] .cell.mill-highlight { background: rgba(187,134,252,0.2); outline-color: #bb86fc; }
        [data-theme="nuit"] .stone.player1.selected,
        [data-theme="nuit"] .stone.player2.selected { filter: brightness(1.3); }
        [data-theme="nuit"] .move-history-panel { background: rgba(10,8,30,0.8); border-color: rgba(187,134,252,0.28); color: var(--text-main); }
        [data-theme="nuit"] .move-log-entry { color: rgba(240,234,255,0.95); }
        [data-theme="nuit"] .move-history-title { color: #bb86fc; opacity: 1; }
        [data-theme="nuit"] .move-log-entry.mill-entry { background: rgba(3,218,198,0.12); border-left-color: #03dac6; }
        [data-theme="nuit"] .move-log-entry.capture-entry { background: rgba(255,107,138,0.12); border-left-color: #ff6b8a; }
        [data-theme="nuit"] .status { background: rgba(10,8,30,0.78); color: var(--text-main); border-color: rgba(187,134,252,0.30); }
        [data-theme="nuit"] .game-info-display { background: rgba(10,8,30,0.75); color: var(--text-main); border-color: rgba(187,134,252,0.25); }
        [data-theme="nuit"] .game-info-display strong { color: #bb86fc; }
        [data-theme="nuit"] .player-info { background: rgba(10,8,30,0.72); color: var(--text-main); border-color: rgba(187,134,252,0.22) !important; }
        [data-theme="nuit"] .player-title { color: #bb86fc; }
        [data-theme="nuit"] .stat-value { color: #bb86fc; }
        [data-theme="nuit"] .player-stat i { color: #03dac6; }

        /* ==================== GLASSMORPHISM THEME ==================== */
        [data-theme="glass"] {
            --glass-blur: 18px;
            --glass-accent: #e8b4f8;
            --glass-accent2: #7dd3f7;
            --stone-dark: #0a0814;
            --stone-medium: #1a1030;
            --stone-light: #2d1f55;
            --wood-dark: #1a0a30;
            --wood-medium: #2d1550;
            --wood-light: #5a2898;
            --text-gold: #e8b4f8;
            --text-light: #f0eaff;
            --text-main: #f0eaff;
            --text-muted: rgba(240,234,255,0.78);
            --highlight-cyan: #7dd3f7;
            --danger-red: #ff7eb3;
            --board-surface-light: rgba(255,255,255,0.06);
            --board-border-dark: rgba(232,180,248,0.2);
            --parchment-bg: rgba(10,8,20,0.95);
            --cell-border: rgba(232,180,248,0.12);
            --panel-bg: rgba(255,255,255,0.07);
            --panel-border: rgba(255,255,255,0.18);
        }
        [data-theme="glass"] body {
            background:
                radial-gradient(ellipse at 15% 20%, rgba(168,85,247,0.4) 0%, transparent 55%),
                radial-gradient(ellipse at 85% 80%, rgba(59,130,246,0.38) 0%, transparent 55%),
                radial-gradient(ellipse at 50% 50%, rgba(20,10,50,0.95) 0%, rgba(5,3,18,1) 100%);
            background-attachment: fixed;
            color: var(--text-light);
        }
        [data-theme="glass"] header h1 {
            background: linear-gradient(135deg, #e8b4f8 0%, #a78bfa 40%, #7dd3f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            filter: drop-shadow(0 0 20px rgba(168,85,247,0.55));
        }
        [data-theme="glass"] .selection-area,
        [data-theme="glass"] .version-card,
        [data-theme="glass"] .option-btn {
            background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
            border: 1px solid rgba(232,180,248,0.22);
            box-shadow: 0 8px 32px rgba(0,0,0,0.45), inset 0 1px 0 rgba(255,255,255,0.12);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            color: var(--text-light);
        }
        [data-theme="glass"] .selection-area h2 {
            background: linear-gradient(135deg, #e8b4f8, #7dd3f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }
        [data-theme="glass"] .version-card:hover,
        [data-theme="glass"] .option-btn:hover {
            background: linear-gradient(135deg, rgba(232,180,248,0.18), rgba(125,211,247,0.10));
            border-color: rgba(232,180,248,0.5);
            box-shadow: 0 12px 40px rgba(0,0,0,0.5), 0 0 20px rgba(168,85,247,0.3), inset 0 1px 0 rgba(255,255,255,0.18);
        }
        [data-theme="glass"] .version-card.active { background: linear-gradient(135deg, rgba(168,85,247,0.3), rgba(59,130,246,0.2)); border-color: rgba(232,180,248,0.6); color: var(--text-light); }
        [data-theme="glass"] .version-card h3 { color: #e8b4f8; }
        [data-theme="glass"] .version-card.active h3 { color: #f0eaff; text-shadow: none; }
        [data-theme="glass"] .version-card.active p { color: rgba(240,234,255,0.85); }

        [data-theme="glass"] .option-btn i { color: #e8b4f8; filter: drop-shadow(0 0 6px rgba(168,85,247,0.5)); }
        [data-theme="glass"] .game-board-container {
            background: linear-gradient(135deg, rgba(168,85,247,0.14), rgba(59,130,246,0.10));
            border: 2px solid rgba(232,180,248,0.22);
            box-shadow: 0 16px 48px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.07);
            backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
        }
        [data-theme="glass"] .game-board { background: rgba(255,255,255,0.04); border-color: rgba(232,180,248,0.14); }
        [data-theme="glass"] .cell { border-color: rgba(232,180,248,0.10); box-shadow: inset 1px 1px 3px rgba(255,255,255,0.05), inset -1px -1px 3px rgba(0,0,0,0.2); }
        [data-theme="glass"] .cell.dark-cell { background: rgba(232,180,248,0.04); }
        [data-theme="glass"] .cell.possible-move { background: rgba(125,211,247,0.15); outline-color: #7dd3f7; box-shadow: inset 0 0 14px rgba(125,211,247,0.28); }
        [data-theme="glass"] .cell.mill-highlight { background: rgba(232,180,248,0.18); outline-color: #e8b4f8; }
        [data-theme="glass"] .cell.capturable { background: rgba(255,126,179,0.18); outline-color: #ff7eb3; }
        [data-theme="glass"] .stone.player1 {
            background: radial-gradient(circle at 35% 35%, #c4b5fd, #7c3aed 55%, #2e1065 90%);
            box-shadow: 0 5px 14px rgba(0,0,0,0.6), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(196,181,253,0.4), 0 0 14px rgba(168,85,247,0.45);
        }
        [data-theme="glass"] .stone.player2 {
            background: radial-gradient(circle at 35% 35%, #bae6fd, #0ea5e9 55%, #0c4a6e 90%);
            box-shadow: 0 5px 14px rgba(0,0,0,0.6), inset 0 -5px 12px rgba(0,0,0,0.4), inset 0 5px 10px rgba(186,230,253,0.4), 0 0 14px rgba(59,130,246,0.45);
        }
        [data-theme="glass"] .status,
        [data-theme="glass"] .game-info-display,
        [data-theme="glass"] .player-info,
        [data-theme="glass"] .move-history-panel {
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border-color: rgba(232,180,248,0.22);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            box-shadow: 0 4px 18px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10);
            color: #f0eaff;
        }
        [data-theme="glass"] .move-log-entry { color: rgba(240,234,255,0.95); }
        [data-theme="glass"] .move-history-title { color: #e8b4f8; opacity: 1; }
        [data-theme="glass"] .move-log-entry.mill-entry { background: rgba(125,211,247,0.12); border-left-color: #7dd3f7; }
        [data-theme="glass"] .move-log-entry.capture-entry { background: rgba(255,126,179,0.12); border-left-color: #ff7eb3; }
        [data-theme="glass"] .player-info { border-color: rgba(232,180,248,0.18) !important; }
        [data-theme="glass"] .player-info.active-player {
            background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(59,130,246,0.14));
            border-color: rgba(232,180,248,0.6) !important;
            box-shadow: 0 0 30px rgba(168,85,247,0.42), inset 0 0 20px rgba(168,85,247,0.08);
        }
        [data-theme="glass"] .player-title,
        [data-theme="glass"] .stat-value { color: #e8b4f8; text-shadow: 0 0 8px rgba(232,180,248,0.4); }
        [data-theme="glass"] .player-stat i { color: #7dd3f7; }
        [data-theme="glass"] .game-info-display strong { color: #7dd3f7; }
        [data-theme="glass"] .controls button {
            background: linear-gradient(145deg, rgba(168,85,247,0.28), rgba(59,130,246,0.18));
            border: 1px solid rgba(232,180,248,0.28);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            color: #f0eaff; text-shadow: none;
            box-shadow: 0 4px 14px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.10);
        }
        [data-theme="glass"] .controls button:not([disabled]):hover {
            background: linear-gradient(145deg, rgba(168,85,247,0.48), rgba(59,130,246,0.32));
            border-color: rgba(232,180,248,0.55);
            box-shadow: 0 8px 24px rgba(0,0,0,0.5), 0 0 14px rgba(168,85,247,0.32);
        }
        [data-theme="glass"] .controls button.surrender-btn { background: linear-gradient(145deg, rgba(255,126,179,0.28), rgba(190,18,60,0.18)); border-color: rgba(255,126,179,0.38); }
        [data-theme="glass"] #undo-btn { background: linear-gradient(145deg, rgba(125,211,247,0.22), rgba(14,165,233,0.14)); border-color: rgba(125,211,247,0.32); }
        [data-theme="glass"] .toolbar-btn,
        [data-theme="glass"] .language-selector {
            background: linear-gradient(135deg, rgba(255,255,255,0.10), rgba(255,255,255,0.05));
            border-color: rgba(232,180,248,0.3);
            backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px);
            color: #e8b4f8;
        }
        [data-theme="glass"] .toolbar-btn:hover,
        [data-theme="glass"] .language-selector:hover { background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(59,130,246,0.14)); border-color: rgba(232,180,248,0.55); }
        [data-theme="glass"] .language-selector i,
        [data-theme="glass"] .language-selector select { color: #e8b4f8; }
        [data-theme="glass"] #settings-fab {
            background: linear-gradient(145deg, rgba(168,85,247,0.7), rgba(59,130,246,0.5));
            border-color: rgba(232,180,248,0.55);
            color: #f0eaff;
        }
        [data-theme="glass"] .back-btn,
        [data-theme="glass"] .rules-btn {
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
            border-color: rgba(232,180,248,0.3);
            color: #e8b4f8;
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        [data-theme="glass"] .back-btn:hover, [data-theme="glass"] .rules-btn:hover { background: linear-gradient(135deg, rgba(168,85,247,0.2), rgba(59,130,246,0.12)); border-color: rgba(232,180,248,0.55); }
        [data-theme="glass"] .start-game-btn {
            background: linear-gradient(145deg, #c4b5fd, #7c3aed, #5b21b6);
            border-color: rgba(232,180,248,0.6);
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.4);
            box-shadow: 0 8px 28px rgba(0,0,0,0.6), 0 0 30px rgba(168,85,247,0.5);
        }
        [data-theme="glass"] .start-game-btn:hover { background: linear-gradient(145deg, #ddd6fe, #a78bfa, #7c3aed); box-shadow: 0 14px 40px rgba(0,0,0,0.7), 0 0 50px rgba(168,85,247,0.65); }
        [data-theme="glass"] .player-setup-area { background: linear-gradient(135deg, rgba(255,255,255,0.09), rgba(255,255,255,0.04)); border-color: rgba(232,180,248,0.3); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); }
        [data-theme="glass"] .player-setup-area .setup-section { background: rgba(255,255,255,0.05); border-color: rgba(232,180,248,0.18); }
        [data-theme="glass"] .player-setup-area input[type="text"] { background: rgba(255,255,255,0.07); border-color: rgba(232,180,248,0.35); color: #f0eaff; }
        [data-theme="glass"] .player-setup-area input[type="text"]:focus { border-color: #7dd3f7; box-shadow: 0 0 14px rgba(125,211,247,0.4); }
        [data-theme="glass"] .stone-decoration { color: rgba(232,180,248,0.18); }

        
/* ==================== KABYLIE: EXTRA READABILITY ==================== */
[data-theme="kabylie"] .option-btn {
    background: rgba(255,255,255,0.88);
    border-color: rgba(30,136,229,0.28);
    box-shadow: 0 10px 22px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .option-btn:hover {
    background: rgba(30,136,229,0.06);
    border-color: rgba(30,136,229,0.45);
    box-shadow: 0 14px 30px rgba(0,0,0,0.12);
}
[data-theme="kabylie"] .option-btn i { color: var(--kab-red); filter: none; }

[data-theme="kabylie"] .player-info {
    background: rgba(255,255,255,0.86);
    border-color: rgba(31,26,18,0.18);
    box-shadow: 0 10px 22px rgba(0,0,0,0.10);
    color: var(--text-main);
}
[data-theme="kabylie"] .player-title { color: var(--kab-blue); text-shadow: none; }
[data-theme="kabylie"] .player-stat i { color: var(--kab-green); text-shadow: none; opacity: 0.9; }
[data-theme="kabylie"] .stat-value { color: var(--kab-red); text-shadow: none; }
[data-theme="kabylie"] .player-info.active-player {
    background: rgba(46,125,50,0.12);
    border-color: rgba(46,125,50,0.55) !important;
    box-shadow: 0 0 22px rgba(46,125,50,0.28), 0 10px 22px rgba(0,0,0,0.10);
}
[data-theme="kabylie"] .start-game-btn {
    background: linear-gradient(145deg, #43a047, #1b5e20);
    border-color: rgba(27,94,32,0.7);
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
    box-shadow: 0 8px 24px rgba(0,0,0,0.25), 0 0 24px rgba(67,160,71,0.4);
}
[data-theme="kabylie"] .start-game-btn:hover { background: linear-gradient(145deg, #66bb6a, #2e7d32); box-shadow: 0 12px 32px rgba(0,0,0,0.28), 0 0 36px rgba(67,160,71,0.55); }

/* ==================== HIGH-CONTRAST THEME ==================== */
[data-theme="contrast"] {
    --stone-dark: #000000;
    --stone-medium: #1a1a1a;
    --stone-light: #ffffff;

    --wood-dark: #000000;
    --wood-medium: #0f0f0f;
    --wood-light: #2a2a2a;

    --text-main: #ffffff;
    --text-muted: #e6e6e6;
    --text-light: #ffffff;
    --text-gold: #ffd400;

    --highlight-cyan: #00e5ff;
    --info-blue: #00e5ff;
    --danger-red: #ff3b3b;

    --panel-bg: #000000;
    --panel-border: #ffffff;

    --board-surface-light: #000000;
    --board-border-dark: #ffffff;
    --parchment-bg: #000000;

    --cell-border: rgba(255,255,255,0.65);
}
[data-theme="contrast"] body {
    background: #000000;
    color: #ffffff;
    background-image: none;
}
[data-theme="contrast"] header h1 { color: var(--text-gold); text-shadow: none; }
[data-theme="contrast"] header::after { color: rgba(255,255,255,0.85); }
[data-theme="contrast"] .selection-area,
[data-theme="contrast"] .version-card,
[data-theme="contrast"] .difficulty-card,
[data-theme="contrast"] .mode-card,
[data-theme="contrast"] .ai-difficulty-panel,
[data-theme="contrast"] .rules-modal-content,
[data-theme="contrast"] .status,
[data-theme="contrast"] .game-info-display,
[data-theme="contrast"] .player-info,
[data-theme="contrast"] .move-history-panel {
    background: #000000 !important;
    border-color: #ffffff !important;
    box-shadow: none !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    color: #ffffff !important;
}
[data-theme="contrast"] .option-btn i { color: var(--text-gold); filter: none; }
[data-theme="contrast"] .move-log-entry { color: #ffffff; }
[data-theme="contrast"] .move-history-title { color: var(--text-gold); opacity: 1; }
[data-theme="contrast"] .move-log-entry.mill-entry { background: rgba(0,229,255,0.15); border-left-color: var(--highlight-cyan); }
[data-theme="contrast"] .move-log-entry.capture-entry { background: rgba(255,59,59,0.15); border-left-color: var(--danger-red); }
[data-theme="contrast"] .game-board-container { box-shadow: none !important; border-color: #ffffff !important; }
[data-theme="contrast"] .game-board { background: #000000; border-color: #ffffff; box-shadow: none !important; }
[data-theme="contrast"] .cell { box-shadow: none !important; }
[data-theme="contrast"] .cell.possible-move { background: rgba(0,229,255,0.22); outline-color: #00e5ff; }
[data-theme="contrast"] .cell.mill-highlight { background: rgba(255,212,0,0.22); outline-color: #ffd400; }
[data-theme="contrast"] .cell.capturable { background: rgba(255,59,59,0.22); outline-color: #ff3b3b; }
[data-theme="contrast"] .stone.player1 {
    background: #111111;
    box-shadow: inset 0 0 0 2px #ffffff, 0 6px 12px rgba(0,0,0,0.7);
}
[data-theme="contrast"] .stone.player2 {
    background: #eeeeee;
    box-shadow: inset 0 0 0 2px #000000, 0 6px 12px rgba(0,0,0,0.7);
}
[data-theme="contrast"] .stone.selected { outline-color: #00e5ff; }

/* ==================== FLOATING SETTINGS PANEL (bottom-right) ==================== */
        /* Removed from top so it never obstructs the game view */
        .toolbar-buttons {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            z-index: 1020;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
            max-width: min(280px, calc(100vw - 1.5rem));
        }

        /* Toggle FAB */
        #settings-fab {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(145deg, var(--wood-light, #9d603a), var(--wood-dark, #5a341f));
            border: 2px solid rgba(240,200,80,0.5);
            box-shadow: 0 4px 14px rgba(0,0,0,0.4), 0 0 0 0 rgba(240,200,80,0);
            cursor: pointer;
            color: var(--text-gold, #f0c850);
            font-size: 1.15rem;
            transition: all 0.25s ease;
            flex-shrink: 0;
            z-index: 2;
        }
        #settings-fab:hover {
            transform: scale(1.08) rotate(15deg);
            box-shadow: 0 6px 18px rgba(0,0,0,0.5), 0 0 16px rgba(240,200,80,0.35);
        }
        #settings-fab.open { transform: rotate(45deg); }

        /* Collapsible tray */
        .settings-tray {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.45rem;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            pointer-events: none;
            transition: max-height 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.25s ease;
        }
        .settings-tray.open {
            max-height: min(420px, calc(100dvh - 6rem));
            opacity: 1;
            pointer-events: all;
            overflow-y: auto;
            overscroll-behavior: contain;
        }
        .settings-tray.open::-webkit-scrollbar { width: 8px; }
        .settings-tray.open::-webkit-scrollbar-thumb { background: rgba(240, 200, 80, 0.22); border-radius: 999px; }
        .settings-tray.open::-webkit-scrollbar-track { background: transparent; }

        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(20, 15, 10, 0.82);
            border-radius: 22px;
            padding: 0.4rem 0.85rem;
            border: 1px solid rgba(240, 200, 80, 0.35);
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            cursor: pointer;
            color: var(--text-gold, #f0c850);
            font-size: 0.92rem;
            gap: 0.45rem;
            white-space: nowrap;
            min-height: 36px;
        }
        .toolbar-btn:hover {
            background: rgba(240, 200, 80, 0.14);
            border-color: rgba(240, 200, 80, 0.6);
            transform: translateX(-3px);
        }
        .toolbar-btn.sound-off { opacity: 0.55; }

        /* Language selector inside tray */
        .language-selector {
            position: relative;
            display: flex;
            align-items: center;
            background: rgba(20, 15, 10, 0.82);
            border-radius: 22px;
            padding: 0.4rem 0.85rem;
            border: 1px solid rgba(240, 200, 80, 0.35);
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.2s ease;
            gap: 0.45rem;
        }
        .language-selector::after {
            content: '▾';
            font-size: 0.75rem;
            opacity: 0.75;
            margin-left: 0.15rem;
            line-height: 1;
        }

        .language-selector:hover {
            background: rgba(240, 200, 80, 0.14);
            border-color: rgba(240, 200, 80, 0.6);
            transform: translateX(-3px);
        }
        .language-selector i {
            color: var(--text-gold, #f0c850);
            font-size: 0.92rem;
        }
        .language-selector select {
            background: transparent;
            color: inherit;
            border: none;
            padding: 0.12rem 1.25rem 0.12rem 0.25rem;
            min-width: 120px;
            font-family: var(--font-body);
            font-size: 0.88rem;
            font-weight: 700;
            cursor: pointer;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        .language-selector select option {
            background: #2c2722;
            color: #f5f5f5;
        }

        /* ==================== MOVE HISTORY PANEL ==================== */
        .move-history-panel {
            width: 100%;
            max-height: 160px;
            overflow: hidden;
            background: rgba(0,0,0,0.5);
            border: 1.5px solid rgba(240,200,80,0.4);
            border-radius: 10px;
            padding: 0.6rem 0.85rem;
            transition: max-height 0.3s ease;
        }
        .move-history-title {
            font-size: 0.78rem;
            color: var(--text-gold);
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
        }
        .move-log-list {
            display: flex;
            flex-direction: column-reverse;
            gap: 3px;
            max-height: 110px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(240,200,80,0.3) transparent;
        }
        .move-log-entry {
            font-size: 0.82rem;
            color: var(--text-main);
            opacity: 1;
            padding: 2px 6px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: logFadeIn 0.3s ease;
            font-weight: 500;
        }
        .move-log-entry .log-stone {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .move-log-entry .log-stone.p1 { background: var(--player1-stone-color-light); border: 1px solid #555; }
        .move-log-entry .log-stone.p2 { background: var(--player2-stone-color-light); border: 1px solid #ccc; }
        .move-log-entry.mill-entry { background: rgba(0,255,255,0.12); border-left: 2px solid var(--highlight-cyan); }
        .move-log-entry.capture-entry { background: rgba(255,77,77,0.12); border-left: 2px solid var(--danger-red); }
        @keyframes logFadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* ==================== SPECTATOR MODE ==================== */
        .spectator-badge {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            border: 1px solid var(--text-gold);
            border-radius: 20px;
            padding: 0.3rem 1rem;
            color: var(--text-gold);
            font-size: 0.85rem;
            font-family: var(--font-title);
            letter-spacing: 1px;
            z-index: 5;
            display: none;
            animation: fadeIn 0.5s ease;
            pointer-events: none;
        }
        .spectator-badge.visible { display: block; }

        /* ==================== SAVE NOTIFICATION ==================== */
        .save-notification {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            background: rgba(20,20,20,0.95);
            border: 1px solid var(--text-gold);
            border-radius: 12px;
            padding: 0.8rem 1.2rem;
            color: var(--text-light);
            font-size: 0.9rem;
            z-index: 1030;
            display: none;
            gap: 0.8rem;
            align-items: center;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            max-width: 320px;
            animation: slideInRight 0.4s ease;
        }
        .save-notification.visible { display: flex; }
        @keyframes slideInRight {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .save-notification .save-btns { display: flex; gap: 0.5rem; flex-shrink: 0; }
        .save-notification button {
            padding: 0.35rem 0.9rem;
            border-radius: 20px;
            border: 1px solid var(--text-gold);
            cursor: pointer;
            font-size: 0.8rem;
            font-family: var(--font-body);
            transition: all 0.2s;
        }
        .save-notification .btn-resume {
            background: var(--text-gold);
            color: var(--stone-dark);
            font-weight: bold;
        }
        .save-notification .btn-resume:hover { filter: brightness(1.15); }
        .save-notification .btn-discard {
            background: transparent;
            color: var(--text-gold);
        }
        .save-notification .btn-discard:hover { background: rgba(240,200,80,0.1); }

        /* ==================== MILL FLASH ANIMATION ==================== */
        @keyframes millFlash {
            0% { box-shadow: inset 0 0 0 rgba(0,255,255,0), 0 0 0 0 rgba(0,255,255,0); }
            30% { box-shadow: inset 0 0 25px rgba(0,255,255,0.9), 0 0 30px rgba(0,255,255,0.8); }
            60% { box-shadow: inset 0 0 10px rgba(0,255,255,0.5), 0 0 15px rgba(0,255,255,0.4); }
            100% { box-shadow: inset 0 0 5px rgba(0,255,255,0.2), 0 0 5px rgba(0,255,255,0.2); }
        }
        .cell.mill-highlight {
            animation: mill-pulse 1.5s infinite, millFlash 0.6s ease-out !important;
        }

        /* ==================== MOBILE IMPROVEMENTS ==================== */
        @media (max-width: 480px) {
            .controls button {
                flex-basis: 70px;
                padding: 0.6rem 0.6rem;
                font-size: 0.72rem;
                max-width: none;
            }
            .controls button span { display: none; }
            .controls button i { font-size: 1.1rem; }
            .toolbar-btn span { display: none; }
            .move-history-panel { max-height: 90px; }
            .game-info-display { font-size: 0.78rem; padding: 0.4rem 0.6rem; gap: 0.6rem; }
            .selection-area { padding: 1rem; }
            .options-group { gap: 0.8rem; }
            .version-card { padding: 1rem; }
            .game-play-area.active { gap: 0.6rem; padding: 0.5rem; }
        }
        @media (max-width: 360px) {
            .splash-langs { flex-direction: column; align-items: center; }
            .splash-lang-btn { min-width: 80%; max-width: 80%; }
        }
        @media (max-width: 380px) {
            .stone { width: 72%; height: 72%; }
        }

        /* ==================== SPECTATOR SPEED CONTROLS ==================== */
        .spectator-controls {
            display: none;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(240,200,80,0.3);
            border-radius: 8px;
            padding: 0.3rem 0.75rem;
            font-size: 0.85rem;
            color: var(--text-gold);
        }
        .spectator-controls.visible { display: flex; }
        .spectator-controls select {
            background: transparent;
            color: var(--text-gold);
            border: none;
            outline: none;
            font-family: var(--font-body);
            font-size: 0.85rem;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
        }
        .spectator-controls select option { background: var(--stone-dark); color: var(--text-light); }
    
        /* ===== Accessibility + robustness improvements ===== */
        :focus-visible { outline: 3px solid rgba(240,200,80,0.9); outline-offset: 3px; }
        @media (prefers-reduced-motion: reduce) {
            * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; scroll-behavior: auto !important; }
        }
        /* Debug overlay (runtime errors, rejections, logs) */
        .debug-overlay {
            position: fixed;
            inset: auto 12px 12px 12px;
            max-height: min(55vh, 420px);
            overflow: auto;
            z-index: 5000;
            display: none;
            padding: 12px 12px 10px;
            border-radius: 14px;
            background: rgba(18, 14, 12, 0.92);
            border: 1px solid rgba(240, 200, 80, 0.25);
            box-shadow: 0 16px 50px rgba(0,0,0,0.55);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.85rem;
            line-height: 1.35;
        }
        .debug-overlay.visible { display: block; }
        .debug-overlay header {
            display: flex; align-items: center; justify-content: space-between;
            gap: 10px;
            padding: 0 0 10px 0;
            border-bottom: 1px solid rgba(240, 200, 80, 0.16);
            margin-bottom: 10px;
        }
        .debug-overlay .title { font-weight: 700; color: var(--text-gold); letter-spacing: 0.02em; }
        .debug-overlay .actions { display: flex; gap: 8px; }
        .debug-overlay button {
            appearance: none;
            border: 1px solid rgba(240,200,80,0.25);
            background: rgba(240,200,80,0.08);
            color: var(--text-light);
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.15s ease, background 0.15s ease, border-color 0.15s ease;
        }
        .debug-overlay button:hover { transform: translateY(-1px); background: rgba(240,200,80,0.12); border-color: rgba(240,200,80,0.35); }
        .debug-overlay button:active { transform: translateY(0px); }
        .debug-overlay .log { white-space: pre-wrap; word-break: break-word; }
        .debug-overlay .entry { padding: 10px 0; border-bottom: 1px dashed rgba(240,200,80,0.12); }
        .debug-overlay .entry:last-child { border-bottom: none; }
        .debug-overlay .meta { opacity: 0.85; }
        .debug-overlay .err { color: #ffb3b3; }
        .debug-overlay .warn { color: #ffd9a8; }
        .debug-overlay .info { color: #bfe3ff; }

        /* Confetti canvas (no external dependency) */
        #confetti-canvas {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 2500;
            width: 100%;
            height: 100%;
        }

    

/* =====================================================================
   DESIGN REFRESH v4 — Ergonomie + lisibilité + graphisme modernisé
   (Overrides placed at end to avoid touching core logic)
   ===================================================================== */

:root{
  /* Shape + depth */
  --radius-xs: 10px;
  --radius-sm: 14px;
  --radius-md: 18px;
  --radius-lg: 24px;
  --radius-xl: 30px;

  --shadow-1: 0 10px 24px rgba(0,0,0,.18);
  --shadow-2: 0 18px 48px rgba(0,0,0,.24);
  --shadow-3: 0 26px 76px rgba(0,0,0,.30);

  /* Layout rhythm */
  --space-1: .35rem;
  --space-2: .6rem;
  --space-3: 1rem;
  --space-4: 1.4rem;
  --space-5: 2rem;

  /* Mapping to existing theme variables */
  --surface-1: var(--panel-bg, rgba(0,0,0,.45));
  --surface-2: rgba(0,0,0,.55);
  --surface-3: rgba(255,255,255,.06);
  --border-1: var(--panel-border, rgba(240, 200, 80, 0.45));

  --focus-ring: 0 0 0 3px rgba(0, 255, 255, 0.35);
  --ease-out: cubic-bezier(.2,.9,.2,1);
}

/* Better mixing when supported */
@supports (color: color-mix(in srgb, #000 50%, #fff)) {
  :root{
    --surface-2: color-mix(in srgb, var(--surface-1) 88%, #000 12%);
    --surface-3: color-mix(in srgb, var(--surface-1) 82%, #fff 18%);
    --border-1: color-mix(in srgb, var(--panel-border, rgba(240,200,80,.45)) 75%, transparent);
    --focus-ring: 0 0 0 3px color-mix(in srgb, var(--highlight-cyan) 55%, transparent);
  }
}

/* Shadows tuned per theme brightness */
[data-theme="kabylie"], [data-theme="desert"]{
  --shadow-1: 0 10px 25px rgba(31,26,18,.12);
  --shadow-2: 0 18px 55px rgba(31,26,18,.18);
  --shadow-3: 0 28px 78px rgba(31,26,18,.22);
}
[data-theme="nuit"], [data-theme="glass"], [data-theme="contrast"]{
  --shadow-1: 0 10px 25px rgba(0,0,0,.26);
  --shadow-2: 0 18px 55px rgba(0,0,0,.30);
  --shadow-3: 0 28px 78px rgba(0,0,0,.36);
}

/* =====================================================================
   Global readability + accessibility
   ===================================================================== */

html{ text-size-adjust: 100%; }
body{
  font-family: var(--font-ui);
  line-height: 1.6;
  letter-spacing: .1px;
  text-rendering: optimizeLegibility;
}
::selection{
  background: rgba(0, 255, 255, 0.22);
}
a, button, select, input, textarea{
  -webkit-tap-highlight-color: transparent;
}
:focus{ outline: none; }
:focus-visible{
  box-shadow: var(--focus-ring) !important;
  outline: none !important;
}
@media (prefers-reduced-motion: reduce){
  *{ animation: none !important; transition: none !important; scroll-behavior: auto !important; }
}

/* Subtle texture + depth behind the app (graphisme) */
.game-container{
  position: relative;
}
.game-container::before{
  content:"";
  position:absolute;
  inset:-24px;
  pointer-events:none;
  z-index:0;
  opacity:.24;
  background:
    radial-gradient(600px 220px at 18% 12%, rgba(255,255,255,.18), transparent 65%),
    radial-gradient(520px 260px at 82% 8%, rgba(0,255,255,.10), transparent 68%),
    radial-gradient(620px 320px at 52% 82%, rgba(240,200,80,.10), transparent 70%),
    url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160' viewBox='0 0 160 160'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='2' stitchTiles='stitch'/></filter><rect width='160' height='160' filter='url(%23n)' opacity='.22'/></svg>");
  mix-blend-mode: overlay;
  filter: saturate(1.05) contrast(1.02);
}
.game-container > *{ position: relative; z-index: 1; }

/* Scrollbars (ergonomie) */
.selection-area, .rules-book, .move-history-log{
  scrollbar-width: thin;
  scrollbar-color: rgba(240,200,80,.55) transparent;
}
.selection-area::-webkit-scrollbar,
.rules-book::-webkit-scrollbar,
.move-history-log::-webkit-scrollbar{ width: 10px; }
.selection-area::-webkit-scrollbar-thumb,
.rules-book::-webkit-scrollbar-thumb,
.move-history-log::-webkit-scrollbar-thumb{
  background: rgba(240,200,80,.35);
  border-radius: 999px;
  border: 2px solid transparent;
  background-clip: padding-box;
}
.selection-area::-webkit-scrollbar-thumb:hover,
.rules-book::-webkit-scrollbar-thumb:hover,
.move-history-log::-webkit-scrollbar-thumb:hover{
  background: rgba(240,200,80,.55);
  background-clip: padding-box;
}

/* =====================================================================
   Header + title (moins chargé, plus premium)
   ===================================================================== */

header{
  padding: .9rem 0 .7rem;
}
header::before{
  content:"";
  position:absolute;
  inset:auto 10% 0 10%;
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(240,200,80,.6), transparent);
  opacity: .55;
}
h1{
  font-weight: 800;
  letter-spacing: .22em;
  text-transform: uppercase;
  text-shadow: 0 8px 18px rgba(0,0,0,.30);
}
h1::after{
  filter: drop-shadow(0 10px 22px rgba(0,0,0,.26));
  opacity: .55;
}

/* =====================================================================
   Cards / panels (cohérence visuelle)
   ===================================================================== */

.selection-area{
  border-radius: var(--radius-xl);
  border: 1px solid var(--border-1);
  background: var(--surface-1);
  box-shadow: var(--shadow-3);
  backdrop-filter: blur(var(--glass-blur, 10px));
  -webkit-backdrop-filter: blur(var(--glass-blur, 10px));
  gap: 1.25rem;
}
.selection-area h2{
  letter-spacing: .06em;
  text-shadow: 0 10px 18px rgba(0,0,0,.18);
}
.selection-area p{
  max-width: 72ch;
  line-height: 1.62;
  color: var(--text-main);
  opacity: .92;
}

/* Shared card treatment for selectable tiles */
.version-card, .mode-card, .difficulty-card, .option-btn{
  border-radius: var(--radius-lg);
  border: 1px solid color-mix(in srgb, var(--border-1) 70%, transparent);
  box-shadow: var(--shadow-1);
  overflow: hidden;
  transform: translateZ(0);
  transition: transform .22s var(--ease-out), box-shadow .22s var(--ease-out), border-color .22s var(--ease-out), filter .22s var(--ease-out);
}
@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
  .version-card, .mode-card, .difficulty-card, .option-btn{ border: 1px solid var(--border-1); }
}
.version-card:hover, .mode-card:hover, .difficulty-card:hover, .option-btn:hover{
  transform: translateY(-4px) scale(1.01);
  box-shadow: var(--shadow-2);
  filter: saturate(1.05);
}
.version-card:active, .mode-card:active, .difficulty-card:active, .option-btn:active{
  transform: translateY(-1px) scale(0.99);
  box-shadow: var(--shadow-1);
}

.version-card h3, .mode-card h3, .difficulty-card h3{
  letter-spacing: .14em;
}
.version-card p, .mode-card p, .difficulty-card p, .option-btn p{
  color: var(--text-main);
  opacity: .9;
}

/* =====================================================================
   Buttons (ergonomie + interactions)
   ===================================================================== */

.controls button,
.start-game-btn,
.rules-btn,
.back-btn,
.toolbar-btn,
#settings-fab,
.modal-actions button,
#confirm-surrender-btn,
#cancel-surrender-btn{
  border-radius: 999px;
  border: 1px solid color-mix(in srgb, var(--border-1) 70%, transparent);
  box-shadow: var(--shadow-1);
  transition: transform .18s var(--ease-out), box-shadow .18s var(--ease-out), filter .18s var(--ease-out), background-color .18s var(--ease-out);
  position: relative;
  overflow: hidden;
}
@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
  .controls button,
  .start-game-btn,
  .rules-btn,
  .back-btn,
  .toolbar-btn,
  #settings-fab,
  .modal-actions button,
  #confirm-surrender-btn,
  #cancel-surrender-btn{ border: 1px solid var(--border-1); }
}

.controls button:hover,
.start-game-btn:hover,
.rules-btn:hover,
.back-btn:hover,
.toolbar-btn:hover,
#settings-fab:hover,
.modal-actions button:hover{
  transform: translateY(-2px);
  box-shadow: var(--shadow-2);
  filter: saturate(1.05);
}
.controls button:active,
.start-game-btn:active,
.rules-btn:active,
.back-btn:active,
.toolbar-btn:active,
#settings-fab:active,
.modal-actions button:active{
  transform: translateY(-1px);
  box-shadow: var(--shadow-1);
}

/* Ripple-like feedback (CSS only) */
.controls button::after,
.start-game-btn::after,
.rules-btn::after,
.back-btn::after,
.toolbar-btn::after,
#settings-fab::after,
.modal-actions button::after{
  content:"";
  position:absolute;
  inset:-1px;
  background:
    radial-gradient(220px 220px at var(--mx, 50%) var(--my, 50%),
      rgba(255,255,255,.28), transparent 55%);
  opacity: 0;
  transition: opacity .22s var(--ease-out);
}
.controls button:active::after,
.start-game-btn:active::after,
.rules-btn:active::after,
.back-btn:active::after,
.toolbar-btn:active::after,
#settings-fab:active::after,
.modal-actions button:active::after{
  opacity: 1;
}

/* Typography tweak inside pill buttons */
.start-game-btn, .rules-btn, .back-btn{
  letter-spacing: .08em;
  text-transform: uppercase;
}

/* =====================================================================
   Form controls (plus nets et cohérents)
   ===================================================================== */

select, input[type="text"]{
  border-radius: var(--radius-md);
  border: 1px solid color-mix(in srgb, var(--border-1) 75%, transparent);
  background: var(--surface-2);
  color: var(--text-main);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
}
select:hover, input[type="text"]:hover{
  filter: saturate(1.05);
}
[data-theme="kabylie"] select, [data-theme="kabylie"] input[type="text"],
[data-theme="desert"] select, [data-theme="desert"] input[type="text"]{
  background: rgba(255,255,255,.85);
  color: #1f1a12;
}

/* =====================================================================
   Board + cells (graphisme + lisibilité des états)
   ===================================================================== */

.board{
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-3);
  overflow: hidden;
  outline: 1px solid rgba(255,255,255,.06);
}
.cell{
  border-radius: 14px;
  transition: transform .18s var(--ease-out), box-shadow .18s var(--ease-out), background-color .18s var(--ease-out), border-color .18s var(--ease-out);
}
.cell:hover{
  transform: translateY(-1px);
  border-color: rgba(240,200,80,.55);
  box-shadow:
    inset 1px 1px 6px rgba(255,255,255,0.45),
    inset -1px -1px 6px rgba(0,0,0,0.45),
    0 10px 18px rgba(0,0,0,0.18);
}
.cell.possible-move{
  outline-style: solid;
  outline-color: rgba(0,255,255,.55);
  background: rgba(0,255,255,.10);
}
.cell.possible-move:hover{
  background: rgba(0,255,255,.18);
}
.cell.mill-highlight{
  box-shadow: 0 0 0 3px rgba(240,200,80,.45), inset 0 0 18px rgba(240,200,80,.22);
}

/* Stones a bit more “premium” */
.stone{
  box-shadow:
    0 10px 22px rgba(0,0,0,0.45),
    inset 0 -8px 16px rgba(0,0,0,0.40),
    inset 0 10px 12px rgba(255,255,255,0.22);
}
.stone::after{
  content:"";
  position:absolute;
  inset: 12% 18% auto 18%;
  height: 28%;
  border-radius: 999px;
  background: linear-gradient(180deg, rgba(255,255,255,.35), transparent);
  opacity: .65;
  pointer-events:none;
}

/* =====================================================================
   Modal / Rules (lecture plus confortable)
   ===================================================================== */

.modal-content, .rules-book{
  border-radius: var(--radius-xl);
  border: 1px solid var(--border-1);
  box-shadow: var(--shadow-3);
}
.rules-book{
  font-family: var(--font-body);
  line-height: 1.7;
  font-size: 1.02rem;
}
.rules-book h2, .rules-book h3{
  font-family: var(--font-title);
  letter-spacing: .08em;
}

/* =====================================================================
   Toolbars (moins “brut”, plus cohérent)
   ===================================================================== */

.toolbar-btn{
  gap: .55rem;
  padding: .65rem .9rem !important;
}
#settings-fab{
  width: 46px;
  height: 46px;
  border-radius: 999px;
  box-shadow: var(--shadow-2);
}

/* =====================================================================
   Micro-animations (subtiles)
   ===================================================================== */

@keyframes softFloat {
  0%{ transform: translateY(0); }
  50%{ transform: translateY(-10px); }
  100%{ transform: translateY(0); }
}
.stone-decoration{
  animation: softFloat 6s var(--ease-out) infinite;
  opacity: .14;
}
.stone-2{ animation-duration: 7.5s; }
.stone-3{ animation-duration: 6.8s; }
.stone-4{ animation-duration: 8.6s; }

/* Make the ephemeral message feel integrated */
.ephemeral-message-bubble{
  border-radius: var(--radius-lg) !important;
  background: var(--surface-1) !important;
  border: 1px solid var(--border-1) !important;
  box-shadow: var(--shadow-2) !important;
  color: var(--text-main) !important;
}
[data-theme="kabylie"] .ephemeral-message-bubble,
[data-theme="desert"] .ephemeral-message-bubble{
  background: rgba(255,255,255,.92) !important;
  color: #1f1a12 !important;
}


/* Soft sheen on selectable cards */
.version-card::after, .mode-card::after, .difficulty-card::after, .option-btn::after{
  content:"";
  position:absolute;
  inset:-1px;
  background:
    radial-gradient(260px 260px at var(--mx, 30%) var(--my, 10%),
      rgba(255,255,255,.22), transparent 58%),
    linear-gradient(135deg, transparent, rgba(255,255,255,.05), transparent);
  opacity: 0;
  transition: opacity .22s var(--ease-out);
  pointer-events:none;
}
.version-card:hover::after, .mode-card:hover::after, .difficulty-card:hover::after, .option-btn:hover::after{
  opacity: .65;
}


@supports not (color: color-mix(in srgb, #000 50%, #fff)) {
  select, input[type="text"]{ border: 1px solid var(--border-1); }
}


/* ==================== MODERN THEME (Clean UI) ==================== */
/* A modern, readable UI layer that stays compatible with the existing game visuals. */
[data-theme="modern"],
[data-theme="modern-dark"]{
  /* Typography + rhythm */
  --font-ui: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  --font-title: 'Space Grotesk', var(--font-ui);
  --font-body: 'Inter', var(--font-ui);
  --transition-duration: 0.18s;

  /* Radii + shadows */
  --radius-sm: 10px;
  --radius-md: 14px;
  --radius-lg: 18px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.06);
  --shadow-md: 0 10px 28px rgba(0,0,0,0.10);
  --shadow-lg: 0 18px 50px rgba(0,0,0,0.14);
}

/* Light */
[data-theme="modern"]{
  --text-main: #0f172a;
  --text-muted: #475569;
  --text-light: #ffffff;
  --text-gold: #2563eb;

  /* Turn the old “wood/stone” variables into a modern primary/accent system */
  --wood-dark: #2563eb;
  --wood-medium: #3b82f6;
  --wood-light: #60a5fa;

  --stone-dark: #0f172a;
  --stone-medium: #334155;
  --stone-light: #e2e8f0;

  --highlight-cyan: #06b6d4;
  --danger-red: #ef4444;

  --bg-start: #f8fafc;
  --bg-end: #eef2ff;

  --panel-bg: rgba(255,255,255,0.92);
  --panel-border: rgba(15,23,42,0.10);
  --cell-border: rgba(15,23,42,0.12);

  --board-surface-light: rgba(255,255,255,0.85);
  --parchment-bg: rgba(255,255,255,0.75);
  --board-border-dark: rgba(15,23,42,0.14);
}

/* Dark */
[data-theme="modern-dark"]{
  --text-main: rgba(248,250,252,0.96);
  --text-muted: rgba(226,232,240,0.78);
  --text-light: #ffffff;
  --text-gold: #38bdf8;

  --wood-dark: #0ea5e9;
  --wood-medium: #38bdf8;
  --wood-light: #7dd3fc;

  --stone-dark: #020617;
  --stone-medium: #0f172a;
  --stone-light: #1f2937;

  --highlight-cyan: #22d3ee;
  --danger-red: #fb7185;

  --bg-start: #0b1220;
  --bg-end: #0a0f1c;

  --panel-bg: rgba(2,6,23,0.60);
  --panel-border: rgba(148,163,184,0.16);
  --cell-border: rgba(148,163,184,0.16);

  --board-surface-light: rgba(2,6,23,0.50);
  --parchment-bg: rgba(2,6,23,0.50);
  --board-border-dark: rgba(148,163,184,0.18);
}

/* Body / background (remove the decorative svg texture for a cleaner look) */
[data-theme="modern"] body{
  background: radial-gradient(800px 500px at 15% 10%, rgba(59,130,246,0.14), transparent 55%),
              radial-gradient(700px 450px at 85% 15%, rgba(16,185,129,0.10), transparent 55%),
              linear-gradient(180deg, var(--bg-start), var(--bg-end));
  color: var(--text-main);
  font-family: var(--font-body);
  line-height: 1.6;
  letter-spacing: 0.1px;
  text-shadow: none;
  background-image: none;
}

[data-theme="modern-dark"] body{
  background: radial-gradient(900px 600px at 15% 10%, rgba(56,189,248,0.16), transparent 60%),
              radial-gradient(700px 520px at 85% 20%, rgba(34,211,238,0.10), transparent 60%),
              linear-gradient(180deg, var(--bg-start), var(--bg-end));
  color: var(--text-main);
  font-family: var(--font-body);
  line-height: 1.6;
  letter-spacing: 0.1px;
  text-shadow: none;
  background-image: none;
}

/* Headings (no fantasy glow) */
[data-theme="modern"] h1,
[data-theme="modern-dark"] h1{
  font-family: var(--font-title);
  color: var(--text-main);
  text-shadow: none;
  letter-spacing: -0.5px;
}
[data-theme="modern"] h2,
[data-theme="modern-dark"] h2{
  font-family: var(--font-title);
  color: var(--text-main);
  text-shadow: none;
  letter-spacing: -0.2px;
}

/* Panels / cards */
[data-theme="modern"] .selection-area,
[data-theme="modern-dark"] .selection-area,
[data-theme="modern"] .player-info,
[data-theme="modern-dark"] .player-info,
[data-theme="modern"] .status,
[data-theme="modern-dark"] .status,
[data-theme="modern"] .game-info-display,
[data-theme="modern-dark"] .game-info-display,
[data-theme="modern"] .move-history-panel,
[data-theme="modern-dark"] .move-history-panel,
[data-theme="modern"] .version-card,
[data-theme="modern-dark"] .version-card,
[data-theme="modern"] .difficulty-card,
[data-theme="modern-dark"] .difficulty-card,
[data-theme="modern"] .mode-card,
[data-theme="modern-dark"] .mode-card{
  background: var(--panel-bg) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--radius-lg) !important;
  box-shadow: var(--shadow-md) !important;
  color: var(--text-main) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}

[data-theme="modern"] .selection-area p,
[data-theme="modern-dark"] .selection-area p,
[data-theme="modern"] .move-history-panel p,
[data-theme="modern-dark"] .move-history-panel p{
  color: var(--text-muted) !important;
}

/* Tool buttons / language selector (top UI) */
[data-theme="modern"] .toolbar-btn,
[data-theme="modern-dark"] .toolbar-btn,
[data-theme="modern"] .language-selector,
[data-theme="modern-dark"] .language-selector{
  background: var(--panel-bg) !important;
  border: 1px solid var(--panel-border) !important;
  box-shadow: var(--shadow-sm) !important;
  color: var(--text-main) !important;
  border-radius: var(--radius-md) !important;
}

[data-theme="modern"] .toolbar-btn:hover,
[data-theme="modern-dark"] .toolbar-btn:hover{
  transform: translateY(-1px);
  box-shadow: var(--shadow-md) !important;
}

/* Buttons (modern, less “pill”, clearer states) */
[data-theme="modern"] button,
[data-theme="modern-dark"] button,
[data-theme="modern"] .option-btn,
[data-theme="modern-dark"] .option-btn,
[data-theme="modern"] .btn-resume,
[data-theme="modern-dark"] .btn-resume,
[data-theme="modern"] .btn-discard,
[data-theme="modern-dark"] .btn-discard{
  border-radius: var(--radius-md) !important;
  border: 1px solid rgba(255,255,255,0.0);
  box-shadow: var(--shadow-sm) !important;
  text-transform: none !important;
  letter-spacing: 0.15px !important;
}

[data-theme="modern"] button,
[data-theme="modern"] .option-btn,
[data-theme="modern"] .btn-resume{
  background: linear-gradient(180deg, rgba(37,99,235,0.98), rgba(59,130,246,0.92)) !important;
  color: #ffffff !important;
  border-color: rgba(15,23,42,0.06) !important;
}

[data-theme="modern-dark"] button,
[data-theme="modern-dark"] .option-btn,
[data-theme="modern-dark"] .btn-resume{
  background: linear-gradient(180deg, rgba(14,165,233,0.95), rgba(56,189,248,0.85)) !important;
  color: #001018 !important;
  border-color: rgba(125,211,252,0.35) !important;
}

[data-theme="modern"] .btn-discard,
[data-theme="modern-dark"] .btn-discard{
  background: transparent !important;
  border: 1px solid var(--panel-border) !important;
  color: var(--text-main) !important;
}

[data-theme="modern"] button:hover,
[data-theme="modern-dark"] button:hover,
[data-theme="modern"] .option-btn:hover,
[data-theme="modern-dark"] .option-btn:hover{
  transform: translateY(-1px);
  box-shadow: var(--shadow-md) !important;
  filter: saturate(1.08);
}

[data-theme="modern"] button:active,
[data-theme="modern-dark"] button:active,
[data-theme="modern"] .option-btn:active,
[data-theme="modern-dark"] .option-btn:active{
  transform: translateY(0px) scale(0.99);
}

/* Focus rings (keyboard accessibility) */
[data-theme="modern"] :focus-visible,
[data-theme="modern-dark"] :focus-visible{
  outline: 3px solid rgba(37,99,235,0.35);
  outline-offset: 2px;
  border-radius: 10px;
}

/* Board: cleaner grid, less inset “carving” */
[data-theme="modern"] .game-board,
[data-theme="modern-dark"] .game-board{
  border-radius: var(--radius-lg) !important;
  border: 1px solid var(--board-border-dark) !important;
  box-shadow: var(--shadow-lg) !important;
  background: var(--board-surface-light) !important;
}

[data-theme="modern"] .cell,
[data-theme="modern-dark"] .cell{
  box-shadow: none !important;
  border-color: var(--cell-border) !important;
  background: rgba(15,23,42,0.02);
}

[data-theme="modern-dark"] .cell{
  background: rgba(148,163,184,0.06);
}

[data-theme="modern"] .cell:hover,
[data-theme="modern-dark"] .cell:hover{
  background: rgba(37,99,235,0.10) !important;
}

/* Modals: clean surface */
[data-theme="modern"] .modal-content,
[data-theme="modern-dark"] .modal-content{
  background: var(--panel-bg) !important;
  border: 1px solid var(--panel-border) !important;
  border-radius: var(--radius-lg) !important;
  box-shadow: var(--shadow-lg) !important;
  color: var(--text-main) !important;
  text-shadow: none !important;
}

[data-theme="modern"] .modal-content h3,
[data-theme="modern-dark"] .modal-content h3{
  color: var(--text-main) !important;
  text-shadow: none !important;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  [data-theme="modern"] *,
  [data-theme="modern-dark"] *{
    animation-duration: 0.001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.001ms !important;
    scroll-behavior: auto !important;
  }
}

/* Move history visibility in modern themes */
[data-theme="modern"] .move-log-entry { color: var(--text-main) !important; }
[data-theme="modern"] .move-history-title { color: var(--wood-medium) !important; opacity: 1 !important; }
[data-theme="modern"] .move-log-entry.mill-entry { background: rgba(6,182,212,0.10) !important; border-left-color: var(--highlight-cyan) !important; }
[data-theme="modern"] .move-log-entry.capture-entry { background: rgba(239,68,68,0.08) !important; border-left-color: var(--danger-red) !important; }
[data-theme="modern-dark"] .move-log-entry { color: var(--text-main) !important; }
[data-theme="modern-dark"] .move-history-title { color: var(--text-gold) !important; opacity: 1 !important; }
[data-theme="modern-dark"] .move-log-entry.mill-entry { background: rgba(34,211,238,0.12) !important; border-left-color: var(--highlight-cyan) !important; }
[data-theme="modern-dark"] .move-log-entry.capture-entry { background: rgba(251,113,133,0.12) !important; border-left-color: var(--danger-red) !important; }

/* Modern theme play button */
[data-theme="modern"] .start-game-btn,
[data-theme="modern-dark"] .start-game-btn {
    background: linear-gradient(145deg, #3b82f6, #2563eb, #1d4ed8) !important;
    color: #ffffff !important;
    border-color: rgba(15,23,42,0.2) !important;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3) !important;
    box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 3px 0 rgba(0,0,0,0.2) !important;
    letter-spacing: 3px !important;
    animation: playBtnPulseBlue 2.5s ease-in-out infinite !important;
}
[data-theme="modern"] .start-game-btn:hover,
[data-theme="modern-dark"] .start-game-btn:hover {
    background: linear-gradient(145deg, #60a5fa, #3b82f6, #2563eb) !important;
    box-shadow: 0 14px 36px rgba(37,99,235,0.5), 0 0 40px rgba(59,130,246,0.45) !important;
}
@keyframes playBtnPulseBlue {
    0%, 100% { box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 0 0 0 rgba(59,130,246,0.5), 0 3px 0 rgba(0,0,0,0.2); }
    50% { box-shadow: 0 8px 24px rgba(37,99,235,0.4), 0 0 0 8px rgba(59,130,246,0), 0 3px 0 rgba(0,0,0,0.2); }
}



/* =======================================================================
   Modern Responsive + Buttons Visibility Patch (v3)
   - Better mobile/tablet layout (without shrinking desktop layout)
   - Settings button emphasized
   - Ensures button text/icons stay readable across themes
   ======================================================================= */

/* Button design tokens (safe defaults) */
:root{
  --btn-radius: 14px;
  --btn-bg: linear-gradient(145deg, var(--wood-light), var(--wood-medium));
  --btn-bg-hover: linear-gradient(145deg, var(--wood-medium), var(--wood-dark));
  --btn-border: rgba(0,0,0,0.18);
  --btn-fg: var(--text-light);
  --btn-shadow: 0 10px 22px rgba(0,0,0,0.28);
  --btn-shadow-hover: 0 14px 30px rgba(0,0,0,0.33);
}

/* Modern themes: consistent, high-contrast buttons */
[data-theme="modern"],
[data-theme="modern-dark"]{
  --btn-radius: 14px;
  --btn-bg: linear-gradient(180deg, rgba(37,99,235,0.96), rgba(29,78,216,0.96));
  --btn-bg-hover: linear-gradient(180deg, rgba(29,78,216,0.99), rgba(30,64,175,0.99));
  --btn-border: rgba(15,23,42,0.14);
  --btn-fg: #ffffff;
  --btn-shadow: 0 12px 26px rgba(2,6,23,0.18);
  --btn-shadow-hover: 0 16px 34px rgba(2,6,23,0.24);
}

/* Fix incomplete modern-dark theme vars (bg + panel + board + text) */
[data-theme="modern-dark"]{
  --text-main: #e5e7eb;
  --text-muted: rgba(229,231,235,0.74);
  --text-light: #ffffff;
  --text-gold: #60a5fa;

  --stone-dark: #0b1220;
  --stone-medium: #111827;
  --stone-light: #1f2937;

  --wood-dark: #2563eb;
  --wood-medium: #3b82f6;
  --wood-light: #60a5fa;

  --bg-start: #070b16;
  --bg-end: #0b1220;

  --panel-bg: rgba(15,23,42,0.72);
  --panel-border: rgba(148,163,184,0.18);
  --board-surface-light: rgba(15,23,42,0.64);
  --parchment-bg: rgba(15,23,42,0.52);
  --board-border-dark: rgba(148,163,184,0.22);
  --cell-border: rgba(148,163,184,0.16);
}

/* Universal button readability */
button{
  border-radius: var(--btn-radius);
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-border);
  box-shadow: var(--btn-shadow);
  max-width: none; /* important for mobile */
  text-shadow: none;
}
button:hover{
  background: var(--btn-bg-hover);
  box-shadow: var(--btn-shadow-hover);
}
button:active{ transform: translateY(1px); }
button:focus-visible{
  outline: 3px solid rgba(59,130,246,0.45);
  outline-offset: 3px;
}
button:disabled{
  opacity: 0.58;
  filter: saturate(0.9);
  cursor: not-allowed;
}
button i, button svg, .toolbar-btn i, .toolbar-btn svg{ color: currentColor; }

/* Settings entry point: bigger + clearer + persistent label on larger screens */
#settings-fab{
  position: relative;
  width: auto;
  min-width: 48px;
  height: 48px;
  padding: 0.65rem 0.9rem;
  border-radius: 999px;
  gap: 0.55rem;
  font-size: 1.05rem;
  background: linear-gradient(180deg, rgba(34,197,94,0.95), rgba(16,185,129,0.95));
  border: 1px solid rgba(2,6,23,0.14);
  box-shadow: 0 14px 34px rgba(2,6,23,0.22);
  color: #ffffff;
  transform: none;
}
#settings-fab::before{
  content:"";
  position:absolute;
  inset:-7px;
  border-radius: inherit;
  background: radial-gradient(circle, rgba(16,185,129,0.28), transparent 55%);
  opacity: 0.85;
  z-index:-1;
  animation: settingsPulse 2.6s ease-in-out infinite;
}
#settings-fab:hover{
  transform: translateY(-1px);
  box-shadow: 0 18px 44px rgba(2,6,23,0.28);
}
#settings-fab.open{ transform: none; }

.settings-icon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-size: 1.15rem;
  line-height: 1;
}
.settings-label{
  display:none;
  font-size: 0.88rem;
  font-weight: 800;
  letter-spacing: 0.2px;
  white-space: nowrap;
}
#settings-fab.open .settings-label{ display:inline; }
@media (min-width: 640px){
  .settings-label{ display:inline; }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce){
  #settings-fab::before{ animation: none; }
  button:active{ transform: none; }
}

@keyframes settingsPulse{
  0%   { transform: scale(0.96); opacity: 0.55; }
  50%  { transform: scale(1.02); opacity: 0.95; }
  100% { transform: scale(0.96); opacity: 0.55; }
}

/* Keep the FAB from covering content on phones */
@media (max-width: 720px){
  .game-play-area.active{ padding-bottom: 5.5rem; }
  .toolbar-buttons{
    bottom: calc(0.75rem + env(safe-area-inset-bottom));
    left: calc(0.75rem + env(safe-area-inset-left));
    right: auto !important;
    gap: 0.6rem;
  }
}

/* Responsive board sizing (only for tablets/phones) */
@media (max-width: 1024px){
  .game-board-container{ width: min(94vw, 72vh, 600px); }
}
@media (max-width: 640px){
  .game-board-container{ width: min(94vw, 68vh, 560px); padding: 12px; border-width: 9px; }
}
/* Short screens (landscape phones) */
@media (max-height: 680px){
  .game-board-container{ width: min(94vw, 62vh, 560px); padding: 12px; border-width: 8px; }
}

/* Controls: better wrapping on mobile + keep labels visible */
@media (max-width: 760px){
  .controls button{
    flex: 1 1 calc(50% - 0.75rem);
    min-height: 44px;
  }
}
@media (max-width: 480px){
  .controls{ gap: 0.6rem; }
  .controls button{
    flex-basis: auto;
    padding: 0.65rem 0.75rem;
    font-size: 0.78rem;
    gap: 6px;
  }
  /* undo previous rules that were hiding labels */
  .controls button span{ display:inline !important; }
  .toolbar-btn span{ display:inline !important; }
  .controls button i{ font-size: 1.05rem; }
}
@media (max-width: 360px){
  .controls button{ flex: 1 1 100%; font-size: 0.8rem; }
}


/* =======================================================================
   UI Placement + Back Button Fix (v4)
   - Move Settings button to a more visible top-right position (with safe-area)
   - Fix "Retour" buttons (style + sticky visibility in scroll panels)
   - Patch a few remaining responsive display issues (dvh, overflow)
   ======================================================================= */

/* Better mobile viewport handling (prevents cut-off on iOS/Android) */
@supports (height: 100dvh){
  body{ min-height: 100dvh; }
}

/* Selection panels: use dynamic viewport when available */
@supports (max-height: 100dvh){
  .selection-area{ max-height: min(90vh, calc(100dvh - 120px)); }
}

/* SETTINGS: Bottom-left anchor — ne gêne pas le × des règles (haut-droite) */
.toolbar-buttons{
  top: auto !important;
  left: calc(0.9rem + env(safe-area-inset-left));
  right: auto !important;
  bottom: calc(0.9rem + env(safe-area-inset-bottom));
  flex-direction: column; /* tray s'ouvre vers le haut */
  align-items: flex-start;
  z-index: 1200;
}

/* Short screens (landscape phones): same */
@media (max-height: 560px){
  .toolbar-buttons{
    bottom: calc(0.5rem + env(safe-area-inset-bottom));
    flex-direction: column;
  }
}

/* Ensure tray stays readable + doesn't look "floating dark" in modern theme */
.settings-tray{
  background: transparent;
}
.settings-tray .toolbar-btn,
.settings-tray .language-selector{
  backdrop-filter: blur(10px);
}

/* Toolbar buttons: force high contrast + consistent hit area */
.toolbar-btn{
  min-height: 44px;
  padding: 0.55rem 0.9rem !important;
  background: var(--btn-bg) !important;
  color: var(--btn-fg) !important;
  border: 1px solid var(--btn-border) !important;
  box-shadow: var(--btn-shadow) !important;
}
.toolbar-btn:hover{
  background: var(--btn-bg-hover) !important;
  box-shadow: var(--btn-shadow-hover) !important;
}
.toolbar-btn span{ display: inline !important; }

/* Language selector to match toolbar buttons */
.language-selector{
  min-height: 44px;
  padding: 0.45rem 0.9rem;
  border-radius: 999px;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-border);
  box-shadow: var(--btn-shadow);
}
.language-selector select,
.language-selector i{ color: inherit !important; }

/* BACK buttons: make them visible everywhere + modern look */
:root{
  --btn-secondary-bg: rgba(0,0,0,0.16);
  --btn-secondary-bg-hover: rgba(0,0,0,0.24);
  --btn-secondary-fg: var(--text-light);
  --btn-secondary-border: rgba(255,255,255,0.22);
}
[data-theme="modern"]{
  --btn-secondary-bg: rgba(15,23,42,0.06);
  --btn-secondary-bg-hover: rgba(15,23,42,0.10);
  --btn-secondary-fg: var(--text-main);
  --btn-secondary-border: rgba(15,23,42,0.12);
}
[data-theme="modern-dark"]{
  --btn-secondary-bg: rgba(148,163,184,0.10);
  --btn-secondary-bg-hover: rgba(148,163,184,0.16);
  --btn-secondary-fg: var(--text-main);
  --btn-secondary-border: rgba(148,163,184,0.18);
}

.back-btn{
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.55rem;
  min-height: 44px;
  padding: 0.65rem 1.1rem;
  border-radius: 999px;
  background: var(--btn-secondary-bg) !important;
  color: var(--btn-secondary-fg) !important;
  border: 1px solid var(--btn-secondary-border) !important;
  box-shadow: var(--shadow-sm, 0 6px 16px rgba(0,0,0,0.18)) !important;
  text-shadow: none !important;
  letter-spacing: 0.2px;
  margin-top: 1.1rem;
}
.back-btn::before{
  content: "←";
  font-weight: 900;
  line-height: 1;
  opacity: 0.9;
}
.back-btn:hover{
  background: var(--btn-secondary-bg-hover) !important;
  transform: translateY(-1px);
}

/* Keep back buttons visible even when selection area scrolls */
.selection-area .back-btn{
  position: sticky;
  bottom: 0.75rem;
  z-index: 2;
}
.selection-area{
  padding-bottom: 4.5rem; /* space for the sticky back button */
}

/* Prevent text/icon clipping inside small buttons */
button, .toolbar-btn, .back-btn{
  line-height: 1.15;
}

</style>
<style nonce="tiddas">
/* =========================================================
   TIDDAS v6 – Pack UI/UX + Gameplay + Produit additions
   (single-file patch)
   ========================================================= */

/* Improve touch on mobile */
button, .toolbar-btn, .cell { touch-action: manipulation; }

/* Better keyboard focus */
.cell:focus-visible, button:focus-visible, select:focus-visible {
  outline: 3px solid rgba(240,200,80,0.95);
  outline-offset: 2px;
}

/* Last action highlights */
.cell.last-move-from { box-shadow: inset 0 0 0 2px rgba(99,164,255,0.95), 0 0 18px rgba(99,164,255,0.35); }
.cell.last-move-to   { box-shadow: inset 0 0 0 2px rgba(0,255,255,0.95), 0 0 18px rgba(0,255,255,0.35); }
.cell.last-capture   { box-shadow: inset 0 0 0 2px rgba(255,77,77,0.98), 0 0 18px rgba(255,77,77,0.35); }

/* Guided mode pulsing pieces */
.stone.hint-piece {
  animation: tiddasHintPulse 1.05s ease-in-out infinite;
  filter: drop-shadow(0 0 10px rgba(240,200,80,0.25));
}
@keyframes tiddasHintPulse {
  0%,100% { transform: scale(1); }
  50% { transform: scale(1.06); }
}

/* Toasts */
.toast {
  position: fixed;
  left: 50%;
  transform: translateX(-50%) translateY(12px);
  bottom: calc(16px + env(safe-area-inset-bottom, 0px));
  background: rgba(0,0,0,0.82);
  border: 1px solid rgba(240,200,80,0.35);
  color: var(--text-main);
  padding: 10px 14px;
  border-radius: 14px;
  max-width: min(92vw, 720px);
  width: fit-content;
  opacity: 0;
  pointer-events: none;
  z-index: 6500;
  transition: opacity 0.22s ease, transform 0.22s ease;
  font-size: 0.92rem;
  line-height: 1.25;
}
.toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
.toast .toast-strong { color: var(--text-gold); font-weight: 700; }

/* App modals (Stats / Replay / Install help) */
.modal-overlay.app-modal { z-index: 6000; }
.modal-content.stats-modal-content,
.modal-content.replay-modal-content,
.modal-content.install-modal-content {
  max-width: 760px;
  text-align: left;
}
.modal-content.stats-modal-content h3,
.modal-content.replay-modal-content h3,
.modal-content.install-modal-content h3 {
  text-align: center;
}
.stats-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
  margin: 10px 0 14px;
}
.stat-card {
  background: rgba(0,0,0,0.30);
  border: 1px solid rgba(240,200,80,0.22);
  border-radius: 12px;
  padding: 10px 12px;
}
.stat-card .k { font-size: 0.78rem; opacity: 0.85; text-transform: uppercase; letter-spacing: 0.5px; }
.stat-card .v { font-size: 1.12rem; font-weight: 800; color: var(--text-gold); margin-top: 4px; }

.progress-bar {
  height: 10px;
  border-radius: 999px;
  background: rgba(255,255,255,0.10);
  overflow: hidden;
  border: 1px solid rgba(240,200,80,0.20);
}
.progress-bar > div {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, rgba(240,200,80,0.35), rgba(0,255,255,0.35));
}

/* Replay controls */
.replay-controls {
  display: flex;
  gap: 8px;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
  margin: 10px 0 8px;
}
.replay-controls button {
  padding: 0.65rem 0.85rem;
  border-radius: 999px;
  border: 1px solid rgba(240,200,80,0.25);
  background: rgba(0,0,0,0.30);
  color: var(--text-main);
}
.replay-controls button:hover { background: rgba(240,200,80,0.12); }

.replay-range {
  width: 100%;
  margin: 8px 0 6px;
}
.replay-meta {
  font-size: 0.88rem;
  opacity: 0.9;
  text-align: center;
  margin-top: -6px;
}
.replay-footer {
  display: flex;
  gap: 10px;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  margin-top: 10px;
}
.replay-footer label { font-size: 0.9rem; opacity: 0.95; }
.replay-footer select {
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(240,200,80,0.25);
  color: var(--text-main);
  border-radius: 10px;
  padding: 6px 10px;
}

/* Winner overlay extra buttons */
.replay-button.secondary {
  font-size: 0.55em;
  padding: 0.5em 1.2em;
  opacity: 0.92;
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .stone.hint-piece { animation: none; }
  .toast { transition: none; }
}

/* =====================================================================
   LANGUAGE SPLASH SCREEN
   ===================================================================== */
#lang-splash {
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: linear-gradient(145deg, #1e1710, #2c2218, #1a140e);
  padding: clamp(1.2rem, 5vw, 3rem);
  animation: splashFadeIn 0.5s ease;
  overflow: hidden;
}
#lang-splash::before {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="none" stroke="%234a3d35" stroke-width="2" opacity="0.12"/></svg>');
  background-size: 80px;
  pointer-events: none;
}
#lang-splash.hidden {
  animation: splashFadeOut 0.45s ease forwards;
  pointer-events: none;
}
@keyframes splashFadeIn {
  from { opacity: 0; transform: scale(1.04); }
  to   { opacity: 1; transform: scale(1); }
}
@keyframes splashFadeOut {
  from { opacity: 1; transform: scale(1); }
  to   { opacity: 0; transform: scale(0.97); }
}
.splash-logo {
  font-family: var(--font-title);
  font-size: clamp(2.6rem, 9vw, 5rem);
  font-weight: 800;
  color: var(--text-gold);
  letter-spacing: .22em;
  text-shadow: 0 4px 20px rgba(240,200,80,.35), 3px 3px 8px rgba(0,0,0,.7);
  text-transform: uppercase;
  line-height: 1;
  text-align: center;
}
.splash-tifinagh {
  font-size: clamp(1rem, 3vw, 1.4rem);
  letter-spacing: .5em;
  color: var(--text-gold);
  opacity: .55;
  margin-top: .35em;
  margin-bottom: 2.5rem;
  text-align: center;
}
.splash-divider {
  width: min(220px, 60vw);
  height: 1px;
  background: linear-gradient(90deg, transparent, rgba(240,200,80,.65), transparent);
  margin-bottom: 1.8rem;
}
.splash-prompt {
  font-size: clamp(.9rem, 2.5vw, 1.1rem);
  color: rgba(245,245,245,.6);
  margin-bottom: 1.8rem;
  text-align: center;
  letter-spacing: .05em;
}
.splash-langs {
  display: flex;
  gap: clamp(.8rem, 3vw, 2rem);
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 580px;
}
.splash-lang-btn {
  flex: 1;
  min-width: min(200px, 38vw);
  max-width: 260px;
  padding: clamp(1rem, 4vw, 1.8rem) clamp(.8rem, 3vw, 1.4rem);
  background: rgba(0,0,0,.4);
  border: 2px solid rgba(240,200,80,.35);
  border-radius: 20px;
  cursor: pointer;
  transition: all .28s cubic-bezier(.2,.9,.2,1);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: .7rem;
  backdrop-filter: blur(8px);
  box-shadow: 0 8px 24px rgba(0,0,0,.4);
  color: var(--text-main);
  font-family: var(--font-ui);
  text-align: center;
}
.splash-lang-btn:hover {
  border-color: var(--text-gold);
  background: rgba(240,200,80,.12);
  transform: translateY(-6px) scale(1.03);
  box-shadow: 0 16px 40px rgba(0,0,0,.5), 0 0 30px rgba(240,200,80,.35);
}
.splash-lang-btn:active { transform: translateY(-2px) scale(1.01); }
.splash-lang-flag {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: clamp(3.1rem, 8vw, 3.6rem);
  height: clamp(3.1rem, 8vw, 3.6rem);
  border-radius: 999px;
  border: 2px solid rgba(240,200,80,.35);
  background: rgba(0,0,0,.22);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  font-size: clamp(1.55rem, 5vw, 2.35rem);
  line-height: 1;
  font-weight: 800;
  letter-spacing: .08em;
}
.splash-lang-name {
  font-size: clamp(1.1rem, 3.5vw, 1.5rem);
  font-weight: 700;
  color: var(--text-gold);
  letter-spacing: .06em;
}
.splash-lang-sub {
  font-size: clamp(.75rem, 2vw, .9rem);
  color: rgba(245,245,245,.55);
  line-height: 1.4;
}
.splash-footer {
  position: absolute;
  bottom: 1.2rem;
  font-size: .75rem;
  color: rgba(245,245,245,.22);
  letter-spacing: .08em;
  text-align: center;
}
</style><style nonce="tiddas">
/* =========================================================
   TIDDAS v9.2 – Cleanup patch (auto-generated)
   - Fix invalid min()/vh arithmetic
   - Improve mobile viewport handling (dvh)
   - Reduce theme conflicts by making components rely on CSS vars
   ========================================================= */

/* Make viewport height stable on mobile browsers */
:root { --app-dvh: 100vh; }
@supports (height: 100dvh) {
  :root { --app-dvh: 100dvh; }
}

/* Normalize the main container sizing */
:root[data-theme] body { min-height: var(--app-dvh); }

/* Ensure board sizing stays valid everywhere (desktop + mobile) */
:root[data-theme] .game-board-container{
  width: min(95vw, calc(95vh - 10rem), 600px);
  width: min(95vw, calc(95dvh - 10rem), 600px);
}

/* Components should be driven by vars; give them a consistent baseline */
:root[data-theme] .selection-area,
:root[data-theme] .player-setup-area,
:root[data-theme] .game-play-area,
:root[data-theme] .move-history-panel,
:root[data-theme] .version-card,
:root[data-theme] .mode-card,
:root[data-theme] .difficulty-card{
  background: var(--panel-bg, rgba(255,255,255,0.92));
  border: 1px solid var(--panel-border, rgba(0,0,0,0.18));
}

/* Respect safe areas on modern phones */
:root[data-theme] .toolbar-buttons{
  padding-bottom: env(safe-area-inset-bottom);
}
</style>
<style nonce="tiddas">
/* ═══════════════════════════════════════════════════════════════════
   TIDDAS — PATCH GLOBAL : REPLAY FLOTTANT + VISIBILITÉ THÈMES
   ═══════════════════════════════════════════════════════════════════ */

/* ────────────────────────────────────────────────────────────────
   1. TOKENS UNIVERSELS PAR THÈME (modale + stat-cards)
   ──────────────────────────────────────────────────────────────── */
:root {
  /* Thème sombre par défaut */
  --modal-surface:       linear-gradient(160deg, #3a2d25 0%, #2a201a 100%);
  --modal-text:          rgba(245,245,245,0.94);
  --modal-subtext:       rgba(245,245,245,0.68);
  --modal-heading:       #f0c850;
  --modal-border:        rgba(240,200,80,0.45);

  --stat-surface:        rgba(255,255,255,0.07);
  --stat-border-c:       rgba(240,200,80,0.18);
  --stat-label:          rgba(245,235,200,0.70);
  --stat-value:          #f0c850;
  --stat-misc-text:      rgba(245,235,200,0.82);
}

[data-theme="nuit"] {
  --modal-surface:       linear-gradient(160deg, #0e0b22 0%, #08061a 100%);
  --modal-text:          rgba(240,234,255,0.94);
  --modal-subtext:       rgba(240,234,255,0.60);
  --modal-heading:       #bb86fc;
  --modal-border:        rgba(187,134,252,0.38);
  --stat-surface:        rgba(187,134,252,0.10);
  --stat-border-c:       rgba(187,134,252,0.20);
  --stat-label:          rgba(240,234,255,0.58);
  --stat-value:          #bb86fc;
  --stat-misc-text:      rgba(240,234,255,0.78);
}

[data-theme="glass"] {
  --modal-surface:       linear-gradient(160deg, rgba(30,15,60,0.88), rgba(15,8,40,0.92));
  --modal-text:          rgba(240,234,255,0.96);
  --modal-subtext:       rgba(240,234,255,0.62);
  --modal-heading:       #e8b4f8;
  --modal-border:        rgba(232,180,248,0.38);
  --stat-surface:        rgba(255,255,255,0.08);
  --stat-border-c:       rgba(232,180,248,0.20);
  --stat-label:          rgba(240,234,255,0.58);
  --stat-value:          #e8b4f8;
  --stat-misc-text:      rgba(240,234,255,0.78);
}

[data-theme="desert"] {
  --modal-surface:       linear-gradient(160deg, #fffbf0 0%, #fff3d8 100%);
  --modal-text:          #2a1e0a;
  --modal-subtext:       #6a5540;
  --modal-heading:       #8a4500;
  --modal-border:        rgba(122,58,10,0.28);
  --stat-surface:        rgba(122,58,10,0.07);
  --stat-border-c:       rgba(122,58,10,0.14);
  --stat-label:          #7a6050;
  --stat-value:          #8a4500;
  --stat-misc-text:      #5a4030;
}

[data-theme="kabylie"] {
  --modal-surface:       linear-gradient(160deg, #ffffff 0%, #f4f8ff 100%);
  --modal-text:          #1a1612;
  --modal-subtext:       #4a4a5a;
  --modal-heading:       #1565c0;
  --modal-border:        rgba(21,101,192,0.25);
  --stat-surface:        rgba(30,136,229,0.06);
  --stat-border-c:       rgba(30,136,229,0.14);
  --stat-label:          #5a5a6e;
  --stat-value:          #1565c0;
  --stat-misc-text:      #3a3a4a;
}

[data-theme="modern"] {
  --modal-surface:       #ffffff;
  --modal-text:          #0f172a;
  --modal-subtext:       #475569;
  --modal-heading:       #2563eb;
  --modal-border:        rgba(15,23,42,0.10);
  --stat-surface:        rgba(37,99,235,0.06);
  --stat-border-c:       rgba(37,99,235,0.13);
  --stat-label:          #64748b;
  --stat-value:          #2563eb;
  --stat-misc-text:      #334155;
}

[data-theme="modern-dark"] {
  --modal-surface:       #0d1526;
  --modal-text:          rgba(232,240,254,0.96);
  --modal-subtext:       rgba(229,231,235,0.64);
  --modal-heading:       #38bdf8;
  --modal-border:        rgba(148,163,184,0.18);
  --stat-surface:        rgba(14,165,233,0.10);
  --stat-border-c:       rgba(14,165,233,0.18);
  --stat-label:          rgba(229,231,235,0.58);
  --stat-value:          #38bdf8;
  --stat-misc-text:      rgba(229,231,235,0.78);
}

/* ────────────────────────────────────────────────────────────────
   2. MODALES — Fond, texte, titres universels
   ──────────────────────────────────────────────────────────────── */
.modal-content {
  background: var(--modal-surface) !important;
  color: var(--modal-text) !important;
  border-color: var(--modal-border) !important;
}
.modal-content h3 {
  color: var(--modal-heading) !important;
  text-shadow: none !important;
}
.modal-content p,
.modal-content label,
.modal-content span:not(.icon):not([class*="lang"]) {
  color: inherit;
}

/* ────────────────────────────────────────────────────────────────
   3. STATS — stat-card, .k, .v universellement lisibles
   ──────────────────────────────────────────────────────────────── */
.stat-card {
  background: var(--stat-surface) !important;
  border: 1px solid var(--stat-border-c) !important;
  border-radius: 12px;
  padding: 10px 14px;
  color: var(--modal-text) !important;
}
.stat-card .k {
  font-size: 0.76rem !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.55px !important;
  color: var(--stat-label) !important;
  opacity: 1 !important;
}
.stat-card .v {
  font-size: 1.18rem !important;
  font-weight: 800 !important;
  color: var(--stat-value) !important;
  margin-top: 5px;
}
/* Textes libres dans stat-card (dates, etc.) */
#stats-content div[style*="font-size"] {
  color: var(--stat-misc-text) !important;
}
#stats-content strong {
  color: var(--stat-value) !important;
}
/* Barre de progression */
.progress-bar {
  background: var(--stat-border-c) !important;
  border-color: transparent !important;
}
.progress-bar > div {
  background: linear-gradient(90deg, var(--stat-value), var(--modal-heading)) !important;
}

/* Stats modal scroll */
.stats-modal-content { overflow-y: auto; max-height: 85vh; }

/* ────────────────────────────────────────────────────────────────
   4. REPLAY — PANNEAU FLOTTANT (le plateau reste visible)
   ──────────────────────────────────────────────────────────────── */
#replay-modal {
  /* Écrase le comportement overlay plein écran */
  position: fixed !important;
  top: auto !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  width: 100% !important;
  height: auto !important;
  /* Pas de fond sombre */
  background: transparent !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  /* Centrage du panneau */
  display: none;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: flex-end !important;
  padding: 0 0.75rem 0.75rem !important;
  z-index: 6000;
  pointer-events: none;
}
#replay-modal.active {
  display: flex !important;
  pointer-events: auto;
}

/* Le panneau lui-même */
.replay-modal-content {
  width: 100%;
  max-width: 580px;
  /* Fond opaque avec backdrop blur fort pour lisibilité */
  background: var(--modal-surface) !important;
  color: var(--modal-text) !important;
  border: 1.5px solid var(--modal-border) !important;
  border-radius: 20px 20px 14px 14px !important;
  padding: 1rem 1.2rem 0.9rem !important;
  box-shadow:
    0 -6px 40px rgba(0,0,0,0.38),
    0 -1px 12px rgba(0,0,0,0.20),
    0 4px 16px rgba(0,0,0,0.18) !important;
  backdrop-filter: blur(22px) saturate(1.4) !important;
  -webkit-backdrop-filter: blur(22px) saturate(1.4) !important;
}

/* Titre du panneau replay */
.replay-modal-content h3 {
  font-size: 0.95rem !important;
  font-weight: 700 !important;
  color: var(--modal-heading) !important;
  text-align: center;
  margin-bottom: 0.5rem !important;
  letter-spacing: 0.3px;
}

/* Méta (variante · mode · joueurs) */
.replay-meta {
  font-size: 0.78rem !important;
  text-align: center;
  color: var(--modal-subtext) !important;
  margin: 0 0 0.55rem !important;
  line-height: 1.4;
  font-weight: 500;
}

/* Slider de timeline */
.replay-range {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 5px;
  border-radius: 999px;
  background: var(--stat-border-c) !important;
  outline: none;
  margin: 0 0 0.45rem !important;
  cursor: pointer;
  accent-color: var(--modal-heading);
}
.replay-range::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--modal-heading);
  border: 2px solid rgba(255,255,255,0.65);
  box-shadow: 0 1px 6px rgba(0,0,0,0.28);
  cursor: pointer;
  transition: transform 0.14s;
}
.replay-range::-webkit-slider-thumb:hover { transform: scale(1.25); }
.replay-range::-moz-range-thumb {
  width: 16px; height: 16px; border-radius: 50%;
  background: var(--modal-heading);
  border: 2px solid rgba(255,255,255,0.65);
  box-shadow: 0 1px 6px rgba(0,0,0,0.28);
}

/* Indicateur tour courant */
.replay-step-indicator {
  text-align: center;
  font-size: 0.72rem;
  font-weight: 600;
  color: var(--modal-subtext) !important;
  margin: -2px 0 0.5rem;
  font-variant-numeric: tabular-nums;
}

/* Boutons de contrôle */
.replay-controls {
  display: flex !important;
  gap: 5px !important;
  justify-content: center !important;
  align-items: stretch !important;
  flex-wrap: nowrap !important;
  margin: 0 0 0.6rem !important;
}
.replay-controls button {
  all: unset;
  flex: 1;
  min-width: 38px;
  max-width: 58px;
  padding: 0.55rem 0.4rem;
  border-radius: 10px;
  border: 1.5px solid var(--modal-border) !important;
  background: var(--stat-surface) !important;
  color: var(--modal-text) !important;
  font-size: 1.05rem;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.16s, transform 0.12s, box-shadow 0.12s;
  box-shadow: none !important;
  text-shadow: none !important;
}
.replay-controls button:hover {
  background: var(--stat-border-c) !important;
  transform: translateY(-2px);
  box-shadow: 0 3px 10px rgba(0,0,0,0.18) !important;
}
.replay-controls button:active { transform: translateY(0); }

/* Bouton Play : mis en valeur */
#replay-play-btn {
  background: color-mix(in srgb, var(--modal-heading) 20%, transparent) !important;
  border-color: color-mix(in srgb, var(--modal-heading) 55%, transparent) !important;
  flex: 1.5 !important;
  max-width: 70px !important;
  font-size: 1.15rem !important;
}
#replay-play-btn:hover {
  background: color-mix(in srgb, var(--modal-heading) 35%, transparent) !important;
}

/* Fallback pour les navigateurs sans color-mix */
@supports not (color: color-mix(in srgb, red 50%, blue)) {
  #replay-play-btn {
    background: var(--stat-surface) !important;
    border-color: var(--modal-heading) !important;
  }
}

/* Footer : vitesse + fermer */
.replay-footer {
  display: flex !important;
  align-items: center !important;
  justify-content: space-between !important;
  gap: 8px !important;
  flex-wrap: wrap !important;
  margin: 0 !important;
  padding-top: 0.55rem !important;
  border-top: 1px solid var(--modal-border) !important;
}
.replay-footer label {
  display: flex;
  align-items: center;
  gap: 7px;
  font-size: 0.82rem !important;
  font-weight: 500;
  color: var(--modal-subtext) !important;
  opacity: 1 !important;
}
.replay-footer select {
  all: unset;
  background: var(--stat-surface) !important;
  border: 1.5px solid var(--modal-border) !important;
  color: var(--modal-text) !important;
  border-radius: 9px;
  padding: 5px 28px 5px 9px;
  font-size: 0.82rem;
  font-weight: 600;
  cursor: pointer;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='7' viewBox='0 0 10 7'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%23888' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 8px center;
  transition: border-color 0.15s;
  -webkit-appearance: none;
  appearance: none;
}
.replay-footer select option {
  background: var(--modal-surface, #2a201a);
  color: var(--modal-text, #f5f5f5);
}
.replay-footer select:hover { border-color: var(--modal-heading) !important; }

/* Bouton Fermer du replay */
#replay-exit-btn {
  all: unset;
  padding: 0.45rem 1rem !important;
  border-radius: 9px !important;
  border: 1.5px solid var(--modal-border) !important;
  background: var(--stat-surface) !important;
  color: var(--modal-text) !important;
  font-size: 0.82rem !important;
  font-weight: 600 !important;
  cursor: pointer !important;
  transition: background 0.15s, transform 0.12s !important;
}
#replay-exit-btn:hover {
  background: var(--stat-border-c) !important;
  transform: translateY(-1px);
}

/* Indicateur de lecture sur le plateau (bande translucide) */
.replay-board-indicator {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--modal-heading);
  opacity: 0.7;
  z-index: 5999;
  display: none;
  transform-origin: left;
  animation: replayBarPulse 1.8s ease-in-out infinite;
}
#replay-modal.active ~ .replay-board-indicator,
body.replay-active .replay-board-indicator { display: block; }

@keyframes replayBarPulse {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 0.9; }
}

/* Badge "REPLAY" flottant sur le plateau */
.replay-badge {
  position: fixed;
  top: 0.6rem;
  left: 50%;
  transform: translateX(-50%);
  background: var(--modal-heading);
  color: var(--modal-surface, #1a1a1a);
  font-size: 0.7rem;
  font-weight: 800;
  letter-spacing: 0.12em;
  padding: 3px 12px;
  border-radius: 999px;
  z-index: 5998;
  display: none;
  box-shadow: 0 2px 12px rgba(0,0,0,0.3);
  text-transform: uppercase;
  pointer-events: none;
}
body.replay-active .replay-badge { display: block; }

/* ────────────────────────────────────────────────────────────────
   5. WINNER OVERLAY — masqué pendant le replay
   ──────────────────────────────────────────────────────────────── */
body.replay-active .winner-overlay.active {
  opacity: 0 !important;
  pointer-events: none !important;
  transition: opacity 0.3s ease !important;
}

/* ────────────────────────────────────────────────────────────────
   6. BOUTONS MODAL-ACTIONS — force lisibilité
   ──────────────────────────────────────────────────────────────── */
.modal-actions button {
  background: var(--stat-surface) !important;
  border: 1.5px solid var(--modal-border) !important;
  color: var(--modal-text) !important;
  border-radius: 12px !important;
  padding: 0.6rem 1.4rem !important;
  font-size: 0.9rem !important;
  font-weight: 600 !important;
  cursor: pointer !important;
  transition: background 0.16s, transform 0.12s !important;
  box-shadow: none !important;
  text-shadow: none !important;
}
.modal-actions button:hover {
  background: var(--stat-border-c) !important;
  transform: translateY(-1px) !important;
}

/* ────────────────────────────────────────────────────────────────
   7. LABEL + SELECT DANS TOUTES MODALES
   ──────────────────────────────────────────────────────────────── */
.modal-content label {
  color: var(--modal-subtext) !important;
  font-size: 0.88rem;
}

/* ────────────────────────────────────────────────────────────────
   8. PION BLOQUÉ (même pion 3× de suite)
      Croix rouge en overlay + animation de pulsation
   ──────────────────────────────────────────────────────────────── */

/* La cellule hôte du pion bloqué */
.consecutive-blocked-cell {
  cursor: not-allowed !important;
}

/* Le pion bloqué lui-même */
.stone.consecutive-blocked {
  /* Filtre visuel : désaturé + teinte rouge */
  filter: grayscale(55%) sepia(0.6) saturate(2.5) hue-rotate(300deg) brightness(0.82) !important;
  /* Bordure rouge pulsée */
  outline: 3px solid rgba(255, 60, 60, 0.90) !important;
  outline-offset: 2px !important;
  border-radius: 50% !important;
  animation: blockedPulse 1.4s ease-in-out infinite !important;
  cursor: not-allowed !important;
  position: relative;
}

/* Pseudo-élément : croix ✕ en overlay sur le pion */
.consecutive-blocked-cell::after {
  content: '✕';
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(0.85rem, 2.8vw, 1.1rem);
  font-weight: 900;
  color: rgba(255, 60, 60, 0.92);
  text-shadow: 0 0 6px rgba(0,0,0,0.7);
  pointer-events: none;
  z-index: 10;
  line-height: 1;
}

/* Animation de pulsation rouge */
@keyframes blockedPulse {
  0%, 100% {
    outline-color: rgba(255, 60, 60, 0.85);
    box-shadow: 0 0 0 0 rgba(255, 60, 60, 0);
  }
  50% {
    outline-color: rgba(255, 60, 60, 1);
    box-shadow: 0 0 0 5px rgba(255, 60, 60, 0.22);
  }
}

/* Adaptation thème Kabylie / Desert / Modern (clairs) */
[data-theme="kabylie"] .stone.consecutive-blocked,
[data-theme="desert"] .stone.consecutive-blocked,
[data-theme="modern"] .stone.consecutive-blocked {
  outline-color: rgba(200, 20, 20, 0.90) !important;
}
[data-theme="kabylie"] .consecutive-blocked-cell::after,
[data-theme="desert"] .consecutive-blocked-cell::after,
[data-theme="modern"] .consecutive-blocked-cell::after {
  color: rgba(200, 20, 20, 0.95);
}
</style>
</head>
<body>
<!-- ===== LANGUAGE SPLASH SCREEN ===== -->
<div aria-label="Choix de la langue / Tifert n tutlayt" aria-modal="true" id="lang-splash" role="dialog">
<div class="splash-logo">TIDDAS</div>
<div class="splash-tifinagh">ⵜⵉⴷⴷⴰⵙ</div>
<div class="splash-divider"></div>
<p class="splash-prompt">Choisissez votre langue  /  Fren tutlayt-ik</p>
<div class="splash-langs">
<button aria-label="Français" class="splash-lang-btn" data-lang="fr">
<span class="splash-lang-flag">FR</span>
<span class="splash-lang-name">Français</span>
<span class="splash-lang-sub">Jouer en français</span>
</button>
<button aria-label="Taqbaylit" class="splash-lang-btn" data-lang="kab">
<span class="splash-lang-flag">ⵣ</span>
<span class="splash-lang-name">Taqbaylit</span>
<span class="splash-lang-sub">Urar s taqbaylit</span>
</button>
</div>
<p class="splash-footer">Patrimoine Amazigh • Adles Amaziɣ</p>
</div>
<div class="toolbar-buttons" id="toolbar-buttons">
<div class="settings-tray" id="settings-tray">
<button aria-label="Thème" class="toolbar-btn" id="theme-btn" title="Changer de thème">🎨 <span data-i18n="btnTheme" style="font-size:0.78rem;">Thème</span></button>
<button aria-label="Son" class="toolbar-btn" id="sound-btn" title="Son On/Off">🔊 <span data-i18n="btnSound" style="font-size:0.78rem;">Son</span></button>
<button aria-label="Installer" class="toolbar-btn" id="install-btn" title="Installer l'application">
                ⬇️ <span data-i18n="installApp" style="font-size:0.78rem;">Installer</span>
</button>
<button aria-label="Stats" class="toolbar-btn" id="stats-btn" title="Statistiques">
                📈 <span data-i18n="stats" style="font-size:0.78rem;">Stats</span>
</button>
<button aria-label="Mode guidé" aria-pressed="true" class="toolbar-btn" id="guided-btn" title="Mode guidé">
                🧭 <span data-i18n="guidedMode" style="font-size:0.78rem;">Guidé</span>
</button>
<button aria-label="Replay" class="toolbar-btn" disabled="" id="replay-btn" title="Revoir la dernière partie">
                ⏯️ <span data-i18n="replayLast" style="font-size:0.78rem;">Replay</span>
</button>
<div class="language-selector">
<span aria-hidden="true" class="icon">🗣️</span>
<select aria-label="Langue / Tutlayt" id="language-select">
<option value="fr">Français</option>
<option value="kab">ⵣ Taqbaylit</option>
</select>
</div>
</div>
<button aria-label="Paramètres" id="settings-fab" title="Paramètres"><span aria-hidden="true" class="settings-icon">⚙️</span><span class="settings-label" data-i18n="btnSettings">Paramètres</span></button>
</div>
<div class="stone-decoration stone-1">ⵣ</div>
<div class="stone-decoration stone-2">ⵣ</div>
<div class="stone-decoration stone-3">ⵣ</div>
<div class="stone-decoration stone-4">ⵣ</div>
<header id="main-header">
<h1 data-i18n="appTitle">TIDDAS</h1>
</header>
<div class="game-container">
<div class="selection-area active" id="version-selection-area">
<h2 data-i18n="chooseVersion">Choisir la version du jeu :</h2>
<div class="version-grid">
<div class="version-card" data-variant="TIDDEST-no-diag">
<h3 data-i18n="TIDDESTTitle">TIDDEST</h3>
<p data-i18n="TIDDESTDesc">Pas de capture pendant le placement. Interdiction d'aligner 3 pions pendant le placement. Déplacements et captures uniquement horizontaux/verticaux. Victoire normale.</p>
</div>
<div class="version-card" data-variant="bessif-TIDDEST">
<h3 data-i18n="bessifTitle">Učči bessif TIDDEST</h3>
<p data-i18n="bessifDesc">Mêmes règles que TIDDEST. Victoire inversée: gagnez en perdant tous vos pions. Quand vous formez un moulin, votre adversaire choisit un de ses pions à capturer.</p>
</div>
</div>
<button class="rules-btn" id="show-rules-btn">
<span aria-hidden="true" class="icon">📖</span>
<span data-i18n="gameRulesTitle">Règles du jeu</span>
</button>
</div>
<div class="selection-area" id="mode-selection-area">
<h2 data-i18n="howToPlay">Comment souhaitez-vous jouer ?</h2>
<div class="options-group">
<button class="option-btn" disabled="" id="play-online-btn">
<span aria-hidden="true" class="icon">🌐</span>
<span data-i18n="playOnline">Jouer en ligne</span>
<span data-i18n="playOnlineDesc">Bientôt disponible</span>
</button>
<button class="option-btn" id="play-ai-btn">
<span aria-hidden="true" class="icon">🤖</span>
<span data-i18n="playAI">Jouer contre l'ordinateur</span>
<span data-i18n="playAIDesc">Affrontez une intelligence artificielle</span>
</button>
<button class="option-btn" id="play-offline-btn">
<span aria-hidden="true" class="icon">👥</span>
<span data-i18n="playOffline">Jouer hors-ligne</span>
<span data-i18n="playOfflineDesc">Partie locale sur votre appareil</span>
</button>
<button class="option-btn" id="play-spectator-btn">
<span aria-hidden="true" class="icon">👁️</span>
<span data-i18n="playSpectator">Mode Spectateur</span>
<span data-i18n="playSpectatorDesc">Regardez deux IA s'affronter</span>
</button>
</div>
<button class="back-btn" data-i18n="backToVersions" id="back-to-versions-btn">Retour aux versions</button>
</div>
<div class="selection-area" id="ai-difficulty-selection-area">
<h2 data-i18n="chooseAIDifficulty">Choisir la difficulté de l'ordinateur</h2>
<div class="options-group">
<button class="option-btn difficulty-btn" data-level="1">
<span aria-hidden="true" class="icon">🙂</span>
<span data-i18n="difficultyEasy">Facile</span>
<span data-i18n="difficultyEasyDesc">L'ordinateur joue au hasard</span>
</button>
<button class="option-btn difficulty-btn" data-level="2">
<span aria-hidden="true" class="icon">😐</span>
<span data-i18n="difficultyMedium">Moyen</span>
<span data-i18n="difficultyMediumDesc">L'ordinateur est un adversaire correct</span>
</button>
<button class="option-btn difficulty-btn" data-level="3">
<span aria-hidden="true" class="icon">😬</span>
<span data-i18n="difficultyHard">Difficile</span>
<span data-i18n="difficultyHardDesc">L'ordinateur est un vrai stratège</span>
</button>
<button class="option-btn difficulty-btn" data-level="4">
<span aria-hidden="true" class="icon">☠️</span>
<span data-i18n="difficultyImpossible">Expert</span>
<span data-i18n="difficultyImpossibleDesc">L'IA anticipe vos moindres faits et gestes</span>
</button>
</div>
<button class="back-btn" data-i18n="backToModes" id="back-to-modes-btn">Retour aux modes</button>
</div>
<div class="selection-area player-setup-area" id="player-setup-area">
<h2 data-i18n="playerSetup">Configuration des joueurs</h2>
<div class="setup-section" id="player-naming-section">
<h3 data-i18n="playerNamesTitle">Noms des joueurs</h3>
<div class="input-group">
<label data-i18n="player1NameLabel" for="player1-name-input" id="player1-name-label">Nom du Joueur 1 (Noir) :</label>
<input data-i18n-placeholder="yourNamePlaceholder" id="player1-name-input" placeholder="Votre Nom" type="text"/>
</div>
<div class="input-group" id="player2-name-group">
<label data-i18n="player2NameLabel" for="player2-name-input">Nom du Joueur 2 (Blanc) :</label>
<input data-i18n-placeholder="player2Placeholder" id="player2-name-input" placeholder="Joueur 2" type="text"/>
</div>
</div>
<div class="setup-section" id="color-choice-section">
<h3 data-i18n="chooseYourColorTitle">Choisir votre couleur</h3>
<div class="color-choice-group">
<label class="color-option" data-player="1">
<input checked="" name="human-color" type="radio" value="1"/>
<div class="stone-preview player1"></div>
<span data-i18n="player1Color" id="color-option-1-text">Noir (Joueur 1)</span>
<div class="checkmark"><span aria-hidden="true" class="icon">✅</span></div>
</label>
<label class="color-option" data-player="2">
<input name="human-color" type="radio" value="2"/>
<div class="stone-preview player2"></div>
<span data-i18n="player2Color" id="color-option-2-text">Blanc (Joueur 2)</span>
<div class="checkmark"><span aria-hidden="true" class="icon">✅</span></div>
</label>
</div>
</div>
<button class="start-game-btn" id="start-game-from-setup">
<span aria-hidden="true" class="icon">▶️</span>
<span data-i18n="playButton">Jouer</span>
</button>
<button class="back-btn" data-i18n="backToModes" id="back-to-modes-from-setup-btn">Retour aux modes</button>
</div>
<div class="game-play-area" id="game-play-area">
<div class="player-panel-container player-panel-left">
<div class="player-panel">
<div class="player-info player1-info">
<div class="player-title" id="p1-display-name"></div>
<div class="player-stats">
<div class="player-stat" title="Pions restants">
<span aria-hidden="true" class="icon">💿</span>
<span class="stat-value" id="p1-count">10</span>
</div>
<div class="player-stat" title="Pions capturés">
<span aria-hidden="true" class="icon">👻</span>
<span class="stat-value" id="p1-capt">0</span>
</div>
</div>
</div>
</div>
</div>
<div class="center-column">
<div class="game-info-display">
<span id="game-variant-info"></span>
<span id="game-difficulty-info"></span>
</div>
<div aria-live="polite" class="status" id="status" role="alert"></div>
<div class="game-board-container">
<div class="game-board" id="board"></div>
<div class="ephemeral-message-bubble" id="ephemeral-message-bubble"></div>
</div>
<div class="controls">
<button id="new-game"><span aria-hidden="true" class="icon">🏠</span> <span data-i18n="newGame">Accueil</span></button>
<button id="undo-btn"><span aria-hidden="true" class="icon">↩️</span> <span data-i18n="undoMove">Annuler</span></button>
<button id="restart"><span aria-hidden="true" class="icon">↪️</span> <span data-i18n="restartGame">Recommencer</span></button>
<button class="surrender-btn" id="surrender"><span aria-hidden="true" class="icon">🏳️</span> <span data-i18n="surrender">Abandonner</span></button>
</div>
<div class="spectator-controls" id="spectator-controls">
<span aria-hidden="true" class="icon">👁️</span>
<span data-i18n="spectatorSpeed">Vitesse :</span>
<select id="spectator-speed">
<option data-i18n="speedSlow" value="1200">Lente</option>
<option data-i18n="speedNormal" selected="" value="700">Normale</option>
<option data-i18n="speedFast" value="300">Rapide</option>
</select>
</div>
<div class="move-history-panel" id="move-history-panel">
<div class="move-history-title"><span aria-hidden="true" class="icon">•</span> <span data-i18n="moveHistoryTitle">Historique des coups</span></div>
<div class="move-log-list" id="move-log-list"></div>
</div>
</div>
<div class="player-panel-container player-panel-right">
<div class="player-panel">
<div class="player-info player2-info">
<div class="player-title" id="p2-display-name"></div>
<div class="player-stats">
<div class="player-stat" title="Pions restants">
<span aria-hidden="true" class="icon">💿</span>
<span class="stat-value" id="p2-count">10</span>
</div>
<div class="player-stat" title="Pions capturés">
<span aria-hidden="true" class="icon">👻</span>
<span class="stat-value" id="p2-capt">0</span>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div data-i18n="footerHeritage">Patrimoine Culturel Amazigh • Jeu Traditionnel Kabyle</div>
<div class="creator"><span data-i18n="footerCreator">Créé par</span> Boussad TAMAZIRT</div>
</footer>
<div class="winner-overlay" id="winner-overlay">
<div class="winner-message" data-i18n="congratulations">Félicitations !</div>
<div class="winner-name"></div>
<button class="replay-button" data-i18n="replay" id="winner-replay-button">Rejouer</button>
<button class="replay-button secondary" disabled="" id="winner-replay-last-btn">⏯️ <span data-i18n="replayLast">Replay</span></button>
<button class="replay-button secondary" id="winner-stats-btn">📈 <span data-i18n="stats">Stats</span></button>
</div>
<div class="spectator-badge" data-i18n="spectatorBadgeTxt" id="spectator-badge">👁 Mode Spectateur</div>
<div class="save-notification" id="save-notification">
<span data-i18n="savedGameFound" id="save-notification-text">Partie sauvegardée trouvée. Reprendre ?</span>
<div class="save-btns">
<button class="btn-resume" id="btn-resume">Reprendre</button>
<button class="btn-discard" id="btn-discard">Non</button>
</div>
</div>
<div class="modal-overlay" id="confirmation-modal">
<div class="modal-content">
<h3 id="modal-title"></h3>
<p id="modal-message"></p>
<div class="modal-actions">
<button class="modal-cancel-btn" id="modal-cancel-btn"></button>
<button class="modal-confirm-btn" id="modal-confirm-btn"></button>
</div>
</div>
</div>
<div class="rules-modal-overlay" id="rules-modal">
<div class="rules-book">
<button class="rules-close-btn" id="rules-close-btn" title="Fermer">×</button>
<div class="rules-content" lang="fr">
<h3 data-i18n="gameRulesTitle">Règles du Jeu</h3>
<h4 data-i18n="rulesGeneral">Règles Générales de Tiddas (Communes à toutes les variantes) :</h4>
<div class="rules-section">
<p><strong data-i18n="rulesObjectiveStrong">Objectif :</strong> <span data-i18n="rulesObjective">Le but principal est de réduire le nombre de pions de votre adversaire à moins de trois, ou de le bloquer de manière à ce qu'il ne puisse plus effectuer de mouvements valides. Pour la variante Učči bessif TIDDEST, l'objectif est inversé : le joueur gagne s'il réduit son propre nombre de pions à moins de trois, ou s'il est bloqué et ne peut plus effectuer de mouvements valides.</span></p>
<p><strong data-i18n="rulesPiecesStrong">Pions :</strong> <span data-i18n="rulesPieces">Chaque joueur dispose de 10 pions (appelés "cailloux"). Le Joueur 2 (Blanc) commence toujours.</span></p>
<p><strong data-i18n="rulesPhasesStrong">Phases de Jeu :</strong></p>
<ul>
<li><strong data-i18n="rulesPlacementPhaseStrong">Phase de Placement :</strong> <span data-i18n="rulesPlacementPhase">Les joueurs placent à tour de rôle un de leurs pions sur n'importe quelle case vide du plateau. Cette phase continue jusqu'à ce que les 20 pions (10 pour chaque joueur) soient placés.</span></li>
<li><strong data-i18n="rulesMovePhaseStrong">Phase de Déplacement :</strong> <span data-i18n="rulesMovePhase">Une fois tous les pions placés, les joueurs déplacent à tour de rôle l'un de leurs pions d'une case à la fois vers une case adjacente (horizontalement ou verticalement) qui est vide.</span></li>
</ul>
<p><strong data-i18n="rulesMillStrong">Moulin (Alignement) :</strong> <span data-i18n="rulesMill">Former un alignement de <strong>strictement 3 pions</strong> de sa couleur (horizontalement ou verticalement). <strong>Les alignements en diagonale ne sont pas considérés comme des moulins valides.</strong></span></p>
<p><strong data-i18n="rulesCaptureStrong">Capture :</strong> <span data-i18n="rulesCapture">Lorsqu'un joueur forme un moulin (horizontal ou vertical de 3 pions), il a le droit de "manger" (capturer) un pion adverse.</span></p>
<p><strong data-i18n="rulesCapturePlacementRestrictionStrong">Alignement de 3 interdit pendant le placement :</strong> <span data-i18n="rulesCapturePlacementRestriction">Il est interdit de placer un pion de manière à former un moulin de 3 pions ou plus. Par conséquent, <strong>aucune capture n'est possible pendant la phase de placement</strong>. Les captures sont uniquement possibles en phase de déplacement.</span></p>
<p><strong data-i18n="rulesCaptureAllPiecesStrong">Tous les pions sont capturables :</strong> <span data-i18n="rulesCaptureAllPieces">Dans toutes les variantes de ce jeu, <strong>tous les pions peuvent être capturés</strong>, même s'ils font partie d'un moulin. Il n'y a pas de pions "protégés".</span></p>
<p><strong data-i18n="rulesForcedMoveStrong">Règle de déplacement forcé de moulin :</strong> <span data-i18n="rulesForcedMove">En phase de déplacement, si un joueur a la possibilité de former un moulin avec un de ses pions, il est <strong>obligé</strong> de le faire. Si plusieurs mouvements permettent de former un moulin, le joueur peut choisir l'un d'entre eux.</span></p>
</div>
<h4 data-i18n="rulesDifferences">Différences entre les variantes :</h4>
<div class="rules-section">
<p data-i18n="rulesDifferencesIntro">Les règles de base s'appliquent, mais chaque variante introduit des spécificités importantes :</p>
<p><strong data-i18n="rulesTIDDEST">TIDDEST :</strong></p>
<ul>
<li><strong data-i18n="rulesTIDDESTMovesStrong">Déplacements :</strong> <span data-i18n="rulesTIDDESTMoves">Uniquement horizontaux/verticaux. Les déplacements en diagonale sont interdits.</span></li>
<li><strong data-i18n="rulesTIDDESTCapturesStrong">Captures :</strong> <span data-i18n="rulesTIDDESTCaptures">Le joueur qui forme le moulin choisit quel pion adverse capturer.</span></li>
<li><strong data-i18n="rulesTIDDESTWinStrong">Victoire :</strong> <span data-i18n="rulesTIDDESTWin">Normale.</span></li>
<li><strong data-i18n="rulesTIDDESTNoForcedMoveStrong">Pas de déplacement forcé de moulin :</strong> <span data-i18n="rulesTIDDESTNoForcedMove">La règle du déplacement forcé de moulin ne s'applique pas.</span></li>
</ul>
<p><strong data-i18n="rulesBessif">Učči Bessif :</strong></p>
<ul>
<li><span data-i18n="rulesBessifCombines">Combine les règles de <strong>TIDDEST</strong> avec le principe de <strong>victoire inversée</strong>.</span></li>
<li><strong data-i18n="rulesBessifMovesStrong">Déplacements :</strong> <span data-i18n="rulesBessifMoves">Uniquement horizontaux/verticaux.</span></li>
<li><strong data-i18n="rulesBessifInverseWinStrong">Victoire Inversée :</strong> <span data-i18n="rulesBessifInverseWin">Le joueur gagne si son propre nombre de pions est réduit à moins de trois (c'est-à-dire 0, 1 ou 2 pions), OU si son adversaire est bloqué et qu'il (le joueur qui vient de jouer) a moins de pions sur le plateau que son adversaire.</span></li>
<li><strong data-i18n="rulesBessifOpponentChoosesStrong">Choix du pion à capturer :</strong> <span data-i18n="rulesBessifOpponentChooses">Lorsque vous formez un moulin, c'est votre <strong>adversaire</strong> qui doit choisir l'un de ses propres pions que vous allez capturer.</span></li>
<li><strong data-i18n="rulesBessifForcedMoveStrong">Déplacement forcé pour former un moulin :</strong> <span data-i18n="rulesBessifForcedMove">La règle du déplacement forcé de moulin s'applique.</span></li>
</ul>
</div>
</div>
<div class="rules-content" lang="kab">
<h3 data-i18n="gameRulesTitle">Ilugan n wurar</h3>
<h4 data-i18n="rulesGeneral">Ilugan s amata n Tiddas :</h4>
<div class="rules-section">
<p><strong data-i18n="rulesObjectiveStrong">Iswi :</strong> <span data-i18n="rulesObjective">Iswi amenzu, yal ma yetellet yiwen ileqqafen-is ad yemmečč yiwen uleqqaf n wexṣim, neɣ aḥbas-is iwakken ur izmer ara ad inaqel. Di tewsit n Učči bessif, yerebḥ win i wummi mmeččen ileqqafen-is.</span></p>
<p><strong data-i18n="rulesPiecesStrong">Ileqqafen :</strong> <span data-i18n="rulesPieces">Yal amyurar yesɛa 10 n yileqqafen. Amyurar 2 (Amellal) yettbdu d amezwaru.</span></p>
<p><strong data-i18n="rulesPhasesStrong">Talliyin n wurar :</strong></p>
<ul>
<li><strong data-i18n="rulesPlacementPhaseStrong">Tallit n userrasu :</strong> <span data-i18n="rulesPlacementPhase">Imyuraren srusuyen s nnuba (yiwen/yiwen uleqqaf). Tallit-a tekfa mi rsen i 20 n yileqqafen.</span></li>
<li><strong data-i18n="rulesMovePhaseStrong">Tallit n unaqel :</strong> <span data-i18n="rulesMovePhase">Mi rsen yakk ileqqafen, imyuraren ad bdun ad ttnaqalen ileqqafen ɣer texxamin yexlan yellan ɣer yidis yexlan.</span></li>
</ul>
<p><strong data-i18n="rulesMillStrong">Atellet :</strong> <span data-i18n="rulesMill">Aseddukel n <strong>tlata n yileqqafen</strong> kan n yiwen yini (s teɣzi neɣ s tehri).</span></p>
<p><strong data-i18n="rulesCaptureStrong">Učči :</strong> <span data-i18n="rulesCapture">Ma yesdukel amyurar tlata ileqqafen, yezmer ad yečč aleqqaf n wexṣim-is.</span></p>
<p><strong data-i18n="rulesCapturePlacementRestrictionStrong">Yegdel ad tesdukleḍ 3 deg usersu :</strong> <span data-i18n="rulesCapturePlacementRestriction">Yegdel ad tserseḍ aleqqaf iwakken ad tesdukleḍ tlata. Daymi, ulac Učči deg tallit n usersu. Učči tettili kan deg tallit n unaqel.</span></p>
<p><strong data-i18n="rulesCaptureAllPiecesStrong">Akk ileqqafen zemren ad mmeččen :</strong> <span data-i18n="rulesCaptureAllPieces">Deg yakk tiwsiyin, <strong>akk ileqqafen zemren ad mmeččen</strong>, ula ma llan deg utellet.</span></p>
<p><strong data-i18n="rulesForcedMoveStrong">atellet s tmara:</strong> <span data-i18n="rulesForcedMove">Deg tallit n unaqel, ma yella umyurar yezmer ad itellet, ilaq-as ad t-yexdem. Ma yella aṭas n yiberdan, ad yefren yiwen.</span></p>
</div>
<h4 data-i18n="rulesDifferences">Imgired gar tewsiyin :</h4>
<div class="rules-section">
<p data-i18n="rulesDifferencesIntro">Yal tawsit tesɛa ilugan-is :</p>
<p><strong data-i18n="rulesTIDDEST">TIDDEST :</strong></p>
<ul>
<li><strong data-i18n="rulesTIDDESTMovesStrong">Anaqel :</strong> <span data-i18n="rulesTIDDESTMoves">Kan s teɣzi neɣ s tehri.</span></li>
<li><strong data-i18n="rulesTIDDESTCapturesStrong">Učči :</strong> <span data-i18n="rulesTIDDESTCaptures">Win yesduklen tlata ad yefren aleqqaf n wexṣim-is ara yečč.</span></li>
<li><strong data-i18n="rulesTIDDESTWinStrong">Arbaḥ :</strong> <span data-i18n="rulesTIDDESTWin">yerbeḥ win yeččan.</span></li>
<li><strong data-i18n="rulesTIDDESTNoForcedMoveStrong">Ulac atellet s tmara :</strong> <span data-i18n="rulesTIDDESTNoForcedMove">Alugen n lmakala bessif ur ttilin ara.</span></li>
</ul>
<p><strong data-i18n="rulesBessif">Učči Bessif :</strong></p>
<ul>
<li><span data-i18n="rulesBessifCombines">Tesdukel ilugan n <strong>TIDDEST</strong> d umenzay n <strong>A werbaḥ s wexṣar</strong>.</span></li>
<li><strong data-i18n="rulesBessifMovesStrong">Anaqel :</strong> <span data-i18n="rulesBessifMoves">Kan s teɣzi neɣ s tehri.</span></li>
<li><strong data-i18n="rulesBessifInverseWinStrong">Arbaḥ s wexṣar :</strong> <span data-i18n="rulesBessifInverseWin">Amyurar ad irebḥ ma yella gran-as-d ala sin (2) ileqqafen, NEƔ ma yella axṣim-is ur yezmir ara ad inaqel, u netta (win i d-yuraren) yesɛa drus n yileqqafen.</span></li>
<li><strong data-i18n="rulesBessifOpponentChoosesStrong">Axṣim ad yefren :</strong> <span data-i18n="rulesBessifOpponentChooses">Ma yella tetelteḍ, d <strong>axṣim-ik</strong> ara d-ifernen aleqqaf-is ara teččeḍ.</span></li>
<li><strong data-i18n="rulesBessifForcedMoveStrong">atellet s tmara :</strong> <span data-i18n="rulesBessifForcedMove">Ur d ak d iṣaḥ ara ad tenaqleḍ alqqaf ɣer w anda ur tettellit ara ma yella yezmer.</span></li>
</ul>
</div>
</div>
</div>
</div>
<canvas aria-hidden="true" id="confetti-canvas"></canvas>
<!-- ===== Pack Produit: Stats / Replay / Install UI (single-file) ===== -->
<div aria-atomic="true" aria-live="polite" class="toast" id="toast" role="status"></div>
<div aria-hidden="true" class="modal-overlay app-modal" id="stats-modal">
<div aria-labelledby="stats-modal-title" aria-modal="true" class="modal-content stats-modal-content" role="dialog">
<h3 data-i18n="statsTitle" id="stats-modal-title">Stats &amp; progression</h3>
<div id="stats-content"></div>
<div class="modal-actions">
<button id="stats-reset-btn" type="button"><span data-i18n="resetStats">Réinitialiser</span></button>
<button id="stats-export-btn" type="button"><span data-i18n="exportStats">Exporter</span></button>
<button id="stats-close-btn" type="button"><span data-i18n="close">Fermer</span></button>
</div>
</div>
</div>
<div aria-hidden="true" class="modal-overlay app-modal" id="replay-modal">
<div aria-labelledby="replay-modal-title" aria-modal="true" class="modal-content replay-modal-content" role="dialog">
<h3 data-i18n="replayTitle" id="replay-modal-title">⏯ Replay</h3>
<div class="replay-meta" id="replay-meta"></div>
<input aria-label="Timeline" class="replay-range" id="replay-range" max="0" min="0" step="1" type="range" value="0"/>
<div class="replay-step-indicator" id="replay-step-indicator">— / —</div>
<div aria-label="Contrôles replay" class="replay-controls">
<button aria-label="Début" id="replay-first-btn" title="Début" type="button">⏮</button>
<button aria-label="Précédent" id="replay-prev-btn" title="Coup précédent" type="button">⏪</button>
<button aria-label="Lecture/Pause" id="replay-play-btn" title="Lecture/Pause" type="button">▶️</button>
<button aria-label="Suivant" id="replay-next-btn" title="Coup suivant" type="button">⏩</button>
<button aria-label="Fin" id="replay-last-btn" title="Fin" type="button">⏭</button>
</div>
<div class="replay-footer">
<label>
<span data-i18n="speed">Vitesse</span>
<select id="replay-speed">
<option value="0.5">0.5×</option>
<option selected value="1">1×</option>
<option value="1.5">1.5×</option>
<option value="2">2×</option>
<option value="3">3×</option>
</select>
</label>
<button id="replay-exit-btn" type="button"><span data-i18n="close">✕ Fermer</span></button>
</div>
</div>
</div>
<!-- Badge REPLAY sur le plateau -->
<div class="replay-badge" id="replay-badge">⏯ Replay</div>
<!-- Barre d'état replay en haut -->
<div class="replay-board-indicator" id="replay-board-indicator"></div>
<div aria-hidden="true" class="modal-overlay app-modal" id="install-help-modal">
<div aria-labelledby="install-modal-title" aria-modal="true" class="modal-content install-modal-content" role="dialog">
<h3 data-i18n="installHelpTitle" id="install-modal-title">Installer l'app</h3>
<div id="install-help-content">
<p data-i18n="installHelpBody">
                    Astuce : sur iPhone/iPad, utilisez “Partager” → “Sur l'écran d'accueil”. Sur Android/Chrome, le bouton “Installer” apparaît si l'app est éligible.
                </p>
</div>
<div class="modal-actions">
<button id="install-help-close-btn" type="button"><span data-i18n="close">Fermer</span></button>
</div>
</div>
</div>
<div aria-atomic="false" aria-live="polite" class="debug-overlay" id="debug-overlay" role="status">
<header>
<div class="title">Tiddas • Diagnostic</div>
<div class="actions">
<button aria-label="Effacer les logs" id="debug-clear-btn" type="button">Clear</button>
<button aria-label="Lancer les tests" id="debug-tests-btn" type="button">Tests</button>
<button aria-label="Fermer" id="debug-close-btn" type="button">Close</button>
</div>
</header>
<div class="log" id="debug-log"></div>
</div>
<script nonce="tiddas">
/* ===== TIDDAS - Script consolidé (refactorisé) ===== */

// ============================================================
// Micro-interactions pointer glow (IIFE isolée)
// ============================================================

/* ===== UI micro-interactions (single-file) ===== */
(function(){
  // Pointer position -> CSS variables for sheen/ripple
  const setXY = (el, ev) => {
    const r = el.getBoundingClientRect();
    const x = ((ev.clientX - r.left) / r.width) * 100;
    const y = ((ev.clientY - r.top) / r.height) * 100;
    el.style.setProperty('--mx', x.toFixed(2) + '%');
    el.style.setProperty('--my', y.toFixed(2) + '%');
  };
  // Throttle pointermove updates to one per animation frame (perf on mobile)
  let __tiddasRaf = 0;
  let __tiddasLast = null;
  document.addEventListener('pointermove', (ev) => {
    const t = ev.target;
    if(!(t instanceof Element)) return;
    __tiddasLast = { t, x: ev.clientX, y: ev.clientY };
    if (__tiddasRaf) return;
    __tiddasRaf = requestAnimationFrame(() => {
      __tiddasRaf = 0;
      const last = __tiddasLast;
      if (!last) return;
      const el = last.t.closest && last.t.closest('button, .version-card, .difficulty-card, .mode-card, .option-btn, .toolbar-btn, #settings-fab');
      if (!el) return;
      // call setXY with a minimal event-like object
      setXY(el, { clientX: last.x, clientY: last.y });
    });
  }, {passive:true});

  // Replace any leftover font-awesome tags gracefully
  const map = {
    'fa-globe':'🌐','fa-book-open':'📖','fa-robot':'🤖','fa-users':'👥','fa-eye':'👁️',
    'fa-smile':'🙂','fa-meh':'😐','fa-grimace':'😬','fa-frown':'😟','fa-grin-beam':'😁',
    'fa-mouse-pointer':'👉','fa-exchange-alt':'🔄','fa-skull-crossbones':'☠️','fa-check-circle':'✅',
    'fa-play':'▶️','fa-compact-disc':'💿','fa-ghost':'👻','fa-home':'🏠','fa-undo':'↩️','fa-redo':'↪️','fa-flag':'🏳️'
  };
  document.querySelectorAll('i[class*="fa-"]').forEach(i=>{
    const cls = [...i.classList].find(c=>c.startsWith('fa-'));
    const s = document.createElement('span');
    s.className = 'icon';
    s.setAttribute('aria-hidden','true');
    s.textContent = map[cls] || '•';
    i.replaceWith(s);
  });
})();

// ============================================================
// IIFE principale - tout le jeu dans une portée unique
// ============================================================
(function() {
    'use strict';

    // Helpers DOM rapides
    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
    const safeJSONParse = (s, fb = null) => { try { return JSON.parse(s); } catch(_) { return fb; } };
    const nowMs = () => Date.now();
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));


        // ============================================================
        // === SAFE HTML HELPERS ===
        // ============================================================
        const MAX_NAME_LEN = 24;
        function normalizeName(raw, fallback) {
            const s = String(raw ?? '').replace(/[\u0000-\u001F\u007F]/g, ' ').replace(/\s+/g,' ').trim();
            if (!s) return fallback;
            const clipped = s.slice(0, MAX_NAME_LEN);
            return clipped.replace(/[<>]/g, '');
        }

        const ALLOWED_TAGS = new Set(['STRONG','EM','B','I','BR','SMALL','U','MARK','SUP','SUB','SPAN']);
        function sanitizeHTML(html) {
            const tpl = document.createElement('template');
            tpl.innerHTML = String(html ?? '');
            const walk = (node) => {
                const children = Array.from(node.childNodes);
                for (const child of children) {
                    if (child.nodeType === Node.ELEMENT_NODE) {
                        const tag = child.tagName.toUpperCase();
                        if (!ALLOWED_TAGS.has(tag)) {
                            child.replaceWith(document.createTextNode(child.textContent || ''));
                            continue;
                        }
                        for (const attr of Array.from(child.attributes)) child.removeAttribute(attr.name);
                        walk(child);
                    } else if (child.nodeType === Node.COMMENT_NODE) {
                        child.remove();
                    }
                }
            };
            walk(tpl.content);
            return tpl.innerHTML;
        }

        function setSafeHTML(el, html) {
            if (!el) return;
            el.innerHTML = sanitizeHTML(html);
        }



        // ============================================================
        // === CANVAS CONFETTI (no external dependency) ===
        // ============================================================
        const _confettiCanvas = document.getElementById('confetti-canvas');
        const _ctx2d = _confettiCanvas?.getContext('2d');
        let _confettiRAF = 0;

        (function() {
            function resizeCanvas() {
                if (!_confettiCanvas) return;
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                _confettiCanvas.width = Math.floor(window.innerWidth * dpr);
                _confettiCanvas.height = Math.floor(window.innerHeight * dpr);
                _confettiCanvas.style.width = window.innerWidth + 'px';
                _confettiCanvas.style.height = window.innerHeight + 'px';
                _ctx2d?.setTransform(dpr,0,0,dpr,0,0);
            }
            window.addEventListener('resize', resizeCanvas, { passive: true });
            resizeCanvas();
        })();

        function runConfetti(durationMs = 4500) {
            if (!_confettiCanvas || !_ctx2d) return;
            cancelAnimationFrame(_confettiRAF);
            const start = performance.now();
            const particles = [];
            const colors = ['#f0c850','#ffffff','#00ffff','#ff4d4d','#d0c4b2'];

            const emit = () => {
                const n = 14;
                for (let i=0; i<n; i++) {
                    particles.push({
                        x: Math.random()*window.innerWidth,
                        y: -10,
                        vx: (Math.random()-0.5)*5,
                        vy: Math.random()*3+2,
                        color: colors[Math.floor(Math.random()*colors.length)],
                        r: Math.random()*5+3,
                        life: 1.0,
                        decay: Math.random()*0.008+0.004,
                        spin: (Math.random()-0.5)*0.3
                    });
                }
            };

            const tick = (ts) => {
                const elapsed = ts - start;
                if (elapsed < durationMs) emit();
                _ctx2d.clearRect(0,0,window.innerWidth,window.innerHeight);
                for (let i = particles.length-1; i>=0; i--) {
                    const p = particles[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.07;
                    p.life -= p.decay;
                    if (p.life <= 0 || p.y > window.innerHeight + 60) {
                        particles.splice(i,1); continue;
                    }
                    _ctx2d.save();
                    _ctx2d.globalAlpha = Math.max(0, p.life);
                    _ctx2d.fillStyle = p.color;
                    _ctx2d.translate(p.x, p.y);
                    _ctx2d.rotate(p.spin * elapsed * 0.01);
                    _ctx2d.fillRect(-p.r/2, -p.r/2, p.r, p.r * 1.6);
                    _ctx2d.restore();
                }
                if (particles.length > 0 || elapsed < durationMs) {
                    _confettiRAF = requestAnimationFrame(tick);
                } else {
                    _ctx2d.clearRect(0,0,window.innerWidth,window.innerHeight);
                }
            };
            _confettiRAF = requestAnimationFrame(tick);
        }



        // --- CONSTANTS AND GLOBAL VARIABLES ---
        const SIZE = 5;
        const PIECES = 10;
        
        let state;
        let variant = null;
        let gameMode = null;
        let aiDifficulty = null;
        let currentScreen = 'version-selection-area';
        let moveHistory = []; 
        
        let player1Name = "Joueur 1"; 
        let player2Name = "Joueur 2";
        let humanPlayerId = 1;
        let aiPlayerId = null;
        let currentLanguage = 'fr';
        let onConfirmCallback = null;

        // --- DOM ELEMENTS CACHE ---
        const boardDiv = document.getElementById("board");
        const statusDiv = document.getElementById("status");
        const p1Count = document.getElementById("p1-count");
        const p2Count = document.getElementById("p2-count");
        const p1Capt = document.getElementById("p1-capt");
        const p2Capt = document.getElementById("p2-capt");
        const p1Info = document.querySelector('.player1-info');
        const p2Info = document.querySelector('.player2-info');
        const allScreens = document.querySelectorAll('.selection-area, .game-play-area');
        const versionCards = document.querySelectorAll('.version-card');
        const player1NameInput = document.getElementById('player1-name-input');
        const player2NameInput = document.getElementById('player2-name-input');
        const p1DisplayName = document.getElementById('p1-display-name');
        const p2DisplayName = document.getElementById('p2-display-name');
        const languageSelect = document.getElementById('language-select');
        const ephemeralMessageBubble = document.getElementById('ephemeral-message-bubble');
        const winnerOverlay = document.getElementById('winner-overlay');
        const winnerNameElement = winnerOverlay.querySelector('.winner-name');
        const winnerReplayButton = document.getElementById('winner-replay-button');
        const mainHeader = document.getElementById('main-header');
        const player1NameLabel = document.getElementById('player1-name-label');
        const player2NameGroup = document.getElementById('player2-name-group');
        const colorChoiceSection = document.getElementById('color-choice-section');
        const colorOptions = document.querySelectorAll('.color-option');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const surrenderBtn = document.getElementById('surrender');
        const undoBtn = document.getElementById('undo-btn');
        const rulesModal = document.getElementById('rules-modal');
        const showRulesBtn = document.getElementById('show-rules-btn');
        const rulesCloseBtn = document.getElementById('rules-close-btn');

        // --- VARIANT CONFIGURATION ---
        const variantConfig = {
            "TIDDEST-no-diag": { name: "TIDDEST", isInverseWin: false, forceMillMove: false },
            "bessif-TIDDEST": { name: "Učči bessif TIDDEST", isInverseWin: true, forceMillMove: true }
        };
        const aiDifficultyNames = { 1: "Easy", 2: "Medium", 3: "Hard", 4: "Expert" };

        // --- TRANSLATIONS ---
        const translations = {
            fr: {
                playSpectator: "Mode Spectateur",
  		installApp: "Installer",
                playSpectatorDesc: "Regardez deux IA s'affronter",
                spectatorSpeed: "Vitesse :",
                speedSlow: "Lente",
                speedNormal: "Normale",
                speedFast: "Rapide",
                moveHistoryTitle: "Historique des coups",
                logPlace: "place en",
                logMove: "de",
                logMoveTo: "→",
                logMill: "⚡ Tlata S Ya !",
                logCapture: "💀 Capture en",
                savedGameFound: "Partie sauvegardée trouvée. Reprendre ?",
                themeClassic: "Classique",
                themeDesert: "Désert",
                themeNuit: "Nuit",
                surrender: "Abandonner",
                confirm: "Confirmer",
                cancel: "Annuler",
                defaultPlayer1: "Joueur 1",
                defaultPlayer2: "Joueur 2",
                defaultComputerName: "L'ordinateur",
                defaultHumanName: "Humain",
                appTitle: "Tiddas - Jeu",
                chooseVersion: "Choisir la version du jeu :",
                TIDDESTTitle: "TIDDEST",
                TIDDESTDesc: "Pas de capture pendant le placement. Interdiction d'aligner 3 pions pendant le placement. Déplacements et captures uniquement horizontaux/verticaux. Victoire normale.",
                bessifTitle: "Učči Bessif",
                bessifDesc: "Mêmes règles que TIDDEST. Victoire inversée: gagnez en perdant tous vos pions. Quand vous formez un moulin, votre adversaire choisit un de ses pions à capturer.",
                howToPlay: "Comment souhaitez-vous jouer ?",
                playOnline: "Jouer en ligne",
                playOnlineDesc: "Bientôt disponible",
                playAI: "Jouer contre l'ordinateur",
                playAIDesc: "Affrontez une intelligence artificielle",
                playOffline: "Jouer hors-ligne",
                playOfflineDesc: "Partie locale sur votre appareil",
                backToVersions: "Retour",
                chooseAIDifficulty: "Choisir la difficulté de l'ordinateur",
                difficultyEasy: "Facile",
                difficultyMedium: "Moyen",
                difficultyHard: "Difficile",
                difficultyImpossible: "Expert", 
                difficultyEasyDesc: "L'ordinateur joue au hasard",
                difficultyMediumDesc: "L'ordinateur est un adversaire correct",
                difficultyHardDesc: "L'ordinateur est un vrai stratège",
                difficultyImpossibleDesc: "L'IA anticipe vos moindres faits et gestes",
                backToModes: "Retour",
                playerSetup: "Configuration des joueurs",
                playerNamesTitle: "Noms des joueurs",
                chooseYourColorTitle: "Choisir votre couleur",
                playerHumanName: "Nom de l'Humain :",
                player1NameLabel: "Nom du Joueur 1 (Noir) :",
                player2NameLabel: "Nom du Joueur 2 (Blanc) :",
                yourNamePlaceholder: "Votre Nom",
                player2Placeholder: "Joueur 2",
                yourColor: "Votre couleur",
                aiColor: "Couleur de l'IA",
                player1Color: "Noir (Joueur 1)",
                player2Color: "Blanc (Joueur 2)",
                playButton: "Jouer",
                gameVersion: "Version :",
                aiDifficultyDisplayLabel: "Difficulté IA :",
                ephemeralMill: "Tlata S Ya !",
                ephemeralCaptureNormal: "Awi-d Wa !",
                ephemeralCaptureBessif: "Ddem wa !",
                ephemeralMovePhase: "Tallit n unaqel !",
                newGame: "Accueil",
                restartGame: "Recommencer",
                undoMove: "Annuler",
                gameRulesTitle: "Règles du Jeu",
                rulesGeneral: "Règles Générales de Tiddas (Communes à toutes les variantes) :",
                rulesObjectiveStrong: "Objectif :",
                rulesObjective: "Le but principal est de réduire le nombre de pions de votre adversaire à moins de trois, ou de le bloquer de manière à ce qu'il ne puisse plus effectuer de mouvements valides. Pour la variante Učči bessif TIDDEST, l'objectif est inversé : le joueur gagne s'il réduit son propre nombre de pions à moins de trois, ou s'il est bloqué et ne peut plus effectuer de mouvements valides.",
                rulesPiecesStrong: "Pions :",
                rulesPieces: "Chaque joueur dispose de 10 pions (appelés \"cailloux\"). Le Joueur (Blanc) commence toujours.",
                rulesPhasesStrong: "Phases de Jeu :",
                rulesPlacementPhaseStrong: "Phase de Placement :",
                rulesPlacementPhase: "Les joueurs placent à tour de rôle un de leurs pions sur n'importe quelle case vide du plateau. Cette phase continue jusqu'à ce que les 20 pions (10 pour chaque joueur) soient placés.",
                rulesMovePhaseStrong: "Phase de Déplacement :",
                rulesMovePhase: "Une fois tous les pions placés, les joueurs déplacent à tour de rôle l'un de leurs pions d'une case à la fois vers une case adjacente (horizontalement ou verticalement) qui est vide.",
                rulesMillStrong: "Moulin (Alignement) :",
                rulesMill: "Former un alignement de <strong>strictement 3 pions</strong> de sa couleur (horizontalement ou verticalement). <strong>Les alignements en diagonale ne sont pas considérés comme des moulins valides.</strong>",
                rulesCaptureStrong: "Capture :",
                rulesCapture: "Lorsqu'un joueur forme un moulin (horizontal ou vertical de 3 pions), il a le droit de \"manger\" (capturer) un pion adverse.",
                rulesCapturePlacementRestrictionStrong: "Alignement de 3 interdit pendant le placement :",
                rulesCapturePlacementRestriction: "Il est interdit de placer un pion de manière à former un moulin de 3 pions ou plus. Par conséquent, <strong>aucune capture n'est possible pendant la phase de placement</strong>. Les captures sont uniquement possibles en phase de déplacement.",
                rulesCaptureAllPiecesStrong: "Tous les pions sont capturables :",
                rulesCaptureAllPieces: "Dans toutes les variantes de ce jeu, <strong>tous les pions peuvent être capturés</strong>, même s'ils font partie d'un moulin. Il n'y a pas de pions \"protégés\".",
                rulesForcedMoveStrong: "Règle de déplacement forcé de moulin :",
                rulesForcedMove: "En phase de déplacement, si un joueur a la possibilité de former un moulin avec un de ses pions, il est <strong>obligé</strong> de le faire. Si plusieurs mouvements permettent de former un moulin, le joueur peut choisir l'un d'entre eux.",
                rulesDifferences: "Différences entre les variantes :",
                rulesDifferencesIntro: "Les règles de base s'appliquent, mais chaque variante introduit des spécificités importantes :",
                rulesTIDDEST: "TIDDEST :",
                rulesTIDDESTMovesStrong: "Déplacements :",
                rulesTIDDESTMoves: "Uniquement horizontaux/verticaux. Les déplacements en diagonale sont interdits.",
                rulesTIDDESTCapturesStrong: "Captures :",
                rulesTIDDESTCaptures: "Le joueur qui forme le moulin choisit quel pion adverse capturer.",
                rulesTIDDESTWinStrong: "Victoire :",
                rulesTIDDESTWin: "Normale.",
                rulesTIDDESTNoForcedMoveStrong: "Pas de déplacement forcé de moulin :",
                rulesTIDDESTNoForcedMove: "La règle du déplacement forcé de moulin ne s'applique pas.",
                rulesBessif: "Učči Bessif :",
                rulesBessifCombines: "Combine les règles de <strong>TIDDEST</strong> avec le principe de <strong>victoire inversée</strong>.",
                rulesBessifMovesStrong: "Déplacements :",
                rulesBessifMoves: "Uniquement horizontaux/verticaux.",
                rulesBessifInverseWinStrong: "Victoire Inversée :",
                rulesBessifInverseWin: "Le joueur gagne si son propre nombre de pions est réduit à moins de trois (c'est-à-dire 0, 1 ou 2 pions), OU si son adversaire est bloqué et qu'il (le joueur qui vient de jouer) a moins de pions sur le plateau que son adversaire.",
                rulesBessifOpponentChoosesStrong: "Choix du pion à capturer :",
                rulesBessifOpponentChooses: "Lorsque vous formez un moulin, c'est votre <strong>adversaire</strong> qui doit choisir l'un de ses propres pions que vous allez capturer.",
                rulesBessifForcedMoveStrong: "Déplacement forcé pour former un moulin :",
                rulesBessifForcedMove: "La règle du déplacement forcé de moulin s'applique.",
                footerHeritage: "Patrimoine Culturel Amazigh • Jeu Traditionnel Kabyle",
                footerCreator: "Créé par",
                congratulations: "Félicitations !",
                winnerMessage: "a gagné !",
                replay: "Rejouer",
                statusPlayerTurn: "Au tour de",
                statusChooseCapture: "choisissez un pion de",
                statusToCapture: "à capturer.",
                statusChooseSacrifice: "doit choisir un de ses pions à sacrifier.",
                statusPlacementPhase: "Phase de placement : Au tour de",
                statusMovePhase: "Phase de déplacement : Au tour de",
                statusGameOver: "Fin de partie !",
                statusAlreadyOccupied: "Cette case est déjà occupée !",
                statusNoPiecesToPlace: "Vous n'avez plus de pions à placer !",
                statusPlacementAlignForbidden: "Alignement de 3 interdit pendant le placement !",
                statusYourPiecesTurn: "C'est le tour de vos pions !",
                statusSelectYourPiece: "Veuillez sélectionner un de vos pions.",
                statusInvalidMove: "Mouvement invalide.",
                statusMustMakeMill: "Vous devez faire un moulin si possible !",
                statusChooseOwnPieceToSacrifice: "Vous devez choisir un de VOS pions à sacrifier !",
                statusChooseOpponentPieceToCapture: "Vous devez choisir un pion de l'ADVERSAIRE à capturer !",
                aiCannotMove: "L'ordinateur ne peut pas bouger et perd la partie !",
                statusConsecutiveBlocked: "Ce pion a déjà joué 3 fois de suite ! Jouez un autre pion.",
                youLost: "Vous avez perdu 😭",
                aiWinsMessage: "a gagné !",
                surrenderConfirm: "Êtes-vous sûr de vouloir abandonner ?",
                surrenderMessage: "a abandonné !",

		stats: "Stats",
      statsTitle: "Stats & progression",
      resetStats: "Réinitialiser",
      exportStats: "Exporter",
      close: "Fermer",
      replayTitle: "Replay",
      replayLast: "Replay",
      guidedMode: "Guidé",
      speed: "Vitesse",
      installHelpTitle: "Installer l'app",
      installHelpBody: "Astuce : sur iPhone/iPad, utilisez “Partager” → “Sur l'écran d'accueil”. Sur Android/Chrome, le bouton “Installer” apparaît si l'app est éligible.",
      toastInstalled: "✅ App installée.",
      toastInstallUnavailable: "ℹ️ Installation non disponible sur ce navigateur.",
      toastReplayReady: "⏯️ Replay prêt.",
      toastNoReplay: "Aucune partie à rejouer.",
      toastStatsReset: "Stats réinitialisées.",
      toastExported: "Export généré.",
      toastSWReady: "✅ Mode hors-ligne prêt.",
      toastSWUpdate: "🔄 Mise à jour dispo : rechargez l'app.",
      boardAria: "Plateau de jeu",
      cellLabel: "Case",
      cellEmpty: "vide",
      gamesPlayedLabel: "Parties",
      winsLabel: "Victoires",
      lossesLabel: "Défaites",
      winRateLabel: "Taux de victoire",
      streakLabel: "Série",
      bestStreakLabel: "Meilleure série",
      movesLabel: "Coups",
      capturesLabel: "Captures",
      millsLabel: "Moulins",
      durationLabel: "Durée",
      levelLabel: "Niveau",
      xpLabel: "XP",
      lastGameLabel: "Dernière partie",
      debugTestsRunning: "Tests en cours…",
      debugTestsDone: "Tests terminés",
      btnTheme: "Thème",
      btnSound: "Son",
      btnSettings: "Paramètres",
      themeGlass: "Verre",
      themeContrast: "Contraste",
      themeModern: "Moderne",
      themeModernDark: "Moderne nuit",
      themeKabylie: "Kabylie",
      // Éléments codés en dur qui ne passaient pas par i18n
      spectatorBadgeTxt: "👁 Mode Spectateur",
      btnResume: "Reprendre",
      btnDiscard: "Non",
      ariaRulesClose: "Fermer",
      ariaReplayFirst: "Début",
      ariaReplayPrev: "Précédent",
      ariaReplayPlay: "Lecture/Pause",
      ariaReplayNext: "Suivant",
      ariaReplayLast: "Fin",
      ariaSettingsFab: "Paramètres",
      ariaInstallBtn: "Installer l'application",
      ariaModeGuide: "Mode guidé"
            },
            kab: {
                surrender: "Mayna",
		            installApp: "Areṣṣi",
                playSpectator: "Anezzeh",
                playSpectatorDesc: "Urar n yiselkimen",
                spectatorSpeed: "tazla :",
                speedSlow: "s laɛqel",
                speedNormal: "swaswa kan",
                speedFast: "s uɣiwel",
                moveHistoryTitle: "Ansa i yekka wurar",
                logPlace: "yesres",
                logMove: "seg",
                logMoveTo: "→",
                logMill: "⚡ Tlata S Ya !",
                logCapture: "💀 Učči",
                savedGameFound: "Urar yettwaskles. Ad d-iban?",
                themeClassic: "Aqdim",
                themeDesert: "Agadir",
                themeNuit: "Timeddit",
                themeGlass: "zǧǧaǧ",
                themeContrast: "amgired",
                themeModern: "Amaynut",
                themeModernDark: "Amaynut qessiḥen",
                themeKabylie: "Taqbaylit",
                btnTheme: "Asentel",
                btnSound: "Ṣṣut",
                btnSettings: "Aseggem",
                confirm: "Yahwa-yi",
                cancel: "ALA",
                defaultPlayer1: "Amyurar 1",
                defaultPlayer2: "Amyurar 2",
                defaultComputerName: "Aselkim",
                defaultHumanName: "Amdan",
                appTitle: "Tiddas - Urar",
                chooseVersion: "Fren acu n tiddest ara turareḍ :",
                TIDDESTTitle: "TIDDEST",
                TIDDESTDesc: "Yerbeḥ win yeččan ileqqafen.",
                bessifTitle: "Učči Bessif",
                bessifDesc: "Am ilugan n TIDDEST, maca yerebḥ win i wummi mmeččen ileqqafen.",
                howToPlay: "Amek tebɣiḍ ad turareḍ ?",
                playOnline: "Urar s internet",
                playOnlineDesc: "Ussan-a",
                playAI: "Urar mgal aselkim",
                playAIDesc: "Urar i yiman-ik",
                playOffline: "Urar war internet",
                playOfflineDesc: "Urar d umeddakul",
                backToVersions: "Uɣal",
                chooseAIDifficulty: "Fren aswir n uselkim",
                difficultyEasy: "Aḥlawan",
                difficultyMedium: "Alemmas",
                difficultyHard: "Aquran",
                difficultyImpossible: "Awessar",
                difficultyEasyDesc: "Aselkim yetturar kan akka!",
                difficultyMediumDesc: "Aselkim yetturar swaswa kan",
                difficultyHardDesc: "Aselkim yewɛeṛ ad t-trebḥeḍ",
                difficultyImpossibleDesc: "Aselkim yeẓra ayen ara txedmeḍ",
                backToModes: "Uɣal",
                playerSetup: "Aheggi n yemyurar",
                playerNamesTitle: "Ismawen n yemyurar",
                chooseYourColorTitle: "Fren ini-k",
                playerHumanName: "Isem n umdan :",
                player1NameLabel: "Isem n umyurar 1 (Aberkan) :",
                player2NameLabel: "Isem n umyurar 2 (Amellal) :",
                yourNamePlaceholder: "Isem-ik",
                player2Placeholder: "Amyurar 2",
                yourColor: "Ini-k",
                aiColor: "Ini n uselkim",
                player1Color: "Aberkan (Amyurar 1)",
                player2Color: "Amellal (Amyurar 2)",
                playButton: "Urar",
                gameVersion: "Tawsit:",
                aiDifficultyDisplayLabel: "Aswir:",
                ephemeralMill: "Tlata S Ya !",
                ephemeralCaptureNormal: "Awi-d Wa !",
                ephemeralCaptureBessif: "Ddem wa !",
                ephemeralMovePhase: "Tallit n unaqel !",
                newGame: "Aɣaram",
                restartGame: "Ɛiwed",
                undoMove: "Uɣal",
                gameRulesTitle: "Ilugan n wurar",
                rulesGeneral: "Ilugan s amata n Tiddas :",
                rulesObjectiveStrong: "Iswi :",
                rulesObjective: "Iswi amenzu, yal ma yetellet yiwen ileqqafen-is ad yemmečč yiwen uleqqaf n wexṣim, neɣ aḥbas-is iwakken ur izmer ara ad inaqel. Di tewsit n Učči bessif, yerebḥ win i wummi mmeččen ileqqafen-is.",
                rulesPiecesStrong: "Ileqqafen :",
                rulesPieces: "Yal amyurar yesɛa 10 n yileqqafen. Amyurar ifarnen ileqqafen imellalen i yebeddun urar.",
                rulesPhasesStrong: "Talliyin n wurar :",
                rulesPlacementPhaseStrong: "Tallit n userrasu :",
                rulesPlacementPhase: "Imyuraren srusuyen s nnuba (yiwen/yiwen uleqqaf). Tallit-a tekfa mi rsen i 20 n yileqqafen.",
                rulesMovePhaseStrong: "Tallit n unaqel :",
                rulesMovePhase: "Mi rsen yakk ileqqafen, imyuraren ad bdun ad ttnaqalen ileqqafen ɣer texxamin yexlan yellan ɣer yidis yexlan.",
                rulesMillStrong: "Atellet :",
                rulesMill: "Aseddukel n <strong>tlata n yileqqafen</strong> kan n yiwen yini (s teɣzi neɣ s tehri).",
                rulesCaptureStrong: "Učči :",
                rulesCapture: "Ma yesdukel amyurar tlata ileqqafen, yezmer ad yečč aleqqaf n wexṣim-is.",
                rulesCapturePlacementRestrictionStrong: "Yegdel ad tesdukleḍ 3 deg usersu :",
                rulesCapturePlacementRestriction: "Yegdel ad tserseḍ aleqqaf iwakken ad tesdukleḍ tlata. Daymi, ulac Učči deg tallit n usersu. Učči tettili kan deg tallit n unaqel.",
                rulesCaptureAllPiecesStrong: "Akk ileqqafen zemren ad mmeččen :",
                rulesCaptureAllPieces: "Deg yakk tiwsiyin, <strong>akk ileqqafen zemren ad mmeččen</strong>, ula ma llan deg utellet.",
                rulesForcedMoveStrong: "atellet s tmara:",
                rulesForcedMove: "Deg tallit n unaqel, ma yella umyurar yezmer ad itellet, ilaq-as ad t-yexdem. Ma yella aṭas n yiberdan, ad yefren yiwen.",
                rulesDifferences: "Imgired gar tewsiyin :",
                rulesDifferencesIntro: "Yal tawsit tesɛa ilugan-is :",
                rulesTIDDEST: "TIDDEST :",
                rulesTIDDESTMovesStrong: "Anaqel :",
                rulesTIDDESTMoves: "Kan s teɣzi neɣ s tehri.",
                rulesTIDDESTCapturesStrong: "Učči :",
                rulesTIDDESTCaptures: "Win yesduklen tlata ad yefren aleqqaf n wexṣim-is ara yečč.",
                rulesTIDDESTWinStrong: "Arbaḥ :",
                rulesTIDDESTWin: "yerbeḥ win yeččan.",
                rulesTIDDESTNoForcedMoveStrong: "Ulac atellet s tmara :",
                rulesTIDDESTNoForcedMove: "Alugen n lmakala bessif ur ttilin ara.",
                rulesBessif: "Učči Bessif :",
                rulesBessifCombines: "Tesdukel ilugan n <strong>TIDDEST</strong> d umenzay n <strong>A werbaḥ s wexṣar</strong>.",
                rulesBessifMovesStrong: "Anaqel :",
                rulesBessifMoves: "Kan s teɣzi neɣ s tehri.",
                rulesBessifInverseWinStrong: "Arbaḥ s wexṣar :",
                rulesBessifInverseWin: "Amyurar ad irebḥ ma yella gran-as-d ala sin (2) ileqqafen, NEƔ ma yella axṣim-is ur yezmir ara ad inaqel, u netta (win i d-yuraren) yesɛa drus n yileqqafen.",
                rulesBessifOpponentChoosesStrong: "Axṣim ad yefren :",
                rulesBessifOpponentChooses: "Ma yella tetelteḍ, d <strong>axṣim-ik</strong> ara d-ifernen aleqqaf-is ara teččeḍ.",
                rulesBessifForcedMoveStrong: "atellet s tmara :",
                rulesBessifForcedMove: "Ur d ak d-iṣaḥ ara ad tenaqleḍ alqqaf ɣer w anda ur tettetelliteḍ ara ma yella tzmereḍ ad tetelteḍ.",
                footerHeritage: "Adles n yimaziɣen • Urar Aqbuṛ n Yeqbayliyen",
                footerCreator: "Iga-t",
                congratulations: "Ayuuuuz!",
                winnerMessage: "yerbeḥ !",
                replay: "Ɛiwed urar",
                statusPlayerTurn: "D nnuba n",
                statusChooseCapture: "fren aleqqaf n",
                statusToCapture: "ad teččeḍ.",
                statusChooseSacrifice: "ilaq-as ad yefren aleqqaf-is ara yefk.",
                statusPlacementPhase: "Aserrasu : D nnuba n",
                statusMovePhase: "Anaqel : D nnuba n",
                statusGameOver: "Yekfa w urar !",
                statusAlreadyOccupied: "taxxamt-a teččur !",
                statusNoPiecesToPlace: "Ur k-d-qqimen ara yileqqafen !",
                statusPlacementAlignForbidden: "D awezɣi ad tesdukleḍ 3 deg userrasu !",
                statusYourPiecesTurn: "D nnuba n yileqqafen-ik !",
                statusSelectYourPiece: "Fren yiwen uleqqaf-ik.",
                statusInvalidMove: "Ur d ak d-iṣaḥ ara.",
                statusMustMakeMill: "Ilaq-ak ad tesdukleḍ tlata ma yella tezmireḍ !",
                statusChooseOwnPieceToSacrifice: "Ilaq-ak ad teferneḍ yiwen uleqqaf-IK ara tefkeḍ !",
                statusChooseOpponentPieceToCapture: "Ilaq-ak ad teferneḍ aleqqaf n WEXṢIM-IK !",
                aiCannotMove: "Aselkim yeḥbes, yexṣer !",
                statusConsecutiveBlocked: "Aleqqaf-a yurar 3 tikkal i deffir ! Aru wayed.",
                youLost: "Txesreḍ 😭",
                aiWinsMessage: "yerbeḥ !",
                surrenderConfirm: "Tebɣiḍ ad tefkeḍ Mayna?",
                surrenderMessage: "yefka Mayna !",
		            stats: "Igemmaḍ",
                statsTitle: "Igemmaḍ & usemmed",
                resetStats: "Sfeḍ",
                exportStats: "Ssufeɣ-d",
                close: "Mdel",
                replayTitle: "aɛiwed",
                replayLast: "aɛiwed",
                guidedMode: "Awelleh",
      speed: "aɣiwel",
      installHelpTitle: "Areṣṣi n wurar",
      installHelpBody: "awelleh : iPhone/iPad «zuzer» → «Deg ​usebtar agejdan». Android/Chrome: «Areṣṣi» ma yella.",
      toastInstalled: "✅ urar yettwareṣṣa.",
      toastInstallUnavailable: "ℹ️ Areṣṣi ur yelli ara.",
      toastReplayReady: "⏯️ Aɛiwed yewjed.",
      toastNoReplay: "Ulac aɛiwed.",
      toastStatsReset: "Agemmuḍ ittwasfeḍ.",
      toastExported: "Asuffeɣ yekfa.",
      toastSWReady: "✅ War-internet ihegga.",
      toastSWUpdate: "🔄 Aleqqem yewjed.",
      boardAria: "Taslaḍt n wurar",
      cellLabel: "Taxxamt",
      cellEmpty: "texla",
      gamesPlayedLabel: "timlilit",
      winsLabel: "timliliyin yettwarebḥen",
      lossesLabel: "Timliliyin yettwaxesren",
      winRateLabel: "Agemmuḍ n rbeḥ",
      streakLabel: "Agraw",
      bestStreakLabel: "Agraw ifazen",
      movesLabel: "Ambiwel",
      capturesLabel: "Učči",
      millsLabel: "Atellet",
      durationLabel: "Akud",
      levelLabel: "Aswir",
      xpLabel: "XP",
      lastGameLabel: "Urar aneggaru",
      debugTestsRunning: "Ikayaden…",
      debugTestsDone: "Ikayaden fukken",
      btnTheme: "Asentel",
      btnSound: "Ṣṣut",
      btnSettings: "Aseggem",
      themeGlass: "zǧǧaǧ",
      themeContrast: "Amgired",
      themeModern: "Amaynut",
      themeModernDark: "Amaynut qessiḥen",
      themeKabylie: "Taqbaylit",
      // NEW: hardcoded UI elements not previously translated
      spectatorBadgeTxt: "👁 Anezzeh",
      btnResume: "Kemmel",
      btnDiscard: "Ala",
      ariaRulesClose: "Mdel",
      ariaReplayFirst: "Bdu",
      ariaReplayPrev: "Yezrin",
      ariaReplayPlay: "Urar/Ḥbes",
      ariaReplayNext: "wayeḍ",
      ariaReplayLast: "taggara",
      ariaSettingsFab: "Aseggem",
      ariaInstallBtn: "Areṣṣi n wurar",
      ariaModeGuide: "Awelleh"
            }
        };
        // --- DEEP COPY HELPER ---
        function deepCopy(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        // --- MODAL FUNCTIONS ---
        function showConfirmationModal(titleKey, messageKey, onConfirm) {
            modalTitle.textContent = translations[currentLanguage][titleKey];
            modalMessage.textContent = translations[currentLanguage][messageKey];
            modalConfirmBtn.textContent = translations[currentLanguage]['confirm'];
            modalCancelBtn.textContent = translations[currentLanguage]['cancel'];
            onConfirmCallback = onConfirm;
            confirmationModal.classList.add('active');
        }

        function hideConfirmationModal() {
            confirmationModal.classList.remove('active');
            onConfirmCallback = null;
        }

        function showRulesModal() {
            document.querySelectorAll('.rules-content').forEach(el => el.style.display = 'none');
            const currentRules = document.querySelector(`.rules-content[lang="${currentLanguage}"]`);
            if (currentRules) {
                currentRules.style.display = 'block';
            }
            rulesModal.classList.add('active');
        }

        function hideRulesModal() {
            rulesModal.classList.remove('active');
        }

        // --- DISPLAY AND UI FUNCTIONS ---
        function updateLanguage(lang) {
            const oldLang = currentLanguage;
            currentLanguage = lang;
            document.documentElement.lang = lang; 

            const defaultNames = [
                translations[oldLang]?.defaultPlayer1,
                translations[oldLang]?.defaultPlayer2,
                translations[oldLang]?.defaultHumanName,
                translations[oldLang]?.defaultComputerName
            ].filter(Boolean);

            if (defaultNames.includes(player1Name)) {
                if (gameMode === 'ai') {
                    player1Name = humanPlayerId === 1 ? translations[lang].defaultHumanName : translations[lang].defaultComputerName;
                } else {
                    player1Name = translations[lang].defaultPlayer1;
                }
            }
            if (defaultNames.includes(player2Name)) {
                if (gameMode === 'ai') {
                    player2Name = humanPlayerId === 2 ? translations[lang].defaultHumanName : translations[lang].defaultComputerName;
                } else {
                    player2Name = translations[lang].defaultPlayer2;
                }
            }
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                const translation = translations[lang][key];
                if (translation !== undefined) {
                    let target = el.querySelector('span:not([data-i18n])') || el;
                    setSafeHTML(target, translation);
                }
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                el.placeholder = translations[lang][el.dataset.i18nPlaceholder] || el.dataset.i18nPlaceholder;
            });
            document.title = translations[lang].appTitle;
            
            if (state && !state.winner) {
                updateStatus();
                updatePlayerNamesDisplay();
                updateGameInfoDisplay();
            }
            updateColorOptionSelection(humanPlayerId);
            if (rulesModal.classList.contains('active')) {
                showRulesModal();
            }
            // Update hardcoded UI elements not covered by data-i18n
            _applyHardcodedI18n(lang);
        }

        function _applyHardcodedI18n(lang) {
            const tr = translations[lang] || translations['fr'];
            // Spectator badge
            const badge = document.getElementById('spectator-badge');
            if (badge) badge.textContent = tr.spectatorBadgeTxt || '👁 Mode Spectateur';
            // Save notification buttons
            const btnResume = document.getElementById('btn-resume');
            if (btnResume) btnResume.textContent = tr.btnResume || 'Reprendre';
            const btnDiscard = document.getElementById('btn-discard');
            if (btnDiscard) btnDiscard.textContent = tr.btnDiscard || 'Non';
            // Rules close button aria/title
            const rulesCloseBtn2 = document.getElementById('rules-close-btn');
            if (rulesCloseBtn2) {
                rulesCloseBtn2.setAttribute('aria-label', tr.ariaRulesClose || 'Fermer');
                rulesCloseBtn2.title = tr.ariaRulesClose || 'Fermer';
            }
            // Replay controls aria-labels
            const replayMap = {
                'replay-first-btn': tr.ariaReplayFirst || 'Début',
                'replay-prev-btn':  tr.ariaReplayPrev  || 'Précédent',
                'replay-play-btn':  tr.ariaReplayPlay  || 'Lecture/Pause',
                'replay-next-btn':  tr.ariaReplayNext  || 'Suivant',
                'replay-last-btn':  tr.ariaReplayLast  || 'Fin'
            };
            for (const [id, label] of Object.entries(replayMap)) {
                const el = document.getElementById(id);
                if (el) el.setAttribute('aria-label', label);
            }
            // Settings FAB title/aria
            const sfab = document.getElementById('settings-fab');
            if (sfab) {
                sfab.setAttribute('aria-label', tr.ariaSettingsFab || 'Paramètres');
                sfab.title = tr.ariaSettingsFab || 'Paramètres';
            }
            // Install btn title/aria
            const installBtn = document.getElementById('install-btn');
            if (installBtn) {
                installBtn.setAttribute('aria-label', tr.ariaInstallBtn || 'Installer l\'application');
                installBtn.title = tr.ariaInstallBtn || 'Installer l\'application';
            }
            // Guided btn title/aria
            const guidedBtn = document.getElementById('guided-btn');
            if (guidedBtn) {
                guidedBtn.setAttribute('aria-label', tr.ariaModeGuide || 'Mode guidé');
                guidedBtn.title = tr.ariaModeGuide || 'Mode guidé';
            }
        }

        function showScreen(screenId) {
            currentScreen = screenId;
            allScreens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(screenId)?.classList.add('active');

            if (screenId === 'game-play-area') {
                mainHeader.classList.add('hidden');
            } else {
                mainHeader.classList.remove('hidden');
                stopSpectatorMode();
            }

            if (screenId === 'player-setup-area') {
                const isAiMode = gameMode === 'ai';
                player2NameGroup.style.display = isAiMode ? 'none' : 'flex';
                colorChoiceSection.style.display = isAiMode ? 'flex' : 'none';
                
                player1NameLabel.textContent = translations[currentLanguage][isAiMode ? 'playerHumanName' : 'player1NameLabel'];
                
                player1NameInput.value = '';
                player2NameInput.value = '';
                
                if (isAiMode) {
                    humanPlayerId = 1; // Default human to player 1
                    player1Name = translations[currentLanguage].defaultHumanName;
                    player2Name = translations[currentLanguage].defaultComputerName;
                } else {
                    player1Name = translations[currentLanguage].defaultPlayer1;
                    player2Name = translations[currentLanguage].defaultPlayer2;
                }
                updateColorOptionSelection(humanPlayerId);
            }
        }
        
        function updateColorOptionSelection(selectedPlayerId) {
            colorOptions.forEach(option => {
                const id = parseInt(option.dataset.player);
                const isSelected = id === selectedPlayerId;
                option.classList.toggle('selected', isSelected);
                option.querySelector('input[type="radio"]').checked = isSelected;
                const span = option.querySelector('span');
                const colorKey = `player${id}Color`;
                const colorName = translations[currentLanguage][colorKey].split(' ')[0];
                if (gameMode === 'ai') {
                    span.textContent = isSelected ? `${translations[currentLanguage].yourColor} (${colorName})` : `${translations[currentLanguage].aiColor} (${colorName})`;
                } else {
                    span.textContent = translations[currentLanguage][colorKey];
                }
            });
        }

        function updateGameInfoDisplay() {
            const variantInfoEl = document.getElementById('game-variant-info');
            const difficultyInfoEl = document.getElementById('game-difficulty-info');
            
            if (variant) {
                const variantTitleKey = variant === 'TIDDEST-no-diag' ? 'TIDDESTTitle' : 'bessifTitle';
                variantInfoEl.innerHTML = `<strong>${translations[currentLanguage].gameVersion}</strong> ${translations[currentLanguage][variantTitleKey]}`;
            } else {
                 variantInfoEl.innerHTML = '';
            }

            if (gameMode === 'ai' && aiDifficulty) {
                const difficultyNameKey = {1: 'difficultyEasy', 2: 'difficultyMedium', 3: 'difficultyHard', 4: 'difficultyImpossible'}[aiDifficulty];
                difficultyInfoEl.innerHTML = `<strong>${translations[currentLanguage].aiDifficultyDisplayLabel}</strong> ${translations[currentLanguage][difficultyNameKey]}`;
                difficultyInfoEl.style.display = 'block';
            } else {
                difficultyInfoEl.innerHTML = '';
                difficultyInfoEl.style.display = 'none';
            }
        }

        function triggerConfetti() {
            runConfetti(5000);
        }

        function showWinnerAnimation(message, name) {
            playSound('victory');
            clearSave();
            winnerOverlay.querySelector('.winner-message').textContent = message;
            winnerNameElement.textContent = name;
            winnerOverlay.classList.add('active');
            triggerConfetti();
            finalizeSessionAndStats();
            pushReplayFrame();
            persistLastReplay();
        }
        
        function hideWinnerAnimation() {
            stopSpectatorMode();
            winnerOverlay.classList.remove('active');
            showScreen('version-selection-area');
        }

        function showStatusError(messageKey) {
            playSound('error');
            const originalText = statusDiv.textContent;
            statusDiv.textContent = translations[currentLanguage][messageKey] || messageKey;
            statusDiv.classList.add('status-error');
            setTimeout(() => {
                statusDiv.classList.remove('status-error');
                statusDiv.textContent = originalText;
                updateStatus();
            }, 1500);
        }

        function __resolveIconEmoji(iconToken) {
            if (!iconToken) return '';
            const s = String(iconToken);
            // If it doesn't look like a FontAwesome class list, treat it as a direct emoji/symbol.
            if (s.indexOf('fa-') === -1) return s;

            const cls = s.split(/\s+/).find(c => c.startsWith('fa-'));
            const map = {
                'fa-globe':'🌐','fa-book-open':'📖','fa-robot':'🤖','fa-users':'👥','fa-eye':'👁️',
                'fa-smile':'🙂','fa-meh':'😐','fa-grimace':'😬','fa-frown':'😟','fa-grin-beam':'😁',
                'fa-mouse-pointer':'👉','fa-exchange-alt':'🔄','fa-skull-crossbones':'☠️','fa-check-circle':'✅',
                'fa-play':'▶️','fa-compact-disc':'💿','fa-ghost':'👻','fa-home':'🏠','fa-undo':'↩️','fa-redo':'↪️','fa-flag':'🏳️'
            };
            return map[cls] || '•';
        }

        function showEphemeralBubbleMessage(messageKey, iconClass = '', duration = 2000) {
            const msg = (translations[currentLanguage] && translations[currentLanguage][messageKey]) || messageKey;
            const emoji = __resolveIconEmoji(iconClass);

            // Build DOM nodes (no external icon fonts required)
            ephemeralMessageBubble.textContent = '';
            if (emoji) {
                const iconEl = document.createElement('i');
                iconEl.className = 'icon';
                iconEl.setAttribute('aria-hidden', 'true');
                iconEl.textContent = emoji;
                ephemeralMessageBubble.appendChild(iconEl);
                ephemeralMessageBubble.appendChild(document.createTextNode(' '));
            }
            const span = document.createElement('span');
            span.textContent = msg;
            ephemeralMessageBubble.appendChild(span);

            ephemeralMessageBubble.classList.add('active');
            setTimeout(() => ephemeralMessageBubble.classList.remove('active'), duration);
        }

        // --- GAME INITIALIZATION AND LOGIC ---
        function initState() {
            return {
                board: Array(SIZE * SIZE).fill(null),
                phase: "placement",
                turn: 2,
                turnForCapture: null,
                counts: { 1: PIECES, 2: PIECES },
                captured: { 1: 0, 2: 0 },
                selected: null,
                captureMode: false,
                winner: null,
                highlightedMills: [],
                pendingCaptures: 0,
                // --- RÈGLE : même pion max 3 fois de suite ---
                // consecutivePiece[p] = indice actuel du pion surveillé pour le joueur p
                // consecutiveCount[p] = combien de fois consécutives ce pion a été déplacé
                consecutivePiece: { 1: null, 2: null },
                consecutiveCount: { 1: 0, 2: 0 },
            };
        }


        // ─────────────────────────────────────────────────────────────
        // RÈGLE : Même pion max 3 fois consécutives
        // ─────────────────────────────────────────────────────────────

        /**
         * Vérifie si le pion à la position fromIdx est interdit pour player
         * parce quil a déjà été déplacé 3 fois de suite.
         * Exception : si cest le SEUL pion que le joueur peut bouger (deadlock)
         */
        function isConsecutiveBlocked(player, fromIdx) {
            if (state.phase !== 'move') return false;
            if (state.consecutivePiece[player] !== fromIdx) return false;
            if (state.consecutiveCount[player] < 3) return false;
            return hasAlternativePiece(player, fromIdx);
        }

        /**
         * Renvoie true si le joueur possède au moins un autre pion capable de bouger.
         */
        function hasAlternativePiece(player, forbiddenIdx) {
            for (let from = 0; from < SIZE * SIZE; from++) {
                if (from === forbiddenIdx) continue;
                if (state.board[from] !== player) continue;
                for (let to = 0; to < SIZE * SIZE; to++) {
                    if (state.board[to] === null && isAdjacent(from, to)) return true;
                }
            }
            return false;
        }

        /**
         * Met à jour le suivi consécutif APRÈS un déplacement from->to.
         */
        function updateConsecutiveTracking(player, fromIdx, toIdx) {
            if (state.consecutivePiece[player] === fromIdx) {
                state.consecutiveCount[player] = Math.min(state.consecutiveCount[player] + 1, 99);
            } else {
                state.consecutiveCount[player] = 1;
            }
            state.consecutivePiece[player] = toIdx;
        }

        /**
         * Filtre une liste de mouvements pour retirer le pion interdit.
         * Exception : si aucun autre mouvement nexiste, garde tout (deadlock).
         */
        function filterConsecutiveMoves(player, moves) {
            if (state.phase !== 'move') return moves;
            const forbidden = state.consecutivePiece[player];
            if (forbidden === null) return moves;
            if (state.consecutiveCount[player] < 3) return moves;
            const allowed = moves.filter(m => m.from !== forbidden);
            return allowed.length > 0 ? allowed : moves;
        }

        // ─────────────────────────────────────────────────────────────

        function startGame() {
            state = initState();
            moveHistory = []; 

            const p1Input = player1NameInput.value.trim();
            const p2Input = player2NameInput.value.trim();

            if (gameMode === 'ai') {
                aiPlayerId = (humanPlayerId === 1) ? 2 : 1;
                if (p1Input) {
                    if (humanPlayerId === 1) player1Name = p1Input;
                    else player2Name = p1Input;
                } else {
                    if (humanPlayerId === 1) player1Name = translations[currentLanguage].defaultHumanName;
                     else player2Name = translations[currentLanguage].defaultHumanName;
                }

                if (aiPlayerId === 1) player1Name = translations[currentLanguage].defaultComputerName;
                else player2Name = translations[currentLanguage].defaultComputerName;
            } else {
                aiPlayerId = null;
                player1Name = p1Input || translations[currentLanguage].defaultPlayer1;
                player2Name = p2Input || translations[currentLanguage].defaultPlayer2;
            }
            
            updateGameInfoDisplay();
            showScreen('game-play-area');
            renderAll();
            triggerNextAction();
        }
        
        function renderAll() {
            renderBoard();
            updateInfo();
            updateStatus();
            updatePlayerNamesDisplay();
            updateUndoButtonState();
        }

        function renderBoard() {
            boardDiv.innerHTML = '';
            // Calcul du pion bloqué pour le joueur actif (affichage visuel)
            const blockedIdx = (state.phase === 'move' && !state.captureMode)
                ? (() => {
                    const p = state.turn;
                    const idx = state.consecutivePiece[p];
                    if (idx === null || state.consecutiveCount[p] < 3) return null;
                    return hasAlternativePiece(p, idx) ? idx : null;
                  })()
                : null;

            for(let i = 0; i < SIZE * SIZE; i++) {
                const cell = document.createElement('div');
                cell.className = "cell";
                cell.dataset.idx = i;
                if((Math.floor(i / SIZE) + i % SIZE) % 2 !== 0) {
                    cell.classList.add("dark-cell");
                }
                if(state.selected === i) {
                    cell.classList.add("selected");
                }
                if (!state.captureMode && state.selected !== null && state.board[i] === null && isAdjacent(state.selected, i)) {
                    cell.classList.add("possible-move");
                }
                if (state.highlightedMills.includes(i)) {
                    cell.classList.add("mill-highlight");
                }
                if(state.board[i]) {
                    const stone = document.createElement('div');
                    stone.className = `stone player${state.board[i]}`;
                    if(state.selected === i) stone.classList.add("selected");
                    // ── Marquage pion épuisé (3 fois de suite) ──
                    if (i === blockedIdx) stone.classList.add("consecutive-blocked");
                    cell.appendChild(stone);
                }
                // Marquer la cellule aussi si le pion y est bloqué
                if (i === blockedIdx) cell.classList.add("consecutive-blocked-cell");
                cell.onclick = () => onCellClick(i);
                boardDiv.appendChild(cell);
            }

            if(state.captureMode) {
                const playerWhosePiecesAreTargetable = variantConfig[variant].isInverseWin ? state.turnForCapture : (3 - state.turnForCapture);
                for(let i = 0; i < SIZE * SIZE; i++) {
                    if(state.board[i] === playerWhosePiecesAreTargetable) { 
                        boardDiv.children[i].classList.add("capturable");
                        boardDiv.children[i].onclick = () => onCellClick(i);
                    } else {
                        boardDiv.children[i].onclick = null;
                    }
                }
            } else {
                for(let i = 0; i < SIZE * SIZE; i++) {
                    boardDiv.children[i].onclick = () => onCellClick(i);
                }
            }
            updateActivePlayerDisplay();
        }

        function updateInfo() {
            if (state.phase === 'placement') {
                // During placement: show remaining pieces to place
                p1Count.textContent = state.counts[1];
                p2Count.textContent = state.counts[2];
            } else {
                // During move phase: show pieces on the board
                p1Count.textContent = state.board.filter(p => p === 1).length;
                p2Count.textContent = state.board.filter(p => p === 2).length;
            }
            p1Capt.textContent = state.captured[1];
            p2Capt.textContent = state.captured[2];
        }
        
        function updatePlayerNamesDisplay() {
            const p1ColorName = translations[currentLanguage].player1Color.split(' ')[0];
            const p2ColorName = translations[currentLanguage].player2Color.split(' ')[0];
            p1DisplayName.textContent = `${player1Name} (${p1ColorName})`;
            p2DisplayName.textContent = `${player2Name} (${p2ColorName})`;
        }

        function updateStatus() {
            if (state.winner) {
                statusDiv.textContent = translations[currentLanguage].statusGameOver;
                return;
            }
            
            const p1NameForStatus = p1DisplayName.textContent.split(' (')[0];
            const p2NameForStatus = p2DisplayName.textContent.split(' (')[0];
            
            if (state.captureMode) {
                // captureCountInfo: only shown if multiple captures remain in one turn
                const captureCountInfo = state.pendingCaptures > 1 ? ` (×${state.pendingCaptures})` : '';
                
                const playerWhoChoosesName = (state.turnForCapture === 1) ? p1NameForStatus : p2NameForStatus;

                if (variantConfig[variant].isInverseWin) {
                    statusDiv.textContent = `${playerWhoChoosesName} ${translations[currentLanguage].statusChooseSacrifice}${captureCountInfo}`;
                } else {
                    const playerWhosePieceIsCapturedName = (state.turnForCapture === 1) ? p2NameForStatus : p1NameForStatus;
                    statusDiv.textContent = `${playerWhoChoosesName}, ${translations[currentLanguage].statusChooseCapture} ${playerWhosePieceIsCapturedName} ${translations[currentLanguage].statusToCapture}${captureCountInfo}`;
                }
            } else {
                 const currentPlayerName = (state.turn === 1) ? p1NameForStatus : p2NameForStatus;
                 const phaseKey = state.phase === 'placement' ? 'statusPlacementPhase' : 'statusMovePhase';
                 statusDiv.textContent = `${translations[currentLanguage][phaseKey]} ${currentPlayerName}.`;
            }
        }
       
        function updateActivePlayerDisplay() {
            const activePlayer = state.captureMode ? state.turnForCapture : state.turn;
            p1Info.classList.toggle('active-player', activePlayer === 1);
            p2Info.classList.toggle('active-player', activePlayer === 2);
        }

        function updateUndoButtonState() {
            const canUndo = moveHistory.length > 0 && 
                            !state.winner && 
                            (gameMode !== 'ai' || state.turn === humanPlayerId) &&
                            !state.captureMode;
            undoBtn.disabled = !canUndo;
        }
        
        function onCellClick(i) {
            if (state.winner) return;
            if (gameMode === 'spectator') return;
            const playerWhoShouldAct = state.captureMode ? state.turnForCapture : state.turn;
            if (gameMode === 'ai' && playerWhoShouldAct === aiPlayerId) {
                return;
            }
            if (state.captureMode) {
                handleCaptureClick(i);
                return;
            }

            const prevSelected = state.selected;
            moveHistory.push(deepCopy(state));
            if (state.phase === 'placement') {
                handlePlacement(i);
            } else {
                handleMove(i);
                if (state.selected !== null && state.selected !== prevSelected) {
                    playSound('select');
                }
            }
            saveGame();
        }
        
        
        function handleUndo() {
            if (undoBtn.disabled) return;
            if (moveHistory.length === 0) return;

            playSound('undo');
            if (gameMode === 'ai') {
                const isPlayableHumanTurn = (s) => s && !s.captureMode && s.turn === humanPlayerId;
                let candidate = null;
                while (moveHistory.length > 0) {
                    candidate = moveHistory.pop();
                    if (isPlayableHumanTurn(candidate)) break;
                }
                if (candidate) state = candidate;
            } else {
                state = moveHistory.pop();
            }

            if (moveLog.length > 0) { moveLog.pop(); renderMoveLog(); }
            renderAll();
            if (!state.winner) triggerNextAction();
        }


        function handleCaptureClick(i) {
            if (!state.captureMode || state.winner) return;
            const pieceOwner = state.board[i];
            const isInverseWin = variantConfig[variant].isInverseWin;
            if (isInverseWin) {
                if (pieceOwner !== state.turnForCapture) {
                    showStatusError('statusChooseOwnPieceToSacrifice');
                    return;
                }
            } else {
                if (pieceOwner !== (3 - state.turnForCapture)) {
                    showStatusError('statusChooseOpponentPieceToCapture');
                    return;
                }
            }
            handleCapture(i);
        }

        function handlePlacement(i) {
            if (state.board[i] !== null) { showStatusError('statusAlreadyOccupied'); moveHistory.pop(); return; }
            if (state.counts[state.turn] <= 0) { showStatusError('statusNoPiecesToPlace'); moveHistory.pop(); return; }
            
            const tempBoard = [...state.board];
            tempBoard[i] = state.turn;
            if (formsForbiddenPlacementAlignment(i, state.turn, tempBoard)) {
                showStatusError('statusPlacementAlignForbidden');
                moveHistory.pop();
                return;
            }
            
            state.board[i] = state.turn;
            state.counts[state.turn]--;
            animateStonePlacement(i, state.turn);
            endTurn();
        }

        function handleMove(i) {
            if (state.selected === null) {
                if (state.board[i] === state.turn) {
                    // ── Règle : pion joué 3× de suite interdit ──
                    if (isConsecutiveBlocked(state.turn, i)) {
                        showStatusError('statusConsecutiveBlocked');
                        moveHistory.pop();
                        return;
                    }
                    state.selected = i;
                    moveHistory.pop(); 
                    renderBoard(); 
                    updateStatus();
                } else {
                    showStatusError(state.board[i] ? 'statusYourPiecesTurn' : 'statusSelectYourPiece');
                    moveHistory.pop();
                }
            } 
            else {
                const from = state.selected;
                const to = i;
                if (to === from) { state.selected = null; moveHistory.pop(); renderBoard(); updateStatus(); return; }
                // Si le joueur clique sur un autre de ses pions → le sélectionner
                // Mais vérifier la règle consécutive sur le nouveau pion aussi
                if (state.board[to] === state.turn) {
                    if (isConsecutiveBlocked(state.turn, to)) {
                        showStatusError('statusConsecutiveBlocked');
                        state.selected = null;
                        moveHistory.pop();
                        renderBoard();
                        updateStatus();
                        return;
                    }
                    state.selected = to;
                    moveHistory.pop();
                    renderBoard();
                    updateStatus();
                    return;
                }
                if (state.board[to] === null && isAdjacent(from, to)) {
                    if (variantConfig[variant].forceMillMove) {
                        const allPossibleMillMovesForPlayer = getPossibleMillMoves(state.turn, state.board, 'move');
                        const tempBoard = simulateMove(state.board, {from, to}, state.turn);
                        const isCurrentMoveAMill = findAllMills(state.board, tempBoard, from, to, state.turn).length > 0;
                        if (allPossibleMillMovesForPlayer.length > 0 && !isCurrentMoveAMill) {
                            showStatusError('statusMustMakeMill');
                            state.selected = null;
                            moveHistory.pop();
                            renderBoard();
                            updateStatus();
                            return;
                        }
                    }
                    
                    // ── Mémoriser le joueur AVANT l'animation (state.turn peut changer) ──
                    const movingPlayer = state.turn;
                    const moveFrom = from;
                    const moveTo = to;

                    animateStoneMove(from, to);
                    setTimeout(() => {
                        const originalBoard = [...state.board];
                        state.board[moveTo] = movingPlayer;
                        state.board[moveFrom] = null;
                        state.selected = null;

                        // ── Mise à jour suivi consécutif ──
                        updateConsecutiveTracking(movingPlayer, moveFrom, moveTo);

                        const formedMills = findAllMills(originalBoard, state.board, moveFrom, moveTo, movingPlayer);
                        
                        if (formedMills.length > 0) { 
                            state.captureMode = true; 
                            state.pendingCaptures = formedMills.length;
                            state.turnForCapture = variantConfig[variant].isInverseWin ? (3 - movingPlayer) : movingPlayer;
                            state.highlightedMills = formedMills.flat();

                            const emoji = variantConfig[variant].isInverseWin ? 'far fa-frown' : 'far fa-grin-beam';
                            showEphemeralBubbleMessage('ephemeralMill', emoji);
                
                            renderBoard();
                            updateUndoButtonState();
                            setTimeout(() => { state.highlightedMills = []; renderBoard(); }, 1500);

                            updateStatus();
                            triggerNextAction();
                        } else {
                            endTurn();
                        }
                    }, 300);
                } 
                else {
                    showStatusError('statusInvalidMove');
                    state.selected = null;
                    moveHistory.pop();
                    renderBoard();
                    updateStatus();
                }
            }
        }

        function handleCapture(idxToCapture) {
            const capturerTurn = state.turnForCapture;
            playSound('capture');
            addMoveLog({ player: capturerTurn, text: `${(translations[currentLanguage] && translations[currentLanguage].logCapture) || 'Capture'} [${Math.floor(idxToCapture/5)+1},${idxToCapture%5+1}]`, capture: true });
            // Undo behavior: a capture is part of the same "turn transaction" as the move/placement that created it.
            // We deliberately DO NOT push a new snapshot here, otherwise undo can revert to a captureMode state and lock the player.
            if (!state.captureMode || state.winner) return;
            const playerWhoGetsPoint = variantConfig[variant].isInverseWin ? (3 - state.turnForCapture) : state.turnForCapture;
            
            animateStoneCapture(idxToCapture);
            const messageKey = variantConfig[variant].isInverseWin ? 'ephemeralCaptureBessif' : 'ephemeralCaptureNormal';
            showEphemeralBubbleMessage(messageKey, 'fas fa-mouse-pointer');
            
            setTimeout(() => {
                state.board[idxToCapture] = null;
                state.captured[playerWhoGetsPoint]++;
                state.pendingCaptures--;

                if (state.pendingCaptures > 0) {
                    renderAll();
                    triggerNextAction();
                } else {
                    state.captureMode = false; 
                    state.turnForCapture = null;
                    state.highlightedMills = [];
                    endTurn();
                }
            }, 500);
        }

        function handleSurrender() {
            if (state.winner) return;
            const winnerId = 3 - state.turn;
            state.winner = winnerId;
            const p1NameForStatus = p1DisplayName.textContent.split(' (')[0];
            const p2NameForStatus = p2DisplayName.textContent.split(' (')[0];

            const winnerName = (winnerId === 1) ? p1NameForStatus : p2NameForStatus;
            const winMessage = `${winnerName} ${translations[currentLanguage].winnerMessage}`;
            const surrendererName = state.turn === 1 ? p1NameForStatus : p2NameForStatus;
            statusDiv.textContent = `${surrendererName} ${translations[currentLanguage].surrenderMessage}`;
            showWinnerAnimation(translations[currentLanguage].congratulations, winMessage);
            updateUndoButtonState();
        }

        function endTurn() {
            state.turn = 3 - state.turn;
            if (state.phase === 'placement' && state.counts[1] === 0 && state.counts[2] === 0) {
                state.phase = 'move';
                showEphemeralBubbleMessage('ephemeralMovePhase', "fas fa-exchange-alt");
            }
            checkWinner();
            renderAll();
            saveGame();
            if(!state.winner){
                triggerNextAction();
            }
        }

        function endGame() {
            let finalMessage = "";
            let finalWinnerName = "";
            const winnerName = (state.winner === 1) ? p1DisplayName.textContent.split(' (')[0] : p2DisplayName.textContent.split(' (')[0];
            
            if (gameMode === 'ai' && state.winner === aiPlayerId) {
                finalMessage = translations[currentLanguage].youLost;
                finalWinnerName = `${winnerName} ${translations[currentLanguage].aiWinsMessage}`;
            } else {
                finalMessage = translations[currentLanguage].congratulations;
                finalWinnerName = `${winnerName} ${translations[currentLanguage].winnerMessage}`;
            }
            showWinnerAnimation(finalMessage, finalWinnerName);
            updateStatus();
            updateUndoButtonState();
        }
        
        function triggerNextAction() {
            if (state.winner) return;
            const playerToAct = state.captureMode ? state.turnForCapture : state.turn;

            if (gameMode === 'spectator') {
                const spd = parseInt(document.getElementById('spectator-speed')?.value || '700');
                setTimeout(() => {
                    if (gameMode !== 'spectator') return;
                    const currentActor = state.captureMode ? state.turnForCapture : state.turn;
                    aiPlayerId = currentActor;
                    humanPlayerId = 3 - currentActor;
                    makeAiMove();
                }, spd);
                return;
            }
            if (gameMode === 'ai' && playerToAct === aiPlayerId) {
                const delay = aiDifficulty === 4 ? 800 : 500;
                setTimeout(() => { makeAiMove(); }, delay);
            }
        }

        // --- GAME RULES AND CHECKS ---
        function findAllMills(originalBoard, newBoard, from, to, player) {
            const millsBefore = new Set();
            for (let i = 0; i < SIZE * SIZE; i++) {
                if (originalBoard[i] === player) {
                    getFormedMills(i, player, originalBoard).forEach(mill => millsBefore.add(mill.sort().join(',')));
                }
            }

            const millsAfter = new Set();
            for (let i = 0; i < SIZE * SIZE; i++) {
                if (newBoard[i] === player) {
                    getFormedMills(i, player, newBoard).forEach(mill => millsAfter.add(mill.sort().join(',')));
                }
            }

            const newlyFormedMills = [];
            for (const millString of millsAfter) {
                if (!millsBefore.has(millString)) {
                    newlyFormedMills.push(millString.split(',').map(Number));
                }
            }
            
            const uniqueNewlyFormedMills = [];
            const seen = new Set();
            for(const mill of newlyFormedMills){
                const sortedMill = [...mill].sort((a,b)=>a-b), key = sortedMill.join(',');
                if(!seen.has(key)){ uniqueNewlyFormedMills.push(sortedMill); seen.add(key); }
            }
            return uniqueNewlyFormedMills;
        }

        function getFormedMills(idx, player, board) {
            const mills = [], r = Math.floor(idx / SIZE), c = idx % SIZE;
            const directions = [[[0, -1], [0, 1]], [[-1, 0], [1, 0]]];
            for (const [dir1, dir2] of directions) {
                let line = [idx];
                for (let i = 1; i < SIZE; i++) { 
                    const nr = r + dir1[0] * i, nc = c + dir1[1] * i, nIdx = nr * SIZE + nc;
                    if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nIdx] === player) { line.unshift(nIdx); } else break;
                }
                for (let i = 1; i < SIZE; i++) { 
                    const nr = r + dir2[0] * i, nc = c + dir2[1] * i, nIdx = nr * SIZE + nc;
                    if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && board[nIdx] === player) { line.push(nIdx); } else break;
                }
                if (line.length === 3) {
                    mills.push([...line].sort((a,b) => a-b));
                }
            }
            return mills;
        }
        


        // Placement rule: it is forbidden to create an alignment of 3 OR MORE stones during placement.
        // (Mills during movement remain STRICTLY 3 stones.)
        function formsForbiddenPlacementAlignment(idx, player, board) {
            const r = Math.floor(idx / SIZE), c = idx % SIZE;

            const countDir = (dr, dc) => {
                let n = 0;
                let rr = r + dr, cc = c + dc;
                while (rr >= 0 && rr < SIZE && cc >= 0 && cc < SIZE) {
                    const ii = rr * SIZE + cc;
                    if (board[ii] === player) { n++; rr += dr; cc += dc; }
                    else break;
                }
                return n;
            };

            // Horizontal length through idx
            const h = 1 + countDir(0, -1) + countDir(0, 1);
            if (h >= 3) return true;

            // Vertical length through idx
            const v = 1 + countDir(-1, 0) + countDir(1, 0);
            if (v >= 3) return true;

            return false;
        }
        function isAdjacent(a, b) {
            const r1 = Math.floor(a / SIZE), c1 = a % SIZE;
            const r2 = Math.floor(b / SIZE), c2 = b % SIZE;
            return (Math.abs(r1 - r2) === 1 && c1 === c2) || (Math.abs(c1 - c2) === 1 && r1 === r2);
        }

        function canPlayerMove(player, board) {
            if (board.filter(p => p === player).length < 3) return false;
            for (let i = 0; i < SIZE * SIZE; i++) {
                if (board[i] === player) {
                    for (let j = 0; j < SIZE * SIZE; j++) {
                        if (board[j] === null && isAdjacent(i, j)) return true;
                    }
                }
            }
            return false;
        }

        function checkWinner() {
            if (state.phase !== 'move') return;
            const p1Pieces = state.board.filter(p => p === 1).length;
            const p2Pieces = state.board.filter(p => p === 2).length;
            const p1CanMove = canPlayerMove(1, state.board);
            const p2CanMove = canPlayerMove(2, state.board);

            if (variantConfig[variant].isInverseWin) {
                if (p1Pieces < 3 || !p1CanMove) state.winner = 1;
                else if (p2Pieces < 3 || !p2CanMove) state.winner = 2;
            } else {
                if (p2Pieces < 3 || !p2CanMove) state.winner = 1;
                else if (p1Pieces < 3 || !p1CanMove) state.winner = 2;
            }
            if (state.winner) endGame();
        }
        
        function countPlayerMoves(player, board, phase) {
            const currentPhase = phase !== undefined ? phase : state.phase;
            if (currentPhase === 'placement') return board.filter(p => p === null).length;
            let moveCount = 0;
            for (let i = 0; i < SIZE * SIZE; i++) {
                if (board[i] === player) {
                    for (let j = 0; j < SIZE * SIZE; j++) {
                        if (board[j] === null && isAdjacent(i, j)) moveCount++;
                    }
                }
            }
            return moveCount;
        }

        // --- ARTIFICIAL INTELLIGENCE ---
        const STRATEGIC_CELLS = {
            center: [12],
            inner_corners: [6, 8, 16, 18],
            edge_centers: [7, 11, 13, 17],
            inner_ring: [6, 7, 8, 11, 12, 13, 16, 17, 18],
        };



        function isInInnerRing(idx) {
            return STRATEGIC_CELLS.inner_ring.includes(idx);
        }
        function isCenterCell(idx) {
            return STRATEGIC_CELLS.center.includes(idx);
        }

        // Aggregation metrics around a target cell.
        // adj1: number of own pieces at Chebyshev distance 1 (including diagonals)
        // adj2: number of own pieces at Chebyshev distance 2
        function getAggregationMetrics(board, targetIdx, player) {
            const tr = Math.floor(targetIdx / SIZE);
            const tc = targetIdx % SIZE;
            let adj1 = 0, adj2 = 0;

            for (let i = 0; i < board.length; i++) {
                if (i === targetIdx) continue;
                if (board[i] !== player) continue;
                const r = Math.floor(i / SIZE);
                const c = i % SIZE;
                const d = Math.max(Math.abs(r - tr), Math.abs(c - tc));
                if (d === 1) adj1++;
                else if (d === 2) adj2++;
            }
            return { adj1, adj2 };
        }
        function evaluatePlacement(board, playerToEvaluate) {
            const opponent = 3 - playerToEvaluate;
            let score = 0;

            const playerPotentialMills = getPotentialMillsCount(board, playerToEvaluate);
            const opponentPotentialMills = getPotentialMillsCount(board, opponent);
            const playerDoubleMills = countDoubleMillSetups(board, playerToEvaluate);
            const opponentDoubleMills = countDoubleMillSetups(board, opponent);

            if (!variantConfig[variant].isInverseWin) {
                // --- NORMAL WIN LOGIC ---
                score += playerDoubleMills * 600;
                score -= opponentDoubleMills * 700;
                score += playerPotentialMills * 40;
                score -= opponentPotentialMills * 50;

                board.forEach((cell, idx) => {
                    if (cell === playerToEvaluate) {
                        if (STRATEGIC_CELLS.center.includes(idx)) score += 40;
                        if (STRATEGIC_CELLS.inner_corners.includes(idx)) score += 25;
                        if (STRATEGIC_CELLS.edge_centers.includes(idx)) score += 15;
                    } else if (cell === opponent) {
                        if (STRATEGIC_CELLS.center.includes(idx)) score -= 40;
                        if (STRATEGIC_CELLS.inner_corners.includes(idx)) score -= 25;
                    }
                });

            } else {
                // --- INVERSE WIN LOGIC (Učči Bessif) ---
                // Higher score = safer for inverse objective:
                // - avoid opening mills / double threats
                // - avoid the center / inner ring
                // - avoid clustering (including diagonals and distance-2)
                score -= playerPotentialMills * 650;
                score -= playerDoubleMills * 2600;

                // It's generally helpful (for losing pieces later) if the opponent has more mill potential.
                score += opponentPotentialMills * 90;
                score += opponentDoubleMills * 650;

                board.forEach((cell, idx) => {
                    if (cell === playerToEvaluate) {
                        // Strong avoidance of the center / inner ring.
                        if (isCenterCell(idx)) score -= 2200;
                        else if (isInInnerRing(idx)) score -= 1400;

                        // Avoid aggregation of own pieces (distance 1 & 2, incl. diagonals).
                        const aggSelf = getAggregationMetrics(board, idx, playerToEvaluate);
                        score -= aggSelf.adj1 * 950;
                        score -= aggSelf.adj2 * 420;

                        // Slight bonus if close to opponent pieces (easier to be captured later),
                        // but much smaller than the anti-aggregation penalty.
                        const aggOpp = getAggregationMetrics(board, idx, opponent);
                        score += aggOpp.adj1 * 80;
                    }
                });
            }
            return score;
        }

        function getPossibleMillMoves(player, board, phase) {
            const currentPhase = phase !== undefined ? phase : state.phase;
            const millMoves = [];
            if (currentPhase === 'placement') return [];
            for (let from = 0; from < SIZE * SIZE; from++) {
                if (board[from] === player) {
                    for (let to = 0; to < SIZE * SIZE; to++) {
                        if (board[to] === null && isAdjacent(from, to)) {
                            const tempBoard = simulateMove(board, {from, to}, player);
                            if (findAllMills(board, tempBoard, from, to, player).length > 0) {
                                millMoves.push({ from, to });
                            }
                        }
                    }
                }
            }
            return millMoves;
        }

        function makeAiMove() {
            if (state.winner) return;
            if (!state.captureMode) { moveHistory.push(deepCopy(state)); }
            if (state.captureMode) {
                const pieceToActOn = aiChoosePieceToActOn();
                if (pieceToActOn !== null) {
                    handleCapture(pieceToActOn);
                } else {
                    // No valid capture target (shouldn't happen, but prevent infinite captureMode lock)
                    state.captureMode = false;
                    state.turnForCapture = null;
                    state.pendingCaptures = 0;
                    state.highlightedMills = [];
                    endTurn();
                }
                return;
            }
            let move = aiFindBestMove();
            if (state.phase === 'placement') {
                if (move) { handlePlacement(move.to); } 
                else { state.winner = 3 - aiPlayerId; endGame(); } // use opponent ID, not humanPlayerId (spectator-safe)
            } else {
                if (!canPlayerMove(aiPlayerId, state.board)) { 
                    showStatusError('aiCannotMove');
                    state.winner = 3 - aiPlayerId; // use opponent ID, not humanPlayerId (spectator-safe)
                    endGame(); 
                    return; 
                }
                if (move) {
                    state.selected = move.from;
                    renderBoard(); 
                    setTimeout(() => { handleMove(move.to); }, 150);
                } else { 
                    state.winner = 3 - aiPlayerId; // use opponent ID, not humanPlayerId (spectator-safe)
                    endGame(); 
                }
            }
            setTimeout(() => saveGame(), 800);
        }
        
        function isPieceInPotentialMill(board, pieceIndex, player) {
            const potentialMillsBefore = getPotentialMillsCount(board, player);
            const tempBoard = [...board];
            tempBoard[pieceIndex] = null;
            const potentialMillsAfter = getPotentialMillsCount(tempBoard, player);
            return potentialMillsAfter < potentialMillsBefore;
        }

        function aiChoosePieceToActOn() {
            const isInverse = variantConfig[variant].isInverseWin;
            const playerToTarget = isInverse ? aiPlayerId : humanPlayerId;
            const possibleTargets = [];
            for (let i = 0; i < state.board.length; i++) {
                if (state.board[i] === playerToTarget) possibleTargets.push(i);
            }

            if (possibleTargets.length === 0) return null;
            if (aiDifficulty === 1) {
                return possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
            }

            let bestTarget = possibleTargets[0];

            // piecesPlaced = pieces on board + captured (total ever placed)
            const piecesPlacedSoFar = state.board.filter(p => p !== null).length + state.captured[1] + state.captured[2];

            if (isInverse) {
                // In Učči Bessif, AI chooses one of its OWN pieces to sacrifice.
                // Goal: maximize inverse evaluation (lose pieces, but avoid creating future forced-mill situations).
                __MINIMAX_TT.clear();

                let bestScore = -Infinity;
                for (const target of possibleTargets) {
                    const tempBoard = [...state.board];
                    tempBoard[target] = null;

                    const winner = getWinnerInState(tempBoard, 'move');
                    let score = evaluateBoard(tempBoard, aiPlayerId, winner, 'move');

                    // Prefer sacrificing pieces in the middle / inner ring and in clusters (reduces future mill threats).
                    if (isCenterCell(target)) score += 900;
                    else if (isInInnerRing(target)) score += 450;

                    const aggBefore = getAggregationMetrics(state.board, target, aiPlayerId);
                    score += aggBefore.adj1 * 120;
                    score += aggBefore.adj2 * 60;

                    // Optional shallow lookahead (kept small to remain fast)
                    if (aiDifficulty >= 3 && winner === null) {
                        const d = (aiDifficulty === 4) ? 2 : 1;
                        score += minimax(tempBoard, d, true, aiPlayerId, -Infinity, Infinity, piecesPlacedSoFar);
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = target;
                    }
                }
            } else {
                // Normal variant: capture the opponent piece that hurts them the most
                let bestScore = -Infinity;
                __MINIMAX_TT.clear();

                for (const target of possibleTargets) {
                    const tempBoard = [...state.board];
                    tempBoard[target] = null;
                    let score = 0;

                    const opponentMillsBefore = getFormedMillsCount(state.board, humanPlayerId);
                    const opponentMillsAfter = getFormedMillsCount(tempBoard, humanPlayerId);
                    if (opponentMillsAfter < opponentMillsBefore) score += 5000;

                    if (isPieceInPotentialMill(state.board, target, humanPlayerId)) score += 3500;

                    const opponentCanFormMillBefore = canPlayerFormMillNextTurn(humanPlayerId, state.board, 'move');
                    const opponentCanFormMillAfter = canPlayerFormMillNextTurn(humanPlayerId, tempBoard, 'move');
                    if (opponentCanFormMillBefore && !opponentCanFormMillAfter) score += 2500;

                    if (aiDifficulty >= 3) {
                        // Small minimax refinement
                        const d = (aiDifficulty === 4) ? 3 : aiDifficulty - 1;
                        score += minimax(tempBoard, d, false, humanPlayerId, -Infinity, Infinity, piecesPlacedSoFar);
                    } else {
                        score += evaluateBoard(tempBoard, aiPlayerId, null, 'move');
                    }

                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = target;
                    }
                }
            }

            return bestTarget;
        }

        function countDoubleMillSetups(board, player) {
            let hotSpots = {};
            const lines = [];
            for (let r = 0; r < SIZE; r++) { for (let c = 0; c < SIZE - 2; c++) { lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2]); } }
            for (let c = 0; c < SIZE; c++) { for (let r = 0; r < SIZE - 2; r++) { lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c]); } }

            for (const line of lines) {
                let pCount = 0;
                let emptyIdx = -1;
                for (const idx of line) {
                    if (board[idx] === player) pCount++;
                    else if (board[idx] === null) emptyIdx = idx;
                }
                if (pCount === 2 && emptyIdx !== -1) {
                    hotSpots[emptyIdx] = (hotSpots[emptyIdx] || 0) + 1;
                }
            }
            
            let doubleMillCount = 0;
            for (const spot in hotSpots) {
                if (hotSpots[spot] >= 2) {
                    doubleMillCount++;
                }
            }
            return doubleMillCount;
        }

        function evaluateBoard(board, playerToEvaluate, simulatedWinner, phase) {
            const opponent = 3 - playerToEvaluate;
            const currentPhase = phase !== undefined ? phase : state.phase;

            if (simulatedWinner !== null) {
                // Always from AI's perspective: higher is better for aiPlayerId (winner = +, loser = -)
                return simulatedWinner === playerToEvaluate ? 100000 : -100000;
            }

            const playerPieces = board.filter(p => p === playerToEvaluate).length;
            const opponentPieces = board.filter(p => p === opponent).length;
            const playerMoves = countPlayerMoves(playerToEvaluate, board, currentPhase);
            const opponentMoves = countPlayerMoves(opponent, board, currentPhase);

            let score = 0;
            score += (playerPieces - opponentPieces) * 200;
            score += (playerMoves - opponentMoves) * 60; 

            const playerMills = getFormedMillsCount(board, playerToEvaluate);
            const opponentMills = getFormedMillsCount(board, opponent);
            score += (playerMills - opponentMills) * 150;

            const playerPotentialMills = getPotentialMillsCount(board, playerToEvaluate);
            const opponentPotentialMills = getPotentialMillsCount(board, opponent);
            score += (playerPotentialMills - opponentPotentialMills) * 75;

            const playerDoubleMills = countDoubleMillSetups(board, playerToEvaluate);
            const opponentDoubleMills = countDoubleMillSetups(board, opponent);
            score += (playerDoubleMills - opponentDoubleMills) * 5000;

            if (canPlayerFormMillNextTurn(opponent, board, currentPhase)) score -= 1000;
            if (canPlayerFormMillNextTurn(playerToEvaluate, board, currentPhase)) score += 900;

            if (variantConfig[variant].isInverseWin) {
                // In inverse mode, fewer pieces and fewer moves are GOOD for AI => invert the "normal" score.
                score = -score;

                // Extra penalties: in Učči Bessif we want to AVOID creating mills (because it captures the opponent).
                score -= playerMills * 650;

                // Avoid center / inner ring + clustering in move phase too (lighter than placement heuristic).
                board.forEach((cell, idx) => {
                    if (cell === playerToEvaluate) {
                        if (isCenterCell(idx)) score -= 700;
                        else if (isInInnerRing(idx)) score -= 350;
                        const agg = getAggregationMetrics(board, idx, playerToEvaluate);
                        score -= agg.adj1 * 240;
                        score -= agg.adj2 * 120;
                    }
                });

                // Huge penalty if AI is currently forced to make a mill (forced-mill rule active and a mill move exists).
                if (variantConfig[variant].forceMillMove && currentPhase === 'move') {
                    const millMoves = getPossibleMillMoves(playerToEvaluate, board, currentPhase);
                    if (millMoves.length > 0) {
                        score -= 50000;
                    }
                }
            }

            return score;
        }

        function getFormedMillsCount(board, player) {
            const seen = new Set();
            let count = 0;
            for(let i=0; i < board.length; i++) {
                if(board[i] === player) {
                    const mills = getFormedMills(i, player, board);
                    for(const mill of mills) {
                        const key = mill.join(',');
                        if(!seen.has(key)) {
                            count++;
                            seen.add(key);
                        }
                    }
                }
            }
            return count;
        }
        
        function isGrouped(board, pieceIndex, player) {
            const r = Math.floor(pieceIndex / SIZE);
            const c = pieceIndex % SIZE;
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (const [dr, dc] of directions) {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
                    const neighborIndex = nr * SIZE + nc;
                    if (board[neighborIndex] === player) {
                        return true;
                    }
                }
            }
            return false;
        }

        function canPlayerFormMillByMoving(player, board) {
            for (let from = 0; from < SIZE * SIZE; from++) {
                if (board[from] === player) {
                    for (let to = 0; to < SIZE * SIZE; to++) {
                        if (board[to] === null && isAdjacent(from, to)) {
                            const tempBoard = simulateMove(board, {from, to}, player);
                            if (findAllMills(board, tempBoard, from, to, player).length > 0) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function canPlayerFormMillNextTurn(player, board, phase) {
            return getPossibleMillMoves(player, board, phase).length > 0;
        }

        function getPotentialMillsCount(board, player) {
            let count = 0;
            const lines = [];
            for (let r = 0; r < SIZE; r++) { for (let c = 0; c < SIZE - 2; c++) { lines.push([r*SIZE+c, r*SIZE+c+1, r*SIZE+c+2]); } }
            for (let c = 0; c < SIZE; c++) { for (let r = 0; r < SIZE - 2; r++) { lines.push([r*SIZE+c, (r+1)*SIZE+c, (r+2)*SIZE+c]); } }

            for (const line of lines) {
                let pCount = 0;
                let eCount = 0;
                for (const idx of line) { 
                    if (board[idx] === player) pCount++;
                    else if (board[idx] === null) eCount++; 
                }
                if (pCount === 2 && eCount === 1) {
                    // Ensure this window is not part of a longer line of player pieces (would form 4+ in a row, not a valid mill)
                    const isHorizontal = (Math.floor(line[0] / SIZE) === Math.floor(line[1] / SIZE));
                    let cellBefore = -1, cellAfter = -1;
                    if (isHorizontal) {
                        const r = Math.floor(line[0] / SIZE);
                        const cStart = line[0] % SIZE;
                        const cEnd = line[2] % SIZE;
                        if (cStart > 0) cellBefore = r * SIZE + (cStart - 1);
                        if (cEnd < SIZE - 1) cellAfter = r * SIZE + (cEnd + 1);
                    } else {
                        const c = line[0] % SIZE;
                        const rStart = Math.floor(line[0] / SIZE);
                        const rEnd = Math.floor(line[2] / SIZE);
                        if (rStart > 0) cellBefore = (rStart - 1) * SIZE + c;
                        if (rEnd < SIZE - 1) cellAfter = (rEnd + 1) * SIZE + c;
                    }
                    // Only count if the adjacent cells won't extend this to a 4+ chain
                    const beforeOk = cellBefore === -1 || board[cellBefore] !== player;
                    const afterOk = cellAfter === -1 || board[cellAfter] !== player;
                    if (beforeOk && afterOk) count++;
                }
            }
            return count;
        }

        

        // Minimax cache (cleared at each AI decision) to keep the AI responsive.
        const __MINIMAX_TT = new Map();
        function boardKeyFast(board) {
            let s = '';
            for (let i = 0; i < board.length; i++) {
                const v = board[i];
                s += (v === null) ? '0' : (v === 1 ? '1' : '2');
            }
            return s;
        }
        function minimax(currentBoard, depth, isMaximizingPlayer, currentPlayer, alpha, beta, piecesPlaced) {
            // piecesPlaced = total pieces ever placed (doesn't decrease on capture)
            const currentPiecesPlaced = piecesPlaced !== undefined ? piecesPlaced : (currentBoard.filter(p => p !== null).length + 0);
            const currentPhase = currentPiecesPlaced < PIECES * 2 ? 'placement' : 'move';

            // Transposition table
            const ttKey = `${depth}|${isMaximizingPlayer ? 1 : 0}|${currentPlayer}|${currentPiecesPlaced}|${boardKeyFast(currentBoard)}`;
            const cached = __MINIMAX_TT.get(ttKey);
            if (cached !== undefined) return cached;

            const simulatedWinner = getWinnerInState(currentBoard, currentPhase);
            if (depth === 0 || simulatedWinner !== null) {
                const leafVal = (currentPhase === 'placement')
                    ? evaluatePlacement(currentBoard, aiPlayerId)
                    : evaluateBoard(currentBoard, aiPlayerId, simulatedWinner, currentPhase);
                __MINIMAX_TT.set(ttKey, leafVal);
                return leafVal;
            }

            const opponentPlayer = 3 - currentPlayer;
            const possibleMoves = generateAllPossibleMoves(currentPlayer, currentBoard, currentPhase);
            if (possibleMoves.length === 0) {
                const noMoveVal = (currentPhase === 'placement')
                    ? evaluatePlacement(currentBoard, aiPlayerId)
                    : evaluateBoard(currentBoard, aiPlayerId, opponentPlayer, currentPhase);
                __MINIMAX_TT.set(ttKey, noMoveVal);
                return noMoveVal;
            }

            let bestEval = isMaximizingPlayer ? -Infinity : Infinity;

            for (const move of possibleMoves) {
                const newBoard = simulateMove(currentBoard, move, currentPlayer);
                const from = move.from !== undefined ? move.from : move.to;
                const formedMills = findAllMills(currentBoard, newBoard, from, move.to, currentPlayer);

                const nextPiecesPlaced = currentPhase === 'placement' ? currentPiecesPlaced + 1 : currentPiecesPlaced;

                let evaluation;

                if (formedMills.length > 0) {
                    // A capture happens. The piece that gets removed is ALWAYS from the opponent of the mover.
                    // In normal rules: the mover chooses which opponent piece to capture.
                    // In Učči Bessif: the opponent chooses which of THEIR OWN pieces will be captured.
                    const victim = opponentPlayer;
                    const chooser = variantConfig[variant].isInverseWin ? opponentPlayer : currentPlayer;
                    const chooserIsAI = chooser === aiPlayerId;

                    const capturablePieces = [];
                    for (let i = 0; i < newBoard.length; i++) {
                        if (newBoard[i] === victim) capturablePieces.push(i);
                    }

                    if (capturablePieces.length > 0) {
                        let captureEval = chooserIsAI ? -Infinity : Infinity;

                        for (const pieceToRemove of capturablePieces) {
                            const boardAfterCapture = [...newBoard];
                            boardAfterCapture[pieceToRemove] = null;

                            const val = minimax(
                                boardAfterCapture,
                                depth - 1,
                                !isMaximizingPlayer,
                                opponentPlayer,
                                alpha,
                                beta,
                                nextPiecesPlaced
                            );

                            if (chooserIsAI) captureEval = Math.max(captureEval, val);
                            else captureEval = Math.min(captureEval, val);
                        }

                        evaluation = captureEval;
                    } else {
                        evaluation = minimax(newBoard, depth - 1, !isMaximizingPlayer, opponentPlayer, alpha, beta, nextPiecesPlaced);
                    }
                } else {
                    evaluation = minimax(newBoard, depth - 1, !isMaximizingPlayer, opponentPlayer, alpha, beta, nextPiecesPlaced);
                }

                if (isMaximizingPlayer) {
                    bestEval = Math.max(bestEval, evaluation);
                    alpha = Math.max(alpha, bestEval);
                } else {
                    bestEval = Math.min(bestEval, evaluation);
                    beta = Math.min(beta, bestEval);
                }
                if (beta <= alpha) break;
            }

            __MINIMAX_TT.set(ttKey, bestEval);
            return bestEval;
        }

        function simulateMove(board, move, player) {
            const newBoard = [...board];
            if (move.from !== undefined) { 
                newBoard[move.from] = null;
            }
            newBoard[move.to] = player;
            return newBoard;
        }

        function generateAllPossibleMoves(player, board, phase) {
            const moves = [];
            if (phase === 'placement') {
                for (let i = 0; i < SIZE * SIZE; i++) {
                    if (board[i] === null) {
                        const tempBoard = simulateMove(board, { to: i }, player);
                        if (!formsForbiddenPlacementAlignment(i, player, tempBoard)) {
                            moves.push({ to: i });
                        }
                    }
                }
            } else {
                const millMoves = getPossibleMillMoves(player, board, phase);
                if (variantConfig[variant].forceMillMove && millMoves.length > 0) {
                    return millMoves;
                }
                for (let i = 0; i < SIZE * SIZE; i++) {
                    if (board[i] === player) {
                        for (let j = 0; j < SIZE * SIZE; j++) {
                            if (board[j] === null && isAdjacent(i, j)) {
                                moves.push({ from: i, to: j });
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function generateAllPossibleMovesOrdered(player, board, phase) {
            const moves = generateAllPossibleMoves(player, board, phase);
            if (phase !== 'move') return moves;
            const opponent = 3 - player;
            const millMoves = new Set();
            moves.forEach(m => {
                const tempB = simulateMove(board, m, player);
                if (findAllMills(board, tempB, m.from, m.to, player).length > 0) millMoves.add(JSON.stringify(m));
            });
            const opponentMillTargets = getPossibleMillMoves(opponent, board, 'move').map(m => m.to);
            const ordered = [], rest = [];
            moves.forEach(m => {
                if (millMoves.has(JSON.stringify(m))) ordered.unshift(m);
                else if (opponentMillTargets.includes(m.to)) ordered.push(m);
                else rest.push(m);
            });
            return [...ordered, ...rest];
        }

        function getWinnerInState(board, phase) {
            // Accept explicit phase to handle captures correctly (captures reduce piece count below PIECES*2 even in move phase)
            const currentPhase = phase !== undefined ? phase : (board.filter(p => p !== null).length >= PIECES * 2 ? 'move' : 'placement');
            if (currentPhase !== 'move') return null;

            const p1Pieces = board.filter(p => p === 1).length;
            const p2Pieces = board.filter(p => p === 2).length;
            const p1CanMove = canPlayerMove(1, board);
            const p2CanMove = canPlayerMove(2, board);
            
            const p1Loses = p1Pieces < 3 || !p1CanMove;
            const p2Loses = p2Pieces < 3 || !p2CanMove;
            
            if (variantConfig[variant].isInverseWin) { 
                // Inverse win: the player who "loses" (has <3 pieces or can't move) actually WINS
                if (p1Loses) return 1;
                if (p2Loses) return 2; 
            } else { 
                // Normal win: the player who causes the opponent to "lose" wins
                if (p1Loses) return 2;
                if (p2Loses) return 1;
            }
            return null;
        }

        function aiFindBestMove() {
            const player = aiPlayerId;
            const opponent = humanPlayerId;
            const currentPhase = state.phase;
            const isInverse = variantConfig[variant].isInverseWin;

            const cmpVec = (a, b) => {
                for (let i = 0; i < Math.min(a.length, b.length); i++) {
                    if (a[i] < b[i]) return -1;
                    if (a[i] > b[i]) return 1;
                }
                return 0;
            };

            // This hardcoded opening is only for the NORMAL win variant.
            if (!isInverse && aiDifficulty === 4 && currentPhase === 'placement') {
                const turnNumber = state.board.filter(p => p !== null).length;
                if (turnNumber < 2 && state.board[12] === null) {
                    return { to: 12 };
                }
                if (turnNumber < 4 && state.board[12] === aiPlayerId) {
                    const preferredCorners = [6, 8, 16, 18];
                    for (const corner of preferredCorners) {
                        if (state.board[corner] === null) return { to: corner };
                    }
                }
            }

            let possibleMoves = generateAllPossibleMoves(player, state.board, currentPhase);
            if (possibleMoves.length === 0) return null;

            // ── Règle : exclure le pion joué 3× de suite (sauf deadlock) ──
            possibleMoves = filterConsecutiveMoves(player, possibleMoves);

            // ===============================
            // Učči Bessif: anti-milieu + anti-agrégation + anti-moulins ouverts
            // ===============================
            if (isInverse) {
                const beforePotential = getPotentialMillsCount(state.board, player);
                const beforeDouble = countDoubleMillSetups(state.board, player);

                if (currentPhase === 'placement') {
                    const annotated = possibleMoves.map(move => {
                        const newBoard = simulateMove(state.board, move, player);
                        const afterPotential = getPotentialMillsCount(newBoard, player);
                        const afterDouble = countDoubleMillSetups(newBoard, player);

                        const inCenter = isCenterCell(move.to);
                        const inInnerRing = isInInnerRing(move.to);

                        const agg = getAggregationMetrics(newBoard, move.to, player);
                        const canMillSoon = canPlayerFormMillByMoving(player, newBoard);

                        const vec = [
                            canMillSoon ? 1 : 0,
                            afterDouble - beforeDouble,
                            afterPotential - beforePotential,
                            inCenter ? 1 : 0,
                            inInnerRing ? 1 : 0,
                            agg.adj1,
                            agg.adj2
                        ];

                        return {
                            move,
                            vec,
                            canMillSoon,
                            deltaPotential: afterPotential - beforePotential,
                            deltaDouble: afterDouble - beforeDouble,
                            inCenter,
                            inInnerRing,
                            agg1: agg.adj1,
                            agg2: agg.adj2
                        };
                    });

                    // Strict filter first
                    let candidates = annotated.filter(x =>
                        x.deltaPotential <= 0 &&
                        x.deltaDouble <= 0 &&
                        !x.canMillSoon &&
                        !x.inCenter &&
                        !x.inInnerRing &&
                        x.agg1 === 0 &&
                        x.agg2 === 0
                    );

                    if (candidates.length === 0) {
                        // Fallback: keep the safest "risk vector" moves
                        annotated.sort((a, b) => cmpVec(a.vec, b.vec));
                        const bestVec = annotated[0].vec;
                        candidates = annotated.filter(x => cmpVec(x.vec, bestVec) === 0);
                    }

                    possibleMoves = candidates.map(x => x.move);

                } else { // Move phase
                    const mustMakeMill = variantConfig[variant].forceMillMove &&
                        getPossibleMillMoves(player, state.board, 'move').length > 0;

                    const annotated = possibleMoves.map(move => {
                        const newBoard = simulateMove(state.board, move, player);
                        const afterPotential = getPotentialMillsCount(newBoard, player);
                        const afterDouble = countDoubleMillSetups(newBoard, player);

                        const inCenter = isCenterCell(move.to);
                        const inInnerRing = isInInnerRing(move.to);

                        const agg = getAggregationMetrics(newBoard, move.to, player);
                        const canMillSoon = canPlayerFormMillByMoving(player, newBoard);

                        // Encourage giving the opponent mill opportunities (they can force a sacrifice of our pieces).
                        const oppMillMoves = getPossibleMillMoves(opponent, newBoard, 'move').length;

                        const vec = [
                            mustMakeMill ? 0 : (canMillSoon ? 1 : 0),
                            afterDouble - beforeDouble,
                            afterPotential - beforePotential,
                            inCenter ? 1 : 0,
                            inInnerRing ? 1 : 0,
                            agg.adj1,
                            agg.adj2,
                            -oppMillMoves
                        ];

                        return {
                            move,
                            vec,
                            mustMakeMill,
                            canMillSoon,
                            deltaPotential: afterPotential - beforePotential,
                            deltaDouble: afterDouble - beforeDouble,
                            inCenter,
                            inInnerRing,
                            agg1: agg.adj1,
                            agg2: agg.adj2
                        };
                    });

                    let candidates = annotated.filter(x =>
                        !x.inCenter &&
                        !x.inInnerRing &&
                        x.agg1 === 0 &&
                        x.agg2 === 0 &&
                        (x.mustMakeMill || (x.deltaPotential <= 0 && x.deltaDouble <= 0 && !x.canMillSoon))
                    );

                    if (candidates.length === 0) {
                        annotated.sort((a, b) => cmpVec(a.vec, b.vec));
                        const bestVec = annotated[0].vec;
                        candidates = annotated.filter(x => cmpVec(x.vec, bestVec) === 0);
                    }

                    possibleMoves = candidates.map(x => x.move);
                }
            }

            // Normal variant: try to make a mill / block mills quickly in move phase
            if (currentPhase === 'move' && !isInverse) {
                const millMoves = getPossibleMillMoves(player, state.board, 'move');
                if (millMoves.length > 0) {
                    return millMoves[Math.floor(Math.random() * millMoves.length)];
                }
                const opponentMillMoves = getPossibleMillMoves(opponent, state.board, 'move');
                if (opponentMillMoves.length > 0) {
                    const blockingMoveTargets = opponentMillMoves.map(move => move.to);
                    const availableBlockingMoves = possibleMoves.filter(move => blockingMoveTargets.includes(move.to));
                    if (availableBlockingMoves.length > 0) {
                        return availableBlockingMoves[Math.floor(Math.random() * availableBlockingMoves.length)];
                    }
                }
            }

            if (aiDifficulty === 1) {
                return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }

            let depth = { 1: 1, 2: 2, 3: 4, 4: 5 }[aiDifficulty] || 2;
            if (currentPhase === 'placement' && depth > 4) depth = 4;
            if (aiDifficulty === 4 && state.phase === 'move' && state.board.filter(p => p !== null).length <= 10) {
                depth++;
            }

            // Clear cache each decision for responsiveness
            __MINIMAX_TT.clear();

            let bestMove = null;
            let bestScore = -Infinity;
            let alpha = -Infinity;
            let beta = Infinity;

            // piecesPlaced = pieces on board + captured (total ever placed)
            const piecesPlacedSoFar = state.board.filter(p => p !== null).length + state.captured[1] + state.captured[2];

            for (const move of possibleMoves) {
                const newBoard = simulateMove(state.board, move, player);
                const nextPiecesPlaced = currentPhase === 'placement' ? piecesPlacedSoFar + 1 : piecesPlacedSoFar;

                const score = minimax(newBoard, depth - 1, false, opponent, alpha, beta, nextPiecesPlaced);

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                    alpha = Math.max(alpha, bestScore);
                }
            }

            return bestMove || possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        }

        // ==========================================
        // ===== NEW FEATURES: SOUND, THEME, SAVE, SPECTATOR, AI+ =====
        // ==========================================

        // --- GLOBALS ---
        let soundEnabled = true;
        const THEMES = ['kabylie', 'desert', 'nuit', 'glass', 'contrast', 'modern', 'modern-dark'];
        const THEME_ICONS = ['ⵣ', '🏜️', '🌙', '💎', '⚡', '✨', '🌑'];
        let currentTheme = THEMES.indexOf('kabylie'); // default: kabylie
        let moveLog = []; // for move history log
        let spectatorDelay = 700;

        // --- IMPROVED SOUND SYSTEM (Web Audio API with dynamics + reverb) ---
        let __audio = null;

        function ensureAudioGraph() {
            const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
            if (!AudioContextCtor) return null;
            if (__audio?.ctx) return __audio;
            const ctx = new AudioContextCtor();
            const master = ctx.createGain();
            master.gain.value = 0.85;
            const compressor = ctx.createDynamicsCompressor();
            compressor.threshold.value = -22;
            compressor.knee.value = 24;
            compressor.ratio.value = 10;
            compressor.attack.value = 0.004;
            compressor.release.value = 0.18;
            const delayNode = ctx.createDelay(0.35);
            delayNode.delayTime.value = 0.16;
            const feedback = ctx.createGain();
            feedback.gain.value = 0.18;
            const wet = ctx.createGain();
            wet.gain.value = 0.16;
            delayNode.connect(feedback);
            feedback.connect(delayNode);
            delayNode.connect(wet);
            master.connect(compressor);
            wet.connect(compressor);
            compressor.connect(ctx.destination);
            __audio = { ctx, master, wetSend: delayNode, wetGain: wet };
            return __audio;
        }

        function audioNow() {
            const a = ensureAudioGraph();
            return a ? a.ctx.currentTime : 0;
        }

        function audioEnv(gainNode, t0, a=0.005, d=0.09, s=0.0, r=0.12, peak=0.6) {
            const g = gainNode.gain;
            g.cancelScheduledValues(t0);
            g.setValueAtTime(0.0001, t0);
            g.exponentialRampToValueAtTime(Math.max(0.0002, peak), t0 + a);
            g.exponentialRampToValueAtTime(Math.max(0.0002, peak * Math.max(0.001, s)), t0 + a + d);
            g.exponentialRampToValueAtTime(0.0001, t0 + a + d + r);
        }

        function addNoiseBurst(t0, duration=0.08, peak=0.35) {
            const a = ensureAudioGraph(); if (!a) return;
            const ctx = a.ctx;
            const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * duration), ctx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
            const src = ctx.createBufferSource();
            src.buffer = buf;
            const filt = ctx.createBiquadFilter();
            filt.type = 'highpass';
            filt.frequency.value = 700;
            const g = ctx.createGain();
            src.connect(filt); filt.connect(g); g.connect(a.master); g.connect(a.wetSend);
            audioEnv(g, t0, 0.001, 0.03, 0.0, 0.08, peak);
            src.start(t0); src.stop(t0 + duration + 0.02);
        }

        function audioTone(t0, f0, duration=0.11, type='sine', peak=0.35, pan=0) {
            const a = ensureAudioGraph(); if (!a) return;
            const ctx = a.ctx;
            const osc = ctx.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(f0, t0);
            const filt = ctx.createBiquadFilter();
            filt.type = 'lowpass';
            filt.frequency.setValueAtTime(Math.min(6000, Math.max(900, f0*6)), t0);
            const g = ctx.createGain();
            const p = ctx.createStereoPanner ? ctx.createStereoPanner() : null;
            if (p) p.pan.setValueAtTime(pan, t0);
            osc.connect(filt); filt.connect(g);
            if (p) { g.connect(p); p.connect(a.master); p.connect(a.wetSend); }
            else { g.connect(a.master); g.connect(a.wetSend); }
            audioEnv(g, t0, 0.004, duration*0.35, 0.12, duration*0.6, peak);
            osc.start(t0); osc.stop(t0 + duration + 0.04);
        }

        function audioChord(t0, freqs, duration=0.22) {
            freqs.forEach((f, i) => audioTone(t0 + i*0.03, f, duration, 'triangle', 0.32, (i-1)*0.25));
        }

        function playSound(type) {
            if (!soundEnabled) return;
            try {
                const a = ensureAudioGraph(); if (!a) return;
                if (a.ctx.state === 'suspended') a.ctx.resume();
                const t0 = audioNow();
                switch (type) {
                    case 'place':
                        audioTone(t0, 420, 0.09, 'sine', 0.24, -0.12);
                        audioTone(t0+0.04, 650, 0.07, 'sine', 0.18, 0.12);
                        break;
                    case 'move':
                        audioTone(t0, 360, 0.08, 'triangle', 0.18, -0.08);
                        audioTone(t0+0.06, 520, 0.09, 'triangle', 0.15, 0.08);
                        break;
                    case 'select':
                        audioTone(t0, 700, 0.06, 'sine', 0.12, 0);
                        break;
                    case 'undo':
                        audioTone(t0, 520, 0.07, 'sine', 0.14, 0);
                        audioTone(t0+0.08, 360, 0.09, 'sine', 0.12, 0);
                        break;
                    case 'mill':
                        audioChord(t0, [523.25, 659.25, 783.99], 0.22);
                        break;
                    case 'capture':
                        addNoiseBurst(t0, 0.07, 0.38);
                        audioTone(t0+0.02, 220, 0.12, 'sawtooth', 0.14, 0);
                        break;
                    case 'victory':
                        audioChord(t0, [392.0, 523.25, 659.25], 0.28);
                        audioChord(t0+0.22, [440.0, 587.33, 739.99], 0.30);
                        break;
                    case 'phase':
                        audioTone(t0, 330, 0.14, 'triangle', 0.16, -0.15);
                        audioTone(t0+0.10, 550, 0.14, 'triangle', 0.16, 0.15);
                        break;
                    case 'error':
                        audioTone(t0, 180, 0.14, 'sawtooth', 0.10, 0);
                        addNoiseBurst(t0+0.03, 0.09, 0.22);
                        break;
                    default:
                        audioTone(t0, 440, 0.06, 'sine', 0.08, 0);
                }
            } catch (e) { /* silently ignore audio errors */ }
        }

        // --- THEME SYSTEM ---
        function applyTheme(themeIndex) {
            const theme = THEMES[themeIndex] || 'kabylie';
            document.documentElement.setAttribute('data-theme', theme);
            const btn = document.getElementById('theme-btn');
            if (btn) {
                const thLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnTheme) || 'Thème';
                btn.innerHTML = (THEME_ICONS[themeIndex] || 'ⵣ') + ' <span style="font-size:0.78rem;" data-i18n="btnTheme">' + thLabel + '</span>';
            }
            try { localStorage.setItem('tiddas_theme', String(themeIndex)); } catch(e){}
        }
        function cycleTheme() {
            currentTheme = (currentTheme + 1) % THEMES.length;
            applyTheme(currentTheme);
        }

        // --- SOUND TOGGLE ---
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            if (btn) {
                const sndLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnSound) || 'Son';
                btn.innerHTML = (soundEnabled ? '🔊 ' : '🔇 ') + '<span style="font-size:0.78rem;" data-i18n="btnSound">' + sndLabel + '</span>';
                btn.classList.toggle('sound-off', !soundEnabled);
            }
            try { localStorage.setItem('tiddas_sound', soundEnabled ? '1' : '0'); } catch(e){}
        }

        // --- SAVE / LOAD GAME (localStorage) ---
        const SAVE_KEY = 'tiddas_save_v2';
        function saveGame() {
            if (!state || state.winner || gameMode === 'spectator') return;
            try {
                const save = { state, variant, gameMode, aiDifficulty, humanPlayerId, player1Name, player2Name, moveLog: moveLog.slice(-20) };
                localStorage.setItem(SAVE_KEY, JSON.stringify(save));
            } catch (e) {}
        }
        function clearSave() {
            try { localStorage.removeItem(SAVE_KEY); } catch(e){}
        }
        
        function loadAndResume() {
            try {
                const raw = localStorage.getItem(SAVE_KEY);
                if (!raw) return;
                const save = JSON.parse(raw);

                // Restore meta
                variant = save.variant || variant;
                gameMode = save.gameMode || gameMode;
                aiDifficulty = (save.aiDifficulty ?? aiDifficulty);
                humanPlayerId = (save.humanPlayerId ?? humanPlayerId);
                aiPlayerId = gameMode === 'ai' ? (3 - humanPlayerId) : null;
                player1Name = save.player1Name || player1Name;
                player2Name = save.player2Name || player2Name;

                // Restore state with forward-compatible defaults (prevents broken saves after updates)
                const defaults = initState();
                const s = save.state || {};
                const merged = {
                    ...defaults,
                    ...s,
                    counts: { ...defaults.counts, ...(s.counts || {}) },
                    captured: { ...defaults.captured, ...(s.captured || {}) }
                };

                // Sanitize board size/content
                if (!Array.isArray(merged.board)) merged.board = defaults.board.slice();
                if (merged.board.length !== SIZE * SIZE) {
                    const fixed = Array(SIZE * SIZE).fill(null);
                    const src = merged.board;
                    for (let i = 0; i < Math.min(src.length, fixed.length); i++) fixed[i] = (src[i] === 1 || src[i] === 2) ? src[i] : null;
                    merged.board = fixed;
                } else {
                    // normalize values
                    merged.board = merged.board.map(v => (v === 1 || v === 2) ? v : null);
                }

                // Sanitize primitive fields
                merged.turn = (merged.turn === 1 || merged.turn === 2) ? merged.turn : defaults.turn;
                merged.phase = (merged.phase === 'placement' || merged.phase === 'move') ? merged.phase : defaults.phase;
                merged.captureMode = !!merged.captureMode;
                merged.pendingCaptures = Number.isFinite(merged.pendingCaptures) ? merged.pendingCaptures : 0;
                merged.turnForCapture = (merged.turnForCapture === 1 || merged.turnForCapture === 2) ? merged.turnForCapture : null;
                merged.selected = Number.isInteger(merged.selected) ? merged.selected : null;
                merged.highlightedMills = Array.isArray(merged.highlightedMills) ? merged.highlightedMills : [];
                merged.winner = (merged.winner === 1 || merged.winner === 2) ? merged.winner : null;

                state = merged;

                moveLog = Array.isArray(save.moveLog) ? save.moveLog : [];
                moveHistory = [];
                clearSave();
                hideSaveNotification();
                updateGameInfoDisplay();
                showScreen('game-play-area');
                renderAll();
                renderMoveLog();
                triggerNextAction();
            } catch(e) { clearSave(); }
        }

        function checkForSavedGame() {
            try {
                const raw = localStorage.getItem(SAVE_KEY);
                if (raw) {
                    const save = JSON.parse(raw);
                    if (save && save.state && !save.state.winner) {
                        showSaveNotification();
                    } else { clearSave(); }
                }
            } catch(e) { clearSave(); }
        }
        function showSaveNotification() {
            const notif = document.getElementById('save-notification');
            document.getElementById('save-notification-text').textContent = t('savedGameFound', 'Partie sauvegardée. Reprendre ?');
            const _br = document.getElementById('btn-resume');
            if (_br) _br.textContent = translations[currentLanguage].btnResume || 'Reprendre';
            const _bd = document.getElementById('btn-discard');
            if (_bd) _bd.textContent = translations[currentLanguage].btnDiscard || 'Non';
            notif.classList.add('visible');
        }
        function hideSaveNotification() {
            document.getElementById('save-notification').classList.remove('visible');
        }

        // --- MOVE HISTORY LOG ---
        function addMoveLog(entry) {
            moveLog.push(entry);
            if (moveLog.length > 60) moveLog.shift();
            renderMoveLog();
        }
        function renderMoveLog() {
            const list = document.getElementById('move-log-list');
            if (!list) return;
            list.innerHTML = '';
            const recent = moveLog.slice(-12);
            recent.forEach(entry => {
                const el = document.createElement('div');
                el.className = `move-log-entry${entry.mill ? ' mill-entry' : ''}${entry.capture ? ' capture-entry' : ''}`;
                const dot = document.createElement('div');
                dot.className = `log-stone p${entry.player}`;
                el.appendChild(dot);
                const txt = document.createElement('span');
                txt.textContent = entry.text;
                el.appendChild(txt);
                list.appendChild(el);
            });
            list.scrollTop = list.scrollHeight;
        }
        function clearMoveLog() { moveLog = []; renderMoveLog(); }

        // --- SPECTATOR MODE ---
        let spectatorIntervalId = null;
        function startSpectatorGame() {
            gameMode = 'spectator';
            aiDifficulty = aiDifficulty || 3;
            humanPlayerId = 0; // No human
            aiPlayerId = 1; // Will alternate
            player1Name = translations[currentLanguage].defaultComputerName + ' N';
            player2Name = translations[currentLanguage].defaultComputerName + ' B';
            moveLog = [];
            state = initState();
            moveHistory = [];
            updateGameInfoDisplay();
            showScreen('game-play-area');
            document.getElementById('spectator-badge').classList.add('visible');
            document.getElementById('spectator-controls').classList.add('visible');
            document.getElementById('undo-btn').disabled = true;
            document.getElementById('surrender').disabled = true;
            renderAll();
            renderMoveLog();
            triggerNextAction();
        }
        function stopSpectatorMode() {
            document.getElementById('spectator-badge').classList.remove('visible');
            document.getElementById('spectator-controls').classList.remove('visible');
        }

        // ==========================================
        

        // --- ANIMATIONS ---
        function animateStonePlacement(idx, player) {
            playSound('place');
            const row = Math.floor(idx/SIZE)+1, col = idx%SIZE+1;
            addMoveLog({ player, text: `[${row},${col}]` });
            const cell = boardDiv.children[idx], stone = document.createElement('div');
            stone.className = `stone player${player} moving`;
            cell.appendChild(stone);
            stone.addEventListener('animationend', () => { stone.classList.remove('moving'); }, { once: true });
        }
        function animateStoneMove(fromIdx, toIdx) {
            playSound('move');
            const row = Math.floor(fromIdx/SIZE)+1, col = fromIdx%SIZE+1;
            const toRow = Math.floor(toIdx/SIZE)+1, toCol = toIdx%SIZE+1;
            const mover = state.board[fromIdx];
            addMoveLog({ player: state.turn, text: `[${row},${col}] → [${toRow},${toCol}]` });
            const stone = boardDiv.children[fromIdx].querySelector('.stone');
            if (stone) { stone.classList.add('fade-out'); stone.addEventListener('animationend', () => {}, { once: true }); }
        }
        function animateStoneCapture(idx) {
            const stone = boardDiv.children[idx].querySelector('.stone');
            if (stone) { stone.classList.add('captured'); stone.addEventListener('animationend', () => {}, { once: true }); }
        }


    // ============================================================
    // === MODULES ADDITIONNELS (stats, replay, a11y, guided, install) ===
    // ============================================================
  // Helpers supplémentaires ($ et $$ déjà définis en haut du scope)

  const clone = (obj) => {
    try { return (typeof deepCopy === 'function') ? deepCopy(obj) : JSON.parse(JSON.stringify(obj)); }
    catch(_) { return obj; }
  };

  // i18n helper
  const t = (key, fallback) => {
    try {
      const lang = currentLanguage || 'fr';
      return (translations && translations[lang] && translations[lang][key]) || fallback || key;
    } catch(_) {
      return fallback || key;
    }
  };

  // Expose i18n helper globally (used by save/resume banner and other UI)
  try { if (!t) t = t; } catch(_) {}


  // ---------------------------------------------------------

  // 2) Toast
  // ---------------------------------------------------------
  const toastEl = $('#toast');
  let toastTimer = null;
  function showToast(message, ms = 2200) {
    if (!toastEl) return;
    setSafeHTML(toastEl, String(message ?? ''));
    toastEl.classList.add('show');
    window.clearTimeout(toastTimer);
    toastTimer = window.setTimeout(() => toastEl.classList.remove('show'), ms);
  }

  // ---------------------------------------------------------
  // 3) Pack Produit – Stats
  // ---------------------------------------------------------
  const STATS_KEY = 'tiddas_stats_v1';
  const REPLAY_KEY = 'tiddas_last_replay_v1';

  function defaultStats() {
    return {
      v: 1,
      createdAt: nowMs(),
      updatedAt: nowMs(),
      games: 0,
      wins: 0,
      losses: 0,
      winsHuman: 0,
      lossesHuman: 0,
      p1Wins: 0,
      p2Wins: 0,
      moves: 0,
      captures: 0,
      mills: 0,
      streak: 0,
      bestStreak: 0,
      xp: 0,
      level: 1,
      achievements: {}
    };
  }

  let stats = defaultStats();

  function loadStats() {
    try {
      const raw = localStorage.getItem(STATS_KEY);
      const parsed = raw ? safeJSONParse(raw, null) : null;
      if (parsed && typeof parsed === 'object' && parsed.v === 1) {
        stats = Object.assign(defaultStats(), parsed);
      } else {
        stats = defaultStats();
      }
    } catch(_) {
      stats = defaultStats();
    }
    stats.level = computeLevel(stats.xp);
  }

  function saveStats() {
    try {
      stats.updatedAt = nowMs();
      localStorage.setItem(STATS_KEY, JSON.stringify(stats));
    } catch(_) {}
  }

  function computeLevel(xp) {
    const x = Math.max(0, Number(xp) || 0);
    return Math.max(1, Math.floor(x / 100) + 1);
  }

  function levelProgress(xp) {
    const x = Math.max(0, Number(xp) || 0);
    const level = computeLevel(x);
    const base = (level - 1) * 100;
    const into = x - base;
    const pct = clamp((into / 100) * 100, 0, 100);
    return { level, into, pct, nextAt: level * 100 };
  }

  // Session counters for current game (reset at startGame)
  let session = {
    active: false,
    startAt: 0,
    moves: 0,
    captures: 0,
    mills: 0,
    mode: null,
    variant: null,
    difficulty: null,
    winner: null
  };

  function resetSession() {
    session = {
      active: true,
      startAt: nowMs(),
      moves: 0,
      captures: 0,
      mills: 0,
      mode: gameMode || null,
      variant: variant || null,
      difficulty: aiDifficulty || null,
      winner: null
    };
  }

  // ---------------------------------------------------------
  // 4) Pack Gameplay – Replay timeline & last-move highlighting
  // ---------------------------------------------------------
  const replay = {
    active: false,
    frames: [],
    sigs: [],
    idx: 0,
    timer: null,
    backup: null,
    data: null
  };

  let prevBoardForDelta = null;
  let lastDelta = { from: null, to: null, capture: null };

  function computeDelta(oldB, newB) {
    const diff = [];
    for (let i = 0; i < newB.length; i++) {
      if (oldB[i] !== newB[i]) diff.push(i);
    }
    const d = { from: null, to: null, capture: null };
    if (diff.length === 1) {
      const i = diff[0];
      if (oldB[i] != null && newB[i] == null) d.capture = i;
      else if (oldB[i] == null && newB[i] != null) d.to = i;
    } else if (diff.length === 2) {
      const [a, b] = diff;
      if (oldB[a] != null && newB[a] == null && oldB[b] == null && newB[b] != null) { d.from = a; d.to = b; }
      else if (oldB[b] != null && newB[b] == null && oldB[a] == null && newB[a] != null) { d.from = b; d.to = a; }
    }
    return d;
  }

  function sigProgress(s) {
    const b = Array.isArray(s?.board) ? s.board.map(v => v || 0).join('') : '';
    const counts = s?.counts ? `${s.counts[1] ?? 0},${s.counts[2] ?? 0}` : '';
    const captured = s?.captured ? `${s.captured[1] ?? 0},${s.captured[2] ?? 0}` : '';
    return [
      b,
      s?.phase || '',
      s?.turn || 0,
      s?.captureMode ? 1 : 0,
      s?.turnForCapture || 0,
      counts,
      captured,
      s?.pendingCaptures || 0,
      s?.winner || 0
    ].join('|');
  }

  function minifyState(s) {
    return {
      board: Array.isArray(s.board) ? [...s.board] : [],
      phase: s.phase,
      turn: s.turn,
      turnForCapture: s.turnForCapture,
      counts: { 1: s.counts?.[1] ?? 0, 2: s.counts?.[2] ?? 0 },
      captured: { 1: s.captured?.[1] ?? 0, 2: s.captured?.[2] ?? 0 },
      selected: null,
      captureMode: !!s.captureMode,
      winner: s.winner ?? null,
      highlightedMills: Array.isArray(s.highlightedMills) ? [...s.highlightedMills] : [],
      pendingCaptures: s.pendingCaptures ?? 0,
      consecutivePiece: s.consecutivePiece ? { ...s.consecutivePiece } : { 1: null, 2: null },
      consecutiveCount: s.consecutiveCount ? { ...s.consecutiveCount } : { 1: 0, 2: 0 }
    };
  }

  function pushReplayFrame() {
    if (replay.active) return;
    const s = state;
    if (!s || !Array.isArray(s.board)) return;
    const sig = sigProgress(s);
    if (replay.sigs.length === 0 || replay.sigs[replay.sigs.length - 1] !== sig) {
      replay.frames.push(minifyState(s));
      replay.sigs.push(sig);
      if (replay.frames.length > 320) {
        replay.frames.shift();
        replay.sigs.shift();
      }
    }
  }

  // ---------------------------------------------------------
  // 5) Pack UI/UX – A11y keyboard navigation (roving tabindex)
  // ---------------------------------------------------------
  let focusIdx = 0;

  function applyA11y() {
    const bd = boardDiv;
    const s = state;
    if (!bd || !s || !Array.isArray(s.board)) return;

    bd.setAttribute('role', 'grid');
    bd.setAttribute('aria-label', t('boardAria', 'Plateau de jeu'));

    const cells = bd.children;
    if (!cells || !cells.length) return;

    // Clamp focus index
    focusIdx = clamp(focusIdx, 0, cells.length - 1);

    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      cell.setAttribute('role', 'gridcell');
      cell.setAttribute('tabindex', i === focusIdx ? '0' : '-1');

      const r = Math.floor(i / 5) + 1;
      const c = (i % 5) + 1;

      let occ = t('cellEmpty', 'vide');
      if (s.board[i] === 1) occ = (player1Name || 'J1');
      else if (s.board[i] === 2) occ = (player2Name || 'J2');

      cell.setAttribute('aria-label', `${t('cellLabel', 'Case')} ${r},${c} : ${occ}`);
    }
  }

  function onBoardKeyDown(e) {
    if (replay.active) return;

    const k = e.key;
    let next = focusIdx;

    if (k === 'ArrowLeft') next = focusIdx - 1;
    else if (k === 'ArrowRight') next = focusIdx + 1;
    else if (k === 'ArrowUp') next = focusIdx - 5;
    else if (k === 'ArrowDown') next = focusIdx + 5;
    else if (k === 'Home') next = Math.floor(focusIdx / 5) * 5;
    else if (k === 'End') next = Math.floor(focusIdx / 5) * 5 + 4;
    else if (k === 'Enter' || k === ' ') {
      e.preventDefault();
      try { onCellClick?.(focusIdx); } catch(_) {}
      return;
    } else {
      return;
    }

    e.preventDefault();
    next = clamp(next, 0, 24);
    focusIdx = next;
    applyA11y();
    try { boardDiv.children[focusIdx]?.focus?.(); } catch(_) {}
  }

  function attachBoardA11yOnce() {
    const bd = boardDiv;
    if (!bd || bd.__tiddasA11yAttached) return;
    bd.__tiddasA11yAttached = true;
    bd.addEventListener('keydown', onBoardKeyDown);
  }

  // ---------------------------------------------------------
  // 6) Apply highlights + guided hints (post-render)
  // ---------------------------------------------------------
  const guidedBtn = $('#guided-btn');
  let guidedMode = true;
  try {
    const saved = localStorage.getItem('tiddas_guided');
    if (saved !== null) guidedMode = saved === '1';
  } catch(_) {}

  function applyGuidedBtn() {
    if (!guidedBtn) return;
    guidedBtn.classList.toggle('active', guidedMode);
    guidedBtn.setAttribute('aria-pressed', String(guidedMode));
    guidedBtn.title = guidedMode ? t('guidedMode', 'Guidé') : t('guidedMode', 'Guidé');
    guidedBtn.setAttribute('aria-label', t('guidedMode', 'Guidé'));
  }

  function setGuidedMode(on) {
    guidedMode = !!on;
    try { localStorage.setItem('tiddas_guided', guidedMode ? '1' : '0'); } catch(_) {}
    applyGuidedBtn();
    try { renderAll?.(); } catch(_) {}
  }

  if (guidedBtn) {
    guidedBtn.addEventListener('click', () => setGuidedMode(!guidedMode));
    applyGuidedBtn();
  }

  function applyHighlightsAndHints() {
    const bd = boardDiv;
    if (!bd) return;
    const cells = bd.children;
    if (!cells || !cells.length) return;

    // Clear previous
    for (let i = 0; i < cells.length; i++) {
      cells[i].classList.remove('last-move-from', 'last-move-to', 'last-capture');
      const st = cells[i].querySelector('.stone');
      if (st) st.classList.remove('hint-piece');
    }

    // Apply last action
    if (lastDelta.from != null && cells[lastDelta.from]) cells[lastDelta.from].classList.add('last-move-from');
    if (lastDelta.to != null && cells[lastDelta.to]) cells[lastDelta.to].classList.add('last-move-to');
    if (lastDelta.capture != null && cells[lastDelta.capture]) cells[lastDelta.capture].classList.add('last-capture');

    // Guided hints
    if (!guidedMode || replay.active) return;
    const s = state;
    if (!s || s.winner) return;
    if (gameMode === 'spectator') return;

    const acting = s.captureMode ? s.turnForCapture : s.turn;
    if (gameMode === 'ai' && acting !== humanPlayerId) return;

    if (s.captureMode) {
      // capturable already marked; pulse the stones in capturable cells
      for (let i = 0; i < s.board.length; i++) {
        if (!cells[i].classList.contains('capturable')) continue;
        const st = cells[i].querySelector('.stone');
        if (st) st.classList.add('hint-piece');
      }
    } else if (s.phase === 'move' && s.selected == null) {
      // Pulse selectable pieces
      for (let i = 0; i < s.board.length; i++) {
        if (s.board[i] === acting) {
          const st = cells[i].querySelector('.stone');
          if (st) st.classList.add('hint-piece');
        }
      }
    }
  }

  // ---------------------------------------------------------
  // 7) Patch core functions (renderAll / onCellClick / undo / endGame / startGame)
  // ---------------------------------------------------------
  if (typeof renderAll === 'function') {
    const __origRenderAll = renderAll;
    renderAll = function(...args) {
      try {
        attachBoardA11yOnce();

        // Delta tracking + session counters (skip during replay)
        if (!replay.active && state && Array.isArray(state.board)) {
          const newB = state.board;
          if (prevBoardForDelta) {
            lastDelta = computeDelta(prevBoardForDelta, newB);

            if (session.active) {
              if (lastDelta.from != null || lastDelta.to != null) session.moves += 1;
              if (lastDelta.capture != null) session.captures += 1;
            }
          }
          prevBoardForDelta = [...newB];
        } else if (replay.active && state && Array.isArray(state.board)) {
          // keep baseline coherent while replaying
          prevBoardForDelta = [...state.board];
        }
      } catch(_) {}

      const r = __origRenderAll.apply(this, args);

      try {
        applyA11y();
        pushReplayFrame();
        applyHighlightsAndHints();
      } catch(_) {}

      return r;
    };
  }

  // Count mills via ephemeral messages
  try {
    if (typeof showEphemeralBubbleMessage === 'function') {
      const __origEph = showEphemeralBubbleMessage;
      showEphemeralBubbleMessage = function(messageKey, iconClass, duration) {
        try {
          if (!replay.active && session.active && messageKey === 'ephemeralMill') {
            session.mills += 1;
          }
        } catch(_) {}
        return __origEph.call(this, messageKey, iconClass, duration);
      };
    }
  } catch(_) {}

  // Prevent interaction while replaying
  if (typeof onCellClick === 'function') {
    const __origOnCellClick = onCellClick;
    onCellClick = function(i) {
      if (replay.active) return;
      return __origOnCellClick.call(this, i);
    };
  }

  // Undo should also rewind replay timeline if possible
  if (typeof handleUndo === 'function') {
    const __origUndo = handleUndo;
    handleUndo = function(...args) {
      const r = __origUndo.apply(this, args);
      try {
        const curSig = sigProgress(state);
        const idx = replay.sigs.lastIndexOf(curSig);
        if (idx >= 0) {
          replay.frames = replay.frames.slice(0, idx + 1);
          replay.sigs = replay.sigs.slice(0, idx + 1);
        } else {
          replay.frames = [minifyState(state)];
          replay.sigs = [curSig];
        }
        showToast(t('toastReplayReady', '⏯️ Replay prêt.'), 1200);
      } catch(_) {}
      return r;
    };
  }

  // Reset replay + session before starting any new game
  if (typeof startGame === 'function') {
    const __origStartGame = startGame;
    startGame = function(...args) {
      try {
        replay.frames = [];
        replay.sigs = [];
        prevBoardForDelta = null;
        lastDelta = { from: null, to: null, capture: null };
        resetSession();
      } catch(_) {}
      return __origStartGame.apply(this, args);
    };
  }

  // Spectator: do not track stats
  if (typeof startSpectatorGame === 'function') {
    const __origStartSpectator = startSpectatorGame;
    startSpectatorGame = function(...args) {
      try {
        session.active = false;
        replay.frames = [];
        replay.sigs = [];
      } catch(_) {}
      return __origStartSpectator.apply(this, args);
    };
  }

  // Persist stats + replay at game end
  if (typeof endGame === 'function') {
    const __origEndGame = endGame;
    endGame = function(...args) {
      try {
        // Ensure final frame is captured (includes winner)
        pushReplayFrame();
        finalizeSessionAndStats();
        persistLastReplay();
        refreshReplayButtons();
      } catch(e) {
        console.warn(e);
      }
      return __origEndGame.apply(this, args);
    };
  }


  // Persist stats + replay on surrender as well (surrender does not call endGame)
  if (typeof handleSurrender === 'function') {
    const __origHandleSurrender = handleSurrender;
    handleSurrender = function(...args) {
      const r = __origHandleSurrender.apply(this, args);
      try {
        pushReplayFrame();
        finalizeSessionAndStats();
        persistLastReplay();
        refreshReplayButtons();
      } catch(_) {}
      return r;
    };
  }

  // ---------------------------------------------------------
  // 8) Finalize stats + replay persistence
  // ---------------------------------------------------------
  function finalizeSessionAndStats() {
    if (!session.active) return;
    if (gameMode === 'spectator') return;
    if (!state) return;
    if (!state.winner) return;

    session.active = false;
    session.winner = state.winner;

    // Aggregate totals
    stats.games += 1;
    stats.moves += session.moves;
    stats.captures += session.captures;
    stats.mills += session.mills;

    // Determine win/loss (AI mode only)
    if (gameMode === 'ai') {
      const human = humanPlayerId;
      if (session.winner === human) {
        stats.wins += 1;
        stats.winsHuman += 1;
        stats.streak += 1;
        stats.bestStreak = Math.max(stats.bestStreak, stats.streak);
        stats.xp += 25 + Math.min(40, session.moves);
        if (aiDifficulty === 4) stats.achievements.beatExpert = true;
      } else {
        stats.losses += 1;
        stats.lossesHuman += 1;
        stats.streak = 0;
        stats.xp += 10 + Math.min(25, session.moves);
      }
    } else if (gameMode === 'local') {
      // Two-player local: only track per-player wins, not global wins/losses
      // (wins/losses are AI-mode concepts; for local, see p1Wins/p2Wins)
      if (session.winner === 1) stats.p1Wins += 1;
      if (session.winner === 2) stats.p2Wins += 1;
      stats.xp += 12 + Math.min(30, session.moves);
    } else {
      // Other modes: count as games only
      stats.xp += 8 + Math.min(20, session.moves);
    }

    // Achievements (simple)
    if (stats.games >= 1) stats.achievements.firstGame = true;
    if (stats.winsHuman >= 1) stats.achievements.firstWin = true;
    if (stats.games >= 10) stats.achievements.tenGames = true;
    if (stats.bestStreak >= 5) stats.achievements.streak5 = true;

    stats.level = computeLevel(stats.xp);
    saveStats();
  }

  function persistLastReplay() {
    // Only persist meaningful games (non-spectator)
    if (gameMode === 'spectator') return;
    if (replay.frames.length < 2) return;

    const data = {
      v: 1,
      createdAt: nowMs(),
      meta: {
        variant: variant || null,
        gameMode: gameMode || null,
        aiDifficulty: aiDifficulty || null,
        humanPlayerId: humanPlayerId || null,
        player1Name: player1Name || null,
        player2Name: player2Name || null
      },
      frames: replay.frames
    };

    try { localStorage.setItem(REPLAY_KEY, JSON.stringify(data)); } catch(_) {}
  }

  function loadLastReplay() {
    try {
      const raw = localStorage.getItem(REPLAY_KEY);
      const parsed = raw ? safeJSONParse(raw, null) : null;
      if (!parsed || typeof parsed !== 'object' || parsed.v !== 1) return null;
      if (!Array.isArray(parsed.frames) || parsed.frames.length < 2) return null;
      return parsed;
    } catch(_) {
      return null;
    }
  }

  // ---------------------------------------------------------
  // 9) Stats UI modal
  // ---------------------------------------------------------
  const statsBtn = $('#stats-btn');
  const winnerStatsBtn = $('#winner-stats-btn');
  const statsModal = $('#stats-modal');
  const statsCloseBtn = $('#stats-close-btn');
  const statsResetBtn = $('#stats-reset-btn');
  const statsExportBtn = $('#stats-export-btn');
  const statsContent = $('#stats-content');

  function formatDuration(ms) {
    const s = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(s / 60);
    const r = s % 60;
    if (m <= 0) return `${r}s`;
    return `${m}m ${r}s`;
  }

  function renderStats() {
    if (!statsContent) return;
    const games = stats.games || 0;
    const wins = stats.wins || 0;
    const losses = stats.losses || 0;
    // Win rate is only meaningful for AI-mode games (wins/losses are only tracked in AI mode)
    const aiGames = (stats.winsHuman || 0) + (stats.lossesHuman || 0);
    const winRate = aiGames > 0 ? Math.round(((stats.winsHuman || 0) / aiGames) * 100) : (games > 0 ? null : 0);
    const winRateStr = winRate !== null ? `${winRate}%` : '—';

    const lp = levelProgress(stats.xp);
    const lastReplay = loadLastReplay();
    const lastAt = lastReplay?.createdAt ? new Date(lastReplay.createdAt) : null;

    const achievements = [];
    if (stats.achievements?.firstGame) achievements.push('🎮 1');
    if (stats.achievements?.firstWin) achievements.push('🏆 1');
    if (stats.achievements?.tenGames) achievements.push('🔟');
    if (stats.achievements?.streak5) achievements.push('🔥 5');
    if (stats.achievements?.beatExpert) achievements.push('☠️ Expert');

    statsContent.innerHTML = `
      <div class="stats-grid">
        <div class="stat-card"><div class="k">${t('gamesPlayedLabel','Parties')}</div><div class="v">${games}</div></div>
        <div class="stat-card"><div class="k">${t('winRateLabel','Taux de victoire')}</div><div class="v">${winRateStr}</div></div>
        <div class="stat-card"><div class="k">${t('winsLabel','Victoires')}</div><div class="v">${wins}</div></div>
        <div class="stat-card"><div class="k">${t('lossesLabel','Défaites')}</div><div class="v">${losses}</div></div>
        <div class="stat-card"><div class="k">${t('movesLabel','Coups')}</div><div class="v">${stats.moves || 0}</div></div>
        <div class="stat-card"><div class="k">${t('capturesLabel','Captures')}</div><div class="v">${stats.captures || 0}</div></div>
        <div class="stat-card"><div class="k">${t('millsLabel','Moulins')}</div><div class="v">${stats.mills || 0}</div></div>
        <div class="stat-card"><div class="k">${t('bestStreakLabel','Meilleure série')}</div><div class="v">${stats.bestStreak || 0}</div></div>
      </div>

      <div class="stat-card" style="margin-top:10px;">
        <div class="k">${t('levelLabel','Niveau')} • ${t('xpLabel','XP')}</div>
        <div class="v">${lp.level} <span style="font-size:0.85rem; opacity:0.9;">(${stats.xp || 0} XP)</span></div>
        <div class="progress-bar" aria-label="XP progress"><div style="width:${lp.pct.toFixed(0)}%"></div></div>
        <div style="margin-top:6px; font-size:0.86rem; opacity:0.9;">${lp.into.toFixed(0)} / 100 XP</div>
      </div>

      <div class="stat-card" style="margin-top:10px;">
        <div class="k">${t('lastGameLabel','Dernière partie')}</div>
        <div style="margin-top:4px; font-size:0.95rem;">
          ${lastAt ? lastAt.toLocaleString() : '—'}
        </div>
        <div style="margin-top:8px; font-size:0.95rem;">
          <strong>🏆</strong> ${t('streakLabel','Série')} : ${stats.streak || 0}
          &nbsp;•&nbsp;
          <strong>🎖️</strong> ${achievements.length ? achievements.join('  ') : '—'}
        </div>
      </div>

      ${gameMode === 'ai' ? `
      <div class="stat-card" style="margin-top:10px;">
        <div class="k">AI</div>
        <div style="margin-top:4px; font-size:0.95rem;">
          ${t('winsLabel','Victoires')} (Vous) : ${stats.winsHuman || 0}
          &nbsp;•&nbsp;
          ${t('lossesLabel','Défaites')} : ${stats.lossesHuman || 0}
        </div>
      </div>` : ''}

      ${((stats.p1Wins || 0) + (stats.p2Wins || 0) > 0) ? `
      <div class="stat-card" style="margin-top:10px;">
        <div class="k">Local</div>
        <div style="margin-top:4px; font-size:0.95rem;">
          J1 : ${stats.p1Wins || 0} &nbsp;•&nbsp; J2 : ${stats.p2Wins || 0}
        </div>
      </div>` : ''}
    `;
  }

  function openStats() {
    if (!statsModal) return;
    renderStats();
    statsModal.classList.add('active');
    statsModal.setAttribute('aria-hidden', 'false');
  }
  function closeStats() {
    if (!statsModal) return;
    statsModal.classList.remove('active');
    statsModal.setAttribute('aria-hidden', 'true');
  }

  if (statsBtn) statsBtn.addEventListener('click', openStats);
  if (winnerStatsBtn) winnerStatsBtn.addEventListener('click', openStats);
  if (statsCloseBtn) statsCloseBtn.addEventListener('click', closeStats);
  if (statsModal) statsModal.addEventListener('click', (e) => { if (e.target === statsModal) closeStats(); });

  if (statsResetBtn) {
    statsResetBtn.addEventListener('click', () => {
      const ok = window.confirm(`${t('resetStats','Réinitialiser')} ?`);
      if (!ok) return;
      stats = defaultStats();
      saveStats();
      renderStats();
      showToast(t('toastStatsReset', 'Stats réinitialisées.'), 1800);
    });
  }

  if (statsExportBtn) {
    statsExportBtn.addEventListener('click', () => {
      try {
        const payload = JSON.stringify(stats, null, 2);
        const blob = new Blob([payload], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'tiddas_stats.json';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showToast(t('toastExported', 'Export généré.'), 1600);
      } catch(_) {}
    });
  }

  // ---------------------------------------------------------
  // 10) Replay UI modal
  // ---------------------------------------------------------
  const replayBtn = $('#replay-btn');
  const winnerReplayLastBtn = $('#winner-replay-last-btn');

  const replayModal = $('#replay-modal');
  const replayMetaEl = $('#replay-meta');
  const replayRange = $('#replay-range');
  const replaySpeed = $('#replay-speed');
  const replayPlayBtn = $('#replay-play-btn');
  const replayPrevBtn = $('#replay-prev-btn');
  const replayNextBtn = $('#replay-next-btn');
  const replayFirstBtn = $('#replay-first-btn');
  const replayLastBtn = $('#replay-last-btn');
  const replayExitBtn = $('#replay-exit-btn');

  function refreshReplayButtons() {
    const last = loadLastReplay();
    const has = !!last;
    if (replayBtn) replayBtn.disabled = !has;
    if (winnerReplayLastBtn) winnerReplayLastBtn.disabled = !has;
  }

  const replayStepEl = $('#replay-step-indicator');

  function updateReplayMeta() {
    if (!replayMetaEl) return;
    if (!replay.data) {
      replayMetaEl.textContent = '';
      if (replayStepEl) replayStepEl.textContent = '— / —';
      return;
    }
    const meta = replay.data.meta || {};
    const vName = (variantConfig && meta.variant && variantConfig[meta.variant]?.name)
      ? variantConfig[meta.variant].name
      : (meta.variant || '—');
    const mode = meta.gameMode || '—';
    const diff = meta.aiDifficulty ? ` · AI ${meta.aiDifficulty}` : '';
    const p1 = meta.player1Name || 'J1';
    const p2 = meta.player2Name || 'J2';
    replayMetaEl.textContent = `${vName} · ${mode}${diff} · ${p1} vs ${p2}`;
    if (replayStepEl) replayStepEl.textContent = `Coup ${replay.idx + 1} / ${replay.frames.length}`;
  }

  function setReplayIndex(i) {
    if (!replay.frames.length) return;
    replay.idx = clamp(i, 0, replay.frames.length - 1);
    if (replayRange) replayRange.value = String(replay.idx);
    updateReplayMeta();

    // Compute delta between frames for highlight
    try {
      const cur = replay.frames[replay.idx];
      const prev = replay.idx > 0 ? replay.frames[replay.idx - 1] : null;
      if (prev && Array.isArray(prev.board) && Array.isArray(cur.board)) {
        lastDelta = computeDelta(prev.board, cur.board);
      } else {
        lastDelta = { from: null, to: null, capture: null };
      }
    } catch(_) {}

    // Show frame (render only)
    try {
      state = clone(replay.frames[replay.idx]);
      state.selected = null;
      // Les frames minifiées ne contiennent pas ces champs requis par renderBoard()
      // en phase de déplacement. Sans eux, state.consecutivePiece[p] lève une TypeError
      // silencieusement avalée, et le plateau n'est jamais dessiné.
      if (!state.consecutivePiece) state.consecutivePiece = { 1: null, 2: null };
      if (!state.consecutiveCount) state.consecutiveCount = { 1: 0, 2: 0 };
      renderAll?.();
    } catch(e) { console.error('[Replay] renderAll error:', e); }
  }

  function stopReplayTimer() {
    if (replay.timer) {
      window.clearTimeout(replay.timer);
      replay.timer = null;
    }
    if (replayPlayBtn) replayPlayBtn.textContent = '▶️';
  }

  function stepReplay(delta) {
    stopReplayTimer();
    setReplayIndex(replay.idx + delta);
  }

  function playReplay() {
    if (!replay.frames.length) return;
    const speed = Number(replaySpeed?.value || '1') || 1;
    const delay = Math.max(180, Math.floor(700 / speed));

    const tick = () => {
      if (!replay.active) return;
      if (replay.idx >= replay.frames.length - 1) {
        stopReplayTimer();
        return;
      }
      setReplayIndex(replay.idx + 1);
      replay.timer = window.setTimeout(tick, delay);
    };

    if (replay.timer) {
      // pause
      stopReplayTimer();
    } else {
      if (replayPlayBtn) replayPlayBtn.textContent = '⏸️';
      replay.timer = window.setTimeout(tick, delay);
    }
  }

  function disableGameControls(disabled) {
    const ids = ['new-game', 'undo-btn', 'restart', 'surrender'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !!disabled;
    });
  }

  function openReplay() {
    const data = loadLastReplay();
    if (!data) {
      showToast(t('toastNoReplay', 'Aucune partie à rejouer.'), 1800);
      return;
    }

    replay.data = data;
    replay.frames = data.frames || [];
    replay.sigs = [];
    replay.idx = 0;

    // Backup current context to restore after replay
    replay.backup = {
      state: clone(state),
      moveHistory: clone(moveHistory),
      moveLog: clone(moveLog),
      gameMode: gameMode,
      variant: variant,
      aiDifficulty: aiDifficulty,
      humanPlayerId: humanPlayerId,
      aiPlayerId: aiPlayerId,
      player1Name: player1Name,
      player2Name: player2Name
    };

    // Rétablir les valeurs du replay pour que renderAll affiche correctement
    try {
      if (data.meta) {
        if (data.meta.variant) variant = data.meta.variant;
        if (data.meta.gameMode) gameMode = data.meta.gameMode;
        if (data.meta.aiDifficulty) aiDifficulty = data.meta.aiDifficulty;
        if (data.meta.humanPlayerId) humanPlayerId = data.meta.humanPlayerId;
        if (data.meta.player1Name) player1Name = data.meta.player1Name;
        if (data.meta.player2Name) player2Name = data.meta.player2Name;
      }
    } catch(_) {}

    replay.active = true;
    disableGameControls(true);
    stopReplayTimer();

    // S'assurer que le plateau de jeu est visible (masquer winner overlay)
    try {
      const winnerOverlay = document.getElementById('winner-overlay');
      if (winnerOverlay) winnerOverlay.classList.remove('active');
    } catch(_) {}

    // S'assurer que l'écran de jeu est actif
    try {
      const screens = document.querySelectorAll('.selection-area, .game-play-area');
      screens.forEach(s => s.classList.remove('active'));
      const gameArea = document.getElementById('game-play-area');
      if (gameArea) gameArea.classList.add('active');
      const header = document.getElementById('main-header');
      if (header) header.classList.add('hidden');
    } catch(_) {}

    // Ajouter classe sur body pour CSS
    document.body.classList.add('replay-active');

    if (replayModal) {
      replayModal.classList.add('active');
      replayModal.setAttribute('aria-hidden', 'false');
    }

    if (replayRange) {
      replayRange.min = '0';
      replayRange.max = String(Math.max(0, replay.frames.length - 1));
      replayRange.value = '0';
    }

    setReplayIndex(0);
  }

  function closeReplay() {
    stopReplayTimer();

    // Retirer classe body
    document.body.classList.remove('replay-active');

    if (replayModal) {
      replayModal.classList.remove('active');
      replayModal.setAttribute('aria-hidden', 'true');
    }

    // Restore previous context
    try {
      if (replay.backup) {
        gameMode = replay.backup.gameMode;
        variant = replay.backup.variant;
        aiDifficulty = replay.backup.aiDifficulty;
        humanPlayerId = replay.backup.humanPlayerId;
        aiPlayerId = replay.backup.aiPlayerId;
        player1Name = replay.backup.player1Name;
        player2Name = replay.backup.player2Name;
        moveHistory = replay.backup.moveHistory || [];
        moveLog = replay.backup.moveLog || [];
        state = replay.backup.state;
      }
      replay.active = false;
      disableGameControls(false);

      // Restaurer l'en-tête si nécessaire
      try {
        const header = document.getElementById('main-header');
        if (header && state?.phase) header.classList.add('hidden');
      } catch(_) {}

      renderAll?.();
      try { renderMoveLog?.(); } catch(_) {}
    } catch(_) {
      replay.active = false;
      disableGameControls(false);
    }
  }

  if (replayBtn) replayBtn.addEventListener('click', openReplay);
  if (winnerReplayLastBtn) winnerReplayLastBtn.addEventListener('click', openReplay);

  if (replayExitBtn) replayExitBtn.addEventListener('click', closeReplay);
  if (replayModal) replayModal.addEventListener('click', (e) => { if (e.target === replayModal) closeReplay(); });

  if (replayRange) replayRange.addEventListener('input', (e) => setReplayIndex(parseInt(e.target.value, 10) || 0));
  if (replayPlayBtn) replayPlayBtn.addEventListener('click', playReplay);
  if (replayPrevBtn) replayPrevBtn.addEventListener('click', () => stepReplay(-1));
  if (replayNextBtn) replayNextBtn.addEventListener('click', () => stepReplay(1));
  if (replayFirstBtn) replayFirstBtn.addEventListener('click', () => { stopReplayTimer(); setReplayIndex(0); });
  if (replayLastBtn) replayLastBtn.addEventListener('click', () => { stopReplayTimer(); setReplayIndex(replay.frames.length - 1); });

  // ---------------------------------------------------------
  // 11) PWA install + Service Worker (best effort)
  // ---------------------------------------------------------
  const installBtn = $('#install-btn');
  const installHelpModal = $('#install-help-modal');
  const installHelpCloseBtn = $('#install-help-close-btn');

  let deferredPrompt = null;

  function openInstallHelp() {
    if (!installHelpModal) return;
    installHelpModal.classList.add('active');
    installHelpModal.setAttribute('aria-hidden', 'false');
  }

  function closeInstallHelp() {
    if (!installHelpModal) return;
    installHelpModal.classList.remove('active');
    installHelpModal.setAttribute('aria-hidden', 'true');
  }

  if (installHelpCloseBtn) installHelpCloseBtn.addEventListener('click', closeInstallHelp);
  if (installHelpModal) installHelpModal.addEventListener('click', (e) => { if (e.target === installHelpModal) closeInstallHelp(); });



  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    if (installBtn) installBtn.disabled = false;
  });

  window.addEventListener('appinstalled', () => {
    showToast(t('toastInstalled', '✅ App installée.'), 1800);
    if (installBtn) installBtn.disabled = true;
  });

  if (installBtn) {
    installBtn.addEventListener('click', async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();


        try {
          const choice = await deferredPrompt.userChoice;
          if (choice && choice.outcome === 'accepted') {
            showToast(t('toastInstalled', '✅ App installée.'), 1800);
          } else {
            showToast(t('toastInstallUnavailable', 'ℹ️ Installation non disponible.'), 1800);
          }
        } catch(_) {}
        deferredPrompt = null;
      } else {
        openInstallHelp();
      }
    });
  }

  // Override manifest to ensure start_url points to the current file
  try {
    const manifest = {
      name: "Tiddas - Jeu Ancestral Amazigh",
      short_name: "Tiddas",
      description: "Jeu ancestral Amazigh (Tiddas/Moulin) - Patrimoine Kabyle",
      start_url: window.location.href,
      scope: "./",
      display: "standalone",
      orientation: "portrait-primary",
      background_color: "#fff3bf",
      theme_color: "#1e88e5",
      lang: document.documentElement.lang || "fr",
      icons: [
        { src: "data:image/svg+xml," + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 192 192\"><rect width=\"192\" height=\"192\" rx=\"32\" fill=\"#2c2722\"/><text x=\"96\" y=\"130\" font-size=\"110\" text-anchor=\"middle\" fill=\"#f0c850\">ⵣ</text></svg>'), sizes: "192x192", type: "image/svg+xml" },
        { src: "data:image/svg+xml," + encodeURIComponent('<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><rect width=\"512\" height=\"512\" rx=\"96\" fill=\"#2c2722\"/><text x=\"256\" y=\"350\" font-size=\"320\" text-anchor=\"middle\" fill=\"#f0c850\">ⵣ</text></svg>'), sizes: "512x512", type: "image/svg+xml" }
      ]
    };
    const blob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.getElementById('pwa-manifest');
    if (link) link.href = url;
  } catch(_) {}

  // Service worker registration via Blob (single-file)
  async function registerServiceWorker() {
    if (!('serviceWorker' in navigator)) return;
    if (!window.isSecureContext) return;

    // Avoid file:// and other unsupported contexts
    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') return;

    const swCode = `
      const CACHE = 'tiddas-cache-v7';
      const APP_SHELL = ${JSON.stringify(location.href)};
      self.addEventListener('install', (event) => {
        event.waitUntil((async () => {
          const cache = await caches.open(CACHE);
          try { await cache.addAll([APP_SHELL]); } catch(_) {}
          self.skipWaiting();
        })());
      });
      self.addEventListener('activate', (event) => {
        event.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => (k !== CACHE ? caches.delete(k) : Promise.resolve())));
          await self.clients.claim();
        })());
      });
      self.addEventListener('fetch', (event) => {
        const req = event.request;
        if (req.method !== 'GET') return;
        const url = new URL(req.url);
        if (url.origin !== location.origin) return;
        if (req.mode === 'navigate') {
          event.respondWith((async () => {
            const cache = await caches.open(CACHE);
            const cached = await cache.match(APP_SHELL) || await cache.match(req);
            if (cached) return cached;
            try {
              const fresh = await fetch(req);
              cache.put(req, fresh.clone());
              return fresh;
            } catch(e) {
              return cached || Response.error();
            }
          })());
          return;
        }
        event.respondWith((async () => {
          const cache = await caches.open(CACHE);
          const cached = await cache.match(req);
          if (cached) return cached;
          try {
            const fresh = await fetch(req);
            cache.put(req, fresh.clone());
            return fresh;
          } catch(e) {
            return cached || Response.error();
          }
        })());
      });
      self.addEventListener('message', (event) => {
        if (event.data === 'SKIP_WAITING') self.skipWaiting();
      });
    `;

    try {
      const blob = new Blob([swCode], { type: 'text/javascript' });
      const swUrl = URL.createObjectURL(blob);
      const reg = await navigator.serviceWorker.register(swUrl, { scope: './' });

      // Update available
      if (reg.waiting) {
        showToast(t('toastSWUpdate', '🔄 Mise à jour dispo : rechargez l\'app.'), 2400);
      } else {
        showToast(t('toastSWReady', '✅ Mode hors-ligne prêt.'), 1800);
      }

      // Cleanup blob URL (registration keeps an internal copy)
      try { URL.revokeObjectURL(swUrl); } catch(_) {}

      reg.addEventListener('updatefound', () => {
        showToast(t('toastSWUpdate', '🔄 Mise à jour dispo : rechargez l\'app.'), 2400);
      });
    } catch(_) {
      // Silent: some browsers block blob SW registration
    }
  }

  // Best-effort SW registration (enables offline + install eligibility when supported)
  try { registerServiceWorker(); } catch(_) {}


  // ---------------------------------------------------------
  // 12) Internal tests (debug overlay)
  // ---------------------------------------------------------
  const debugTestsBtn = document.getElementById('debug-tests-btn');

  function runInternalTests() {
    const results = [];
    const assert = (name, cond) => results.push({ name, ok: !!cond });

    const oldVariant = variant;
    try {
      // Adjacency sanity
      assert('Adjacency: 0↔1', isAdjacent?.(0, 1) === true);
      assert('Adjacency: 0↮6', isAdjacent?.(0, 6) === false);

      // Mill detection (horizontal)
      const b = Array(25).fill(null);
      b[0] = 1; b[1] = 1; b[2] = 1;
      assert('Mill (0,1,2) detected', (getFormedMills?.(0, 1, b) || []).length > 0);

      // Winner logic (normal): opponent <3 => current player wins
      variant = 'TIDDEST-no-diag';
      const bn = Array(25).fill(null);
      bn[0] = 1; bn[1] = 1; bn[2] = 1;
      bn[10] = 2; bn[11] = 2; // only 2 pieces for player 2
      const wn = getWinnerInState?.(bn, 'move'); // Need explicit 'move' phase (board has <20 pieces, can't auto-detect)
      assert('Winner normal when P2<3 => P1', wn === 1);

      // Winner logic (inverse): player with <3 wins
      variant = 'bessif-TIDDEST';
      const bi = Array(25).fill(null);
      // Player 1 only 2 pieces -> should be winner in inverse
      bi[0] = 1; bi[1] = 1;
      bi[10] = 2; bi[11] = 2; bi[12] = 2;
      const wi = getWinnerInState?.(bi, 'move'); // Need explicit 'move' phase (board has <20 pieces, can't auto-detect)
      assert('Winner inverse when P1<3 => P1', wi === 1);

      // Move generation placement: should have moves on empty board
      const bp = Array(25).fill(null);
      variant = 'TIDDEST-no-diag';
      const moves = generateAllPossibleMoves?.(1, bp, 'placement') || [];
      assert('Placement generates moves', Array.isArray(moves) && moves.length > 0);
    } catch (e) {
      console.warn(e);
      assert('Exception-free', false);
    } finally {
      variant = oldVariant;
    }

    const okCount = results.filter(r => r.ok).length;
    const total = results.length;

    console.groupCollapsed(`[Tiddas] Internal tests: ${okCount}/${total}`);
    results.forEach(r => console.log(`${r.ok ? '✅' : '❌'} ${r.name}`));
    console.groupEnd();

    showToast(`<span class="toast-strong">${okCount}/${total}</span> ${t('debugTestsDone','Tests terminés')}`, 2200);
  }

  if (debugTestsBtn) {
    debugTestsBtn.addEventListener('click', () => {
      showToast(t('debugTestsRunning','Tests en cours…'), 900);
      setTimeout(runInternalTests, 50);
    });
  }

  // ---------------------------------------------------------
  // 0) Language Splash Screen
  // ---------------------------------------------------------


  (function initLangSplash() {
    const splash = document.getElementById('lang-splash');
    if (!splash) return;

    // Check if language was previously chosen
    let savedLang = null;
    try { savedLang = localStorage.getItem('tiddas_lang'); } catch(_) {}

    function chooseLang(lang) {
      // Save preference
      try { localStorage.setItem('tiddas_lang', lang); } catch(_) {}

      // Apply language before hiding splash (always, including 'fr')
      try {
        const sel = document.getElementById('language-select');
        if (sel) sel.value = lang;
        if (typeof updateLanguage === 'function') updateLanguage(lang);
        else currentLanguage = lang;
      } catch(_) {}

      // Animate out
      splash.classList.add('hidden');
      setTimeout(() => {
        splash.style.display = 'none';
        // Focus first interactive element
        const firstBtn = document.querySelector('.version-card');
        if (firstBtn) firstBtn.focus();
      }, 480);
    }

    // If already chosen, skip splash instantly
    if (savedLang) {
      splash.style.display = 'none';
      // Apply saved language for all values (including 'fr')
      try {
        const sel = document.getElementById('language-select');
        if (sel) sel.value = savedLang;
      } catch(_) {}
      // Queue language application via _pendingLang (applied after init chain)
      if (savedLang !== 'fr') {
        window._pendingLang = savedLang;
      }
      // else: 'fr' is the default — no pendingLang needed
      return;
    }

    // Wire up splash buttons
    splash.querySelectorAll('.splash-lang-btn').forEach(btn => {
      btn.addEventListener('click', () => chooseLang(btn.dataset.lang));
      btn.addEventListener('keydown', e => {
        if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); chooseLang(btn.dataset.lang); }
      });
    });

    // Keyboard trap inside splash
    splash.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        const focusable = splash.querySelectorAll('.splash-lang-btn');
        if (!focusable.length) return;
        const first = focusable[0], last = focusable[focusable.length - 1];
        if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
      }
    });

    // Auto-focus first button
    setTimeout(() => splash.querySelector('.splash-lang-btn')?.focus(), 100);
  })();

  // ---------------------------------------------------------
  // 13) i18n hook for new buttons (titles/aria) + initial refresh
  // ---------------------------------------------------------
  const applyNewI18nAttrs = () => {
    const btns = [
      { id: 'install-btn', key: 'installApp' },
      { id: 'stats-btn', key: 'stats' },
      { id: 'guided-btn', key: 'guidedMode' },
      { id: 'replay-btn', key: 'replayLast' },
      { id: 'theme-btn', key: 'btnTheme' },
      { id: 'sound-btn', key: 'btnSound' },
      { id: 'settings-fab', key: 'btnSettings' }
    ];
    btns.forEach(b => {
      const el = document.getElementById(b.id);
      if (!el) return;
      const label = t(b.key, b.key);
      el.setAttribute('aria-label', label);
      el.title = label;
    });

    const winnerReplay = document.getElementById('winner-replay-last-btn');
    if (winnerReplay) {
      winnerReplay.setAttribute('aria-label', t('replayLast','Replay'));
      winnerReplay.title = t('replayLast','Replay');
    }
    const winnerStats = document.getElementById('winner-stats-btn');
    if (winnerStats) {
      winnerStats.setAttribute('aria-label', t('stats','Stats'));
      winnerStats.title = t('stats','Stats');
    }
  };

  if (typeof updateLanguage === 'function') {
    const __origUpdateLang = updateLanguage;
    updateLanguage = function(lang) {
      const r = __origUpdateLang.call(this, lang);
      try { applyNewI18nAttrs(); renderStats(); updateReplayMeta(); } catch(_) {}
      return r;
    };
  }

  // Initial load
  loadStats();
  refreshReplayButtons();
  applyNewI18nAttrs();

  // Apply pending language from splash (if user previously chose kabyle)
  if (window._pendingLang && window._pendingLang !== 'fr') {
    try {
      if (typeof updateLanguage === 'function') updateLanguage(window._pendingLang);
    } catch(_) {}
    delete window._pendingLang;
  }

  // Defer SW registration to idle-ish moment


    // ============================================================
    // === INITIALISATION (DOMContentLoaded unique) ===
    // ============================================================
    document.addEventListener('DOMContentLoaded', () => {

            // Load saved preferences
            try {
                const savedTheme = localStorage.getItem('tiddas_theme');
                if (savedTheme !== null) {
                    const idx = parseInt(savedTheme, 10);
                    currentTheme = Number.isFinite(idx) ? ((idx % THEMES.length) + THEMES.length) % THEMES.length : 0;
                }
                const savedSound = localStorage.getItem('tiddas_sound');
                if (savedSound !== null) soundEnabled = savedSound === '1';
            } catch(e){}
            applyTheme(currentTheme);
            const soundBtn = document.getElementById('sound-btn');
            if (soundBtn) {
                const sndLabel = (typeof translations !== 'undefined' && translations[currentLanguage] && translations[currentLanguage].btnSound) || 'Son';
                soundBtn.innerHTML = (soundEnabled ? '🔊 ' : '🔇 ') + '<span style="font-size:0.78rem;" data-i18n="btnSound">' + sndLabel + '</span>';
                soundBtn.classList.toggle('sound-off', !soundEnabled);
                soundBtn.addEventListener('click', toggleSound);
            }
            const themeBtn = document.getElementById('theme-btn');
            if (themeBtn) { themeBtn.addEventListener('click', cycleTheme); }

            // Settings FAB toggle
            const settingsFab = document.getElementById('settings-fab');
            const settingsTray = document.getElementById('settings-tray');
            if (settingsFab && settingsTray) {
                settingsFab.addEventListener('click', () => {
                    const isOpen = settingsTray.classList.toggle('open');
                    settingsFab.classList.toggle('open', isOpen);
                    settingsFab.setAttribute('aria-expanded', isOpen);
                });
                document.addEventListener('click', (e) => {
                    if (!settingsFab.contains(e.target) && !settingsTray.contains(e.target)) {
                        settingsTray.classList.remove('open');
                        settingsFab.classList.remove('open');
                    }
                });
            }

            // Spectator mode button
            const spectatorBtn = document.getElementById('play-spectator-btn');
            if (spectatorBtn) {
                spectatorBtn.addEventListener('click', () => {
                    gameMode = 'spectator';
                    aiDifficulty = aiDifficulty || 3;
                    showScreen('ai-difficulty-selection-area');
                });
            }

            // Spectator speed change
            const speedSelect = document.getElementById('spectator-speed');
            if (speedSelect) { speedSelect.addEventListener('change', e => { spectatorDelay = parseInt(e.target.value); }); }

            // Save/Resume notification
            const btnResume = document.getElementById('btn-resume');
            const btnDiscard = document.getElementById('btn-discard');
            if (btnResume) btnResume.addEventListener('click', loadAndResume);
            if (btnDiscard) btnDiscard.addEventListener('click', () => { clearSave(); hideSaveNotification(); });

            // Check for saved game on startup
            setTimeout(checkForSavedGame, 800);

            // PWA Manifest creation
            try {
                const manifest = {
                    name: "Tiddas - Jeu Ancestral Amazigh",
                    short_name: "Tiddas",
                    description: "Jeu ancestral Amazigh (Tiddas/Moulin) - Patrimoine Kabyle",
                    start_url: "./",
                    display: "standalone",
                    orientation: "portrait-primary",
                    background_color: "#fff3bf",
                    theme_color: "#1e88e5",
                    lang: "fr",
                    icons: [
                        { src: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj4KPGRlZnM+CiAgPGxpbmVhckdyYWRpZW50IGlkPSJiZyIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjEiPgogICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iI2ZmZjNiZiIvPgogICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZDdmM2ZmIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICA8bGluZWFyR3JhZGllbnQgaWQ9ImJkIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMSI+CiAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjZThjOTdhIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiNiODkwM2EiLz4KICA8L2xpbmVhckdyYWRpZW50PgogIDxsaW5lYXJHcmFkaWVudCBpZD0iY2wiIHgxPSIwIiB5MT0iMCIgeDI9IjEiIHkyPSIxIj4KICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiNmNWRmYTAiLz4KICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3RvcC1jb2xvcj0iI2Q0YTg1NSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHJhZGlhbEdyYWRpZW50IGlkPSJzMSIgY3g9IjM1JSIgY3k9IjMwJSIgcj0iNjUlIj4KICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiM2NjYiLz4KICAgIDxzdG9wIG9mZnNldD0iNTUlIiBzdG9wLWNvbG9yPSIjMWExYTFhIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiLz4KICA8L3JhZGlhbEdyYWRpZW50PgogIDxyYWRpYWxHcmFkaWVudCBpZD0iczIiIGN4PSIzNSUiIGN5PSIzMCUiIHI9IjY1JSI+CiAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjZmZmIi8+CiAgICA8c3RvcCBvZmZzZXQ9IjU1JSIgc3RvcC1jb2xvcj0iI2U4ZThlOCIvPgogICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjYmJiIi8+CiAgPC9yYWRpYWxHcmFkaWVudD4KICA8ZmlsdGVyIGlkPSJmcyI+PGZlRHJvcFNoYWRvdyBkeD0iMCIgZHk9IjMiIHN0ZERldmlhdGlvbj0iNiIgZmxvb2Qtb3BhY2l0eT0iMC4zNSIvPjwvZmlsdGVyPgogIDxmaWx0ZXIgaWQ9ImZwIj48ZmVEcm9wU2hhZG93IGR4PSIwIiBkeT0iMiIgc3RkRGV2aWF0aW9uPSIzIiBmbG9vZC1vcGFjaXR5PSIwLjQiLz48L2ZpbHRlcj4KPC9kZWZzPgo8cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgcng9Ijk2IiBmaWxsPSJ1cmwoI2JnKSIvPgo8cmVjdCB4PSIxNCIgeT0iMTQiIHdpZHRoPSI0ODQiIGhlaWdodD0iNDg0IiByeD0iODIiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzFlODhlNSIgc3Ryb2tlLXdpZHRoPSI2IiBvcGFjaXR5PSIwLjIiLz4KPHJlY3QgeD0iMjYiIHk9IjI2IiB3aWR0aD0iNDYwIiBoZWlnaHQ9IjQ2MCIgcng9IjcwIiBmaWxsPSJub25lIiBzdHJva2U9IiMyZTdkMzIiIHN0cm9rZS13aWR0aD0iMyIgb3BhY2l0eT0iMC4xMiIvPgo8ZyBmaWxsPSIjZDMyZjJmIiBvcGFjaXR5PSIwLjM1Ij4KICA8cG9seWdvbiBwb2ludHM9IjUyLDUyIDcyLDMyIDkyLDUyIDcyLDcyIi8+CiAgPHBvbHlnb24gcG9pbnRzPSI0MjAsNTIgNDQwLDMyIDQ2MCw1MiA0NDAsNzIiLz4KICA8cG9seWdvbiBwb2ludHM9IjUyLDQ2MCA3Miw0NDAgOTIsNDYwIDcyLDQ4MCIvPgogIDxwb2x5Z29uIHBvaW50cz0iNDIwLDQ2MCA0NDAsNDQwIDQ2MCw0NjAgNDQwLDQ4MCIvPgo8L2c+Cjx0ZXh0IHg9IjI1NiIgeT0iMTAwIiBmb250LWZhbWlseT0iQXJpYWwgQmxhY2ssQXJpYWwsc2Fucy1zZXJpZiIgZm9udC1zaXplPSI0NCIgZm9udC13ZWlnaHQ9IjkwMCIgbGV0dGVyLXNwYWNpbmc9IjciIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiNjNjI4MjgiIG9wYWNpdHk9IjAuOSI+VElEREFTPC90ZXh0Pgo8cmVjdCB4PSIxMDYiIHk9IjExNiIgd2lkdGg9IjMwMCIgaGVpZ2h0PSIzMDAiIHJ4PSIxNCIgZmlsbD0idXJsKCNiZCkiIGZpbHRlcj0idXJsKCNmcykiLz4KPGcgZmlsbD0idXJsKCNjbCkiPgogIDxyZWN0IHg9IjExMCIgeT0iMTIwIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTY4IiB5PSIxMjAiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyMjYiIHk9IjEyMCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjI4NCIgeT0iMTIwIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMzQyIiB5PSIxMjAiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxMTAiIHk9IjE3OCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjE2OCIgeT0iMTc4IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjI2IiB5PSIxNzgiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyODQiIHk9IjE3OCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjM0MiIgeT0iMTc4IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTEwIiB5PSIyMzYiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxNjgiIHk9IjIzNiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjIyNiIgeT0iMjM2IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjg0IiB5PSIyMzYiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIzNDIiIHk9IjIzNiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjExMCIgeT0iMjk0IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMTY4IiB5PSIyOTQiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyMjYiIHk9IjI5NCIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjI4NCIgeT0iMjk0IiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMzQyIiB5PSIyOTQiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIxMTAiIHk9IjM1MiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjE2OCIgeT0iMzUyIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CiAgPHJlY3QgeD0iMjI2IiB5PSIzNTIiIHdpZHRoPSI1NCIgaGVpZ2h0PSI1NCIgcng9IjUiLz4KICA8cmVjdCB4PSIyODQiIHk9IjM1MiIgd2lkdGg9IjU0IiBoZWlnaHQ9IjU0IiByeD0iNSIvPgogIDxyZWN0IHg9IjM0MiIgeT0iMzUyIiB3aWR0aD0iNTQiIGhlaWdodD0iNTQiIHJ4PSI1Ii8+CjwvZz4KPGcgZmlsdGVyPSJ1cmwoI2ZwKSI+CiAgPGNpcmNsZSBjeD0iMTM3IiBjeT0iMTQ3IiByPSIyMyIgZmlsbD0idXJsKCNzMSkiLz48Y2lyY2xlIGN4PSIxMzAiIGN5PSIxNDAiIHI9IjciIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjMiLz4KICA8Y2lyY2xlIGN4PSIyNTMiIGN5PSIxNDciIHI9IjIzIiBmaWxsPSJ1cmwoI3MxKSIvPjxjaXJjbGUgY3g9IjI0NiIgY3k9IjE0MCIgcj0iNyIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuMyIvPgogIDxjaXJjbGUgY3g9IjE5NSIgY3k9IjIwNSIgcj0iMjMiIGZpbGw9InVybCgjczEpIi8+PGNpcmNsZSBjeD0iMTg4IiBjeT0iMTk4IiByPSI3IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC4zIi8+CiAgPGNpcmNsZSBjeD0iMzY5IiBjeT0iMjYzIiByPSIyMyIgZmlsbD0idXJsKCNzMSkiLz48Y2lyY2xlIGN4PSIzNjIiIGN5PSIyNTYiIHI9IjciIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjMiLz4KICA8Y2lyY2xlIGN4PSIzMTEiIGN5PSIzMjEiIHI9IjIzIiBmaWxsPSJ1cmwoI3MxKSIvPjxjaXJjbGUgY3g9IjMwNCIgY3k9IjMxNCIgcj0iNyIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuMyIvPgogIDxjaXJjbGUgY3g9IjM2OSIgY3k9IjE0NyIgcj0iMjMiIGZpbGw9InVybCgjczIpIi8+PGNpcmNsZSBjeD0iMzYyIiBjeT0iMTQwIiByPSI4IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC42Ii8+CiAgPGNpcmNsZSBjeD0iMzExIiBjeT0iMjA1IiByPSIyMyIgZmlsbD0idXJsKCNzMikiLz48Y2lyY2xlIGN4PSIzMDQiIGN5PSIxOTgiIHI9IjgiIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjYiLz4KICA8Y2lyY2xlIGN4PSIyNTMiIGN5PSIyNjMiIHI9IjIzIiBmaWxsPSJ1cmwoI3MyKSIvPjxjaXJjbGUgY3g9IjI0NiIgY3k9IjI1NiIgcj0iOCIgZmlsbD0id2hpdGUiIG9wYWNpdHk9IjAuNiIvPgogIDxjaXJjbGUgY3g9IjEzNyIgY3k9IjMyMSIgcj0iMjMiIGZpbGw9InVybCgjczIpIi8+PGNpcmNsZSBjeD0iMTMwIiBjeT0iMzE0IiByPSI4IiBmaWxsPSJ3aGl0ZSIgb3BhY2l0eT0iMC42Ii8+CiAgPGNpcmNsZSBjeD0iMTk1IiBjeT0iMzc5IiByPSIyMyIgZmlsbD0idXJsKCNzMikiLz48Y2lyY2xlIGN4PSIxODgiIGN5PSIzNzIiIHI9IjgiIGZpbGw9IndoaXRlIiBvcGFjaXR5PSIwLjYiLz4KPC9nPgo8dGV4dCB4PSIyNTYiIHk9IjQ2NCIgZm9udC1mYW1pbHk9InNlcmlmIiBmb250LXNpemU9IjM4IiBmb250LXdlaWdodD0iYm9sZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzE1NjVjMCIgb3BhY2l0eT0iMC44NSI+JiMxMDk3OTs8L3RleHQ+Cjwvc3ZnPg==", sizes: "192x192 512x512 any", type: "image/svg+xml", purpose: "any maskable" }
                    ]
                };
                const blob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.getElementById('pwa-manifest');
                if (link) link.href = url;
            } catch(e){}

            languageSelect.addEventListener('change', (e) => updateLanguage(e.target.value));
            
            document.querySelectorAll('.version-card').forEach(card => card.addEventListener('click', () => {
                versionCards.forEach(vc => vc.classList.remove('active'));
                card.classList.add('active');
                variant = card.dataset.variant;
                showScreen('mode-selection-area');
            }));
            
            document.getElementById('play-ai-btn').addEventListener('click', () => { 
                gameMode = 'ai'; 
                showScreen('ai-difficulty-selection-area'); 
            });
            
            document.getElementById('play-offline-btn').addEventListener('click', () => { 
                gameMode = 'local'; 
                showScreen('player-setup-area'); 
            });
            
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.addEventListener('click', () => {
                aiDifficulty = parseInt(btn.dataset.level);
                if (gameMode === 'spectator') {
                    variant = variant || 'TIDDEST-no-diag';
                    startSpectatorGame();
                } else {
                    showScreen('player-setup-area');
                }
            }));
            
            document.getElementById('start-game-from-setup').addEventListener('click', startGame);
            
            document.getElementById('back-to-versions-btn').addEventListener('click', () => showScreen('version-selection-area'));
            
            document.getElementById('back-to-modes-btn').addEventListener('click', () => showScreen('mode-selection-area'));
            
            document.getElementById('back-to-modes-from-setup-btn').addEventListener('click', () => {
                if(gameMode === 'ai') showScreen('ai-difficulty-selection-area');
                else showScreen('mode-selection-area');
            });
            
            colorOptions.forEach(option => option.addEventListener('click', () => {
                humanPlayerId = parseInt(option.dataset.player);
                updateColorOptionSelection(humanPlayerId);
            }));
            
            document.getElementById('new-game').addEventListener('click', () => { hideWinnerAnimation(); showScreen('version-selection-area'); });
            document.getElementById('restart').addEventListener('click', startGame);
            winnerReplayButton.addEventListener('click', hideWinnerAnimation);
            undoBtn.addEventListener('click', handleUndo);
            
            surrenderBtn.addEventListener('click', () => {
                showConfirmationModal('surrender', 'surrenderConfirm', handleSurrender);
            });
            
            modalConfirmBtn.addEventListener('click', () => {
                if (onConfirmCallback) onConfirmCallback();
                hideConfirmationModal();
            });
            
            modalCancelBtn.addEventListener('click', hideConfirmationModal);
            
            confirmationModal.addEventListener('click', (e) => {
                if (e.target === confirmationModal) hideConfirmationModal();
            });
            
            showRulesBtn.addEventListener('click', showRulesModal);
            rulesCloseBtn.addEventListener('click', hideRulesModal);
            rulesModal.addEventListener('click', (e) => {
                if(e.target === rulesModal) hideRulesModal();
            });
            
            updateLanguage(languageSelect.value || 'fr');
            showScreen('version-selection-area');


            // Initialize replay button states
            if (typeof refreshReplayButtons === 'function') refreshReplayButtons();

            // Init lang splash — already auto-executed as IIFE above

            // A11y board
            if (typeof attachBoardA11yOnce === 'function') attachBoardA11yOnce();

            // Guided mode button
            if (typeof applyGuidedBtn === 'function') applyGuidedBtn();


        // Service worker
        setTimeout(registerServiceWorker, 1200);

    }); // fin DOMContentLoaded

})(); // fin IIFE principale
</script>
</body></html>
